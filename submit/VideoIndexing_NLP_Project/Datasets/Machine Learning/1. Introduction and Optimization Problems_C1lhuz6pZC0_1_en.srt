1
00:00:00,000 --> 00:00:00,790


2
00:00:00,790 --> 00:00:03,129
The following content is
provided under a Creative

3
00:00:03,129 --> 00:00:04,549
Commons license.

4
00:00:04,549 --> 00:00:06,759
Your support will help
MIT OpenCourseWare

5
00:00:06,759 --> 00:00:10,849
continue to offer high quality
educational resources for free.

6
00:00:10,849 --> 00:00:13,390
To make a donation or to
view additional materials

7
00:00:13,390 --> 00:00:17,320
from hundreds of MIT courses,
visit MIT OpenCourseWare

8
00:00:17,320 --> 00:00:18,570
at ocw.mit.edu.

9
00:00:18,570 --> 00:00:30,961


10
00:00:30,961 --> 00:00:36,450
JOHN GUTTAG: All right,
welcome to the 60002,

11
00:00:36,450 --> 00:00:40,270
or if you were in 600,
the second half of 600.

12
00:00:40,270 --> 00:00:42,440
I'm John Guttag.

13
00:00:42,439 --> 00:00:44,589
Let me start with a few
administrative things.

14
00:00:44,590 --> 00:00:47,510


15
00:00:47,509 --> 00:00:48,769
What's the workload?

16
00:00:48,770 --> 00:00:50,900
There are problem sets.

17
00:00:50,899 --> 00:00:52,850
They'll all be
programming problems

18
00:00:52,850 --> 00:00:56,210
much in the style of 60001.

19
00:00:56,210 --> 00:00:59,679
And the goal-- really twofold.

20
00:00:59,679 --> 00:01:03,469
60001 problem sets
were mostly about you

21
00:01:03,469 --> 00:01:06,590
learning to be a programmer.

22
00:01:06,590 --> 00:01:08,359
A lot of that carries over.

23
00:01:08,359 --> 00:01:12,530
No one learns to be a
programmer in half a semester.

24
00:01:12,530 --> 00:01:15,469
So a lot of it is to
improve your skills,

25
00:01:15,469 --> 00:01:18,620
but also there's a
lot more, I would say,

26
00:01:18,620 --> 00:01:24,380
conceptual, algorithmic
material in 60002,

27
00:01:24,379 --> 00:01:26,269
and the problem
sets are designed

28
00:01:26,269 --> 00:01:28,280
to help cement that
as well as just

29
00:01:28,280 --> 00:01:31,260
to give you
programming experience.

30
00:01:31,260 --> 00:01:34,530
Finger exercises, small things.

31
00:01:34,530 --> 00:01:39,150
If they're taking you more
than 15 minutes, let us know.

32
00:01:39,150 --> 00:01:42,090
They really shouldn't,
and they're generally

33
00:01:42,090 --> 00:01:45,270
designed to help you learn
a single concept, usually

34
00:01:45,269 --> 00:01:48,000
a programming concept.

35
00:01:48,000 --> 00:01:50,670
Reading assignments
in the textbooks,

36
00:01:50,670 --> 00:01:54,450
I've already posted the
first reading assignment,

37
00:01:54,450 --> 00:01:58,439
and essentially they should
provide you a very different

38
00:01:58,439 --> 00:02:00,299
take on the same
material we're covering

39
00:02:00,299 --> 00:02:03,539
in lectures and recitations.

40
00:02:03,540 --> 00:02:06,270
We've tried to choose
different examples for lectures

41
00:02:06,269 --> 00:02:08,519
and from the textbooks
for the most part,

42
00:02:08,520 --> 00:02:12,330
so you get to see things in
two slightly different ways.

43
00:02:12,330 --> 00:02:16,680
There'll be a final exam
based upon all of the above.

44
00:02:16,680 --> 00:02:18,599
All right,
prerequisites-- experience

45
00:02:18,599 --> 00:02:22,829
writing object-oriented
programs in Python, preferably

46
00:02:22,830 --> 00:02:27,570
Python 3.5.

47
00:02:27,569 --> 00:02:31,259
Familiarity with concepts
of computational complexity.

48
00:02:31,259 --> 00:02:32,949
You'll see even in
today's lecture,

49
00:02:32,949 --> 00:02:35,310
we'll be assuming that.

50
00:02:35,310 --> 00:02:37,650
Familiarity with some
simple algorithms.

51
00:02:37,650 --> 00:02:40,870


52
00:02:40,870 --> 00:02:45,280
If you took 60001 or you
took the 60001 advanced

53
00:02:45,280 --> 00:02:49,360
standing exam, you'll be fine.

54
00:02:49,360 --> 00:02:51,910
Odds are you'll be
fine anyway, but that's

55
00:02:51,909 --> 00:02:54,259
the safest way to do it.

56
00:02:54,259 --> 00:02:56,889
So the programming
assignments are

57
00:02:56,889 --> 00:02:59,500
going to be a bit
easier, at least that's

58
00:02:59,500 --> 00:03:01,840
what students have
reported in the past,

59
00:03:01,840 --> 00:03:04,930
because they'll be more focused
on the problem to be solved

60
00:03:04,930 --> 00:03:07,240
than on the actual programming.

61
00:03:07,240 --> 00:03:10,000
The lecture content,
more abstract.

62
00:03:10,000 --> 00:03:11,409
The lectures will be--

63
00:03:11,409 --> 00:03:13,270
and maybe I'm speaking
euphemistically--

64
00:03:13,270 --> 00:03:15,260
a bit faster paced.

65
00:03:15,259 --> 00:03:18,669
So hang on to your seats.

66
00:03:18,669 --> 00:03:21,669
And the course is really
less about programming

67
00:03:21,669 --> 00:03:25,689
and more about dipping your toe
into the exotic world of data

68
00:03:25,689 --> 00:03:27,879
science.

69
00:03:27,879 --> 00:03:30,759
We do want you to hone
your programming skills.

70
00:03:30,759 --> 00:03:33,099
There'll be a few
additional bits of Python.

71
00:03:33,099 --> 00:03:37,870
Today, for example, we'll
talk about lambda abstraction.

72
00:03:37,870 --> 00:03:40,420
Inevitably, some comments
about software engineering,

73
00:03:40,419 --> 00:03:45,459
how to structure your code,
more emphasis in using packages.

74
00:03:45,460 --> 00:03:47,290
Hopefully it will go
a little bit smoother

75
00:03:47,289 --> 00:03:51,370
than in the last
problem set in 60001.

76
00:03:51,370 --> 00:03:54,550
And finally, it's the old
joke about programming

77
00:03:54,550 --> 00:04:00,390
that somebody walks up to a
taxi driver in New York City

78
00:04:00,389 --> 00:04:01,829
and says, "I'm lost.

79
00:04:01,830 --> 00:04:03,930
How do I get to Carnegie Hall?"

80
00:04:03,930 --> 00:04:05,819
The taxi driver
turns to the person

81
00:04:05,819 --> 00:04:09,789
and says, "practice,
practice, practice."

82
00:04:09,789 --> 00:04:12,090
And that's really the only
way to learn to program

83
00:04:12,090 --> 00:04:14,134
is practice, practice, practice.

84
00:04:14,134 --> 00:04:17,289


85
00:04:17,290 --> 00:04:19,990
The main topic of the
course is what I think

86
00:04:19,990 --> 00:04:22,579
of as computational models.

87
00:04:22,579 --> 00:04:24,969
How do we use
computation to understand

88
00:04:24,970 --> 00:04:28,770
the world in which we live?

89
00:04:28,769 --> 00:04:29,819
What is a model?

90
00:04:29,819 --> 00:04:33,180
To me I think of it as
an experimental device

91
00:04:33,180 --> 00:04:35,879
that can help us to either
understand something that

92
00:04:35,879 --> 00:04:40,980
has happened, to sort of build
a model that explains phenomena

93
00:04:40,980 --> 00:04:44,250
we see every day,
or a model that

94
00:04:44,250 --> 00:04:46,319
will allow us to predict
the future, something

95
00:04:46,319 --> 00:04:48,719
that hasn't happened.

96
00:04:48,720 --> 00:04:51,150
So you can think of, for
example, a climate change

97
00:04:51,149 --> 00:04:52,319
model.

98
00:04:52,319 --> 00:04:55,529
We can build models that sort
of explain how the climate has

99
00:04:55,529 --> 00:04:58,379
changed over the
millennia, and then we

100
00:04:58,379 --> 00:05:00,449
can build probably a
slightly different model

101
00:05:00,449 --> 00:05:03,329
that might predict what it
will be like in the future.

102
00:05:03,329 --> 00:05:06,629


103
00:05:06,629 --> 00:05:10,620
So essentially
what's happening is

104
00:05:10,620 --> 00:05:17,639
science is moving out of the
wet lab and into the computer.

105
00:05:17,639 --> 00:05:19,829
Increasingly, I'm sure
you all see this--

106
00:05:19,829 --> 00:05:22,050
those of you who
are science majors--

107
00:05:22,050 --> 00:05:25,680
an increasing reliance on
computation rather than

108
00:05:25,680 --> 00:05:28,650
traditional experimentation.

109
00:05:28,649 --> 00:05:32,039
As we'll talk about,
traditional experimentation

110
00:05:32,040 --> 00:05:34,980
is and will remain
important, but now it

111
00:05:34,980 --> 00:05:39,300
has to really be
supplemented by computation.

112
00:05:39,300 --> 00:05:41,790
We'll talk about three
kinds of models--

113
00:05:41,790 --> 00:05:48,240
optimization models, statistical
models, and simulation models.

114
00:05:48,240 --> 00:05:52,610
So let's talk first about
optimization models.

115
00:05:52,610 --> 00:05:56,220
An optimization model
is a very simple thing.

116
00:05:56,220 --> 00:05:59,600
We start with an objective
function that's either

117
00:05:59,600 --> 00:06:03,340
to be maximized or minimized.

118
00:06:03,339 --> 00:06:06,609
So for, example, if I'm going
from New York to Boston,

119
00:06:06,610 --> 00:06:09,400
I might want to find a
route by car or plane

120
00:06:09,399 --> 00:06:13,929
or train that minimizes
the total travel time.

121
00:06:13,930 --> 00:06:15,610
So my objective
function would be

122
00:06:15,610 --> 00:06:19,870
the number of minutes spent in
transit getting from a to b.

123
00:06:19,870 --> 00:06:23,379


124
00:06:23,379 --> 00:06:28,519
We then often have to layer on
top of that objective function

125
00:06:28,519 --> 00:06:34,379
a set of constraints, sometimes
empty, that we have to obey.

126
00:06:34,379 --> 00:06:38,569
So maybe the fastest way to
get from New York to Boston

127
00:06:38,569 --> 00:06:42,569
is to take a plane, but I
only have $100 to spend.

128
00:06:42,569 --> 00:06:44,709
So that option is off the table.

129
00:06:44,709 --> 00:06:47,689
So I have the constraints
there on the amount

130
00:06:47,689 --> 00:06:50,029
of money I can spend.

131
00:06:50,029 --> 00:06:53,479
Or maybe I have to be
in Boston before 5:00 PM

132
00:06:53,480 --> 00:06:58,220
and while the bus would
get me there for $15,

133
00:06:58,220 --> 00:07:00,480
it won't get me
there before 5:00.

134
00:07:00,480 --> 00:07:04,460
And so maybe what I'm
left with is driving,

135
00:07:04,459 --> 00:07:05,870
something like that.

136
00:07:05,870 --> 00:07:08,569
So objective function,
something you're either

137
00:07:08,569 --> 00:07:12,949
minimizing or maximizing,
and a set of constraints

138
00:07:12,949 --> 00:07:16,699
that eliminate some solutions.

139
00:07:16,699 --> 00:07:19,550
And as we'll see, there's
an asymmetry here.

140
00:07:19,550 --> 00:07:22,790
We handle these two
things differently.

141
00:07:22,790 --> 00:07:26,850


142
00:07:26,850 --> 00:07:28,550
We use these things
all the time.

143
00:07:28,550 --> 00:07:31,220


144
00:07:31,220 --> 00:07:35,420
I commute to work using Waze,
which essentially is solving--

145
00:07:35,420 --> 00:07:38,660
not very well, I believe--
an optimization problem

146
00:07:38,660 --> 00:07:42,380
to minimize my time
from home to here.

147
00:07:42,379 --> 00:07:47,139
When you travel, maybe you log
into various advisory programs

148
00:07:47,139 --> 00:07:51,469
that try and optimize
things for you.

149
00:07:51,470 --> 00:07:52,970
They're all over the place.

150
00:07:52,970 --> 00:07:58,280
Today you really can't avoid
using optimization algorithm

151
00:07:58,279 --> 00:07:59,449
as you get through life.

152
00:07:59,449 --> 00:08:03,199


153
00:08:03,199 --> 00:08:04,019
Pretty abstract.

154
00:08:04,019 --> 00:08:07,099
Let's talk about a specific
optimization problem

155
00:08:07,100 --> 00:08:10,460
called the knapsack problem.

156
00:08:10,459 --> 00:08:12,949
The first time I talked
about the knapsack problem

157
00:08:12,949 --> 00:08:15,889
I neglected to show a
picture of a knapsack,

158
00:08:15,889 --> 00:08:17,930
and I was 10 minutes
into it before I

159
00:08:17,930 --> 00:08:21,889
realized most of the class had
no idea what a knapsack was.

160
00:08:21,889 --> 00:08:25,370
It's what we old people
used to call a backpack,

161
00:08:25,370 --> 00:08:30,389
and they used to look more
like that than they look today.

162
00:08:30,389 --> 00:08:34,918
So the knapsack
problem involves--

163
00:08:34,918 --> 00:08:39,620
usually it's told in terms of a
burglar who breaks into a house

164
00:08:39,620 --> 00:08:42,048
and wants to steal
a bunch of stuff

165
00:08:42,048 --> 00:08:44,240
but has a knapsack
that will only

166
00:08:44,240 --> 00:08:48,740
hold a finite amount of stuff
that he or she wishes to steal.

167
00:08:48,740 --> 00:08:53,750
And so the burglar has to
solve the optimization problem

168
00:08:53,750 --> 00:08:57,919
of stealing the stuff with
the most value while obeying

169
00:08:57,919 --> 00:09:03,110
the constraint that it all
has to fit in the knapsack.

170
00:09:03,110 --> 00:09:07,740
So we have an
objective function.

171
00:09:07,740 --> 00:09:10,529
I'll get the most for
this when I fence it.

172
00:09:10,529 --> 00:09:13,949
And a constraint, it has
to fit in my backpack.

173
00:09:13,950 --> 00:09:17,100
And you can guess
which of these might be

174
00:09:17,100 --> 00:09:18,580
the most valuable items here.

175
00:09:18,580 --> 00:09:21,440


176
00:09:21,440 --> 00:09:27,890
So here is in words, written
words what I just said orally.

177
00:09:27,889 --> 00:09:29,629
There's more stuff
than you can carry,

178
00:09:29,629 --> 00:09:32,269
and you have to choose
which stuff to take

179
00:09:32,269 --> 00:09:33,519
and which to leave behind.

180
00:09:33,519 --> 00:09:36,210


181
00:09:36,210 --> 00:09:39,889
I should point out that
there are two variants of it.

182
00:09:39,889 --> 00:09:46,740
There's the 0/1 knapsack
problem and the continuous.

183
00:09:46,740 --> 00:09:52,159
The 0/1 would be illustrated
by something like this.

184
00:09:52,159 --> 00:09:55,059
So the 0/1 knapsack problem
means you either take

185
00:09:55,059 --> 00:09:56,789
the object or you don't.

186
00:09:56,789 --> 00:10:01,480
I take that whole gold
bar or I take none of it.

187
00:10:01,480 --> 00:10:04,480
The continuous or so-called
fractional knapsack problem

188
00:10:04,480 --> 00:10:07,100
says I can take pieces of it.

189
00:10:07,100 --> 00:10:08,769
So maybe if I take
in my gold bar

190
00:10:08,769 --> 00:10:12,129
and shaved it into gold
dust, I then can say,

191
00:10:12,129 --> 00:10:13,700
well, the whole
thing won't fit in,

192
00:10:13,700 --> 00:10:16,800
but I can fit in a
path, part of it.

193
00:10:16,799 --> 00:10:20,939
The continuous knapsack
problem is really boring.

194
00:10:20,940 --> 00:10:22,837
It's easy to solve.

195
00:10:22,836 --> 00:10:25,169
How do you think you would
solve the continuous problem?

196
00:10:25,169 --> 00:10:29,649


197
00:10:29,649 --> 00:10:34,559
Suppose you had over here a pile
of gold and a pile of silver

198
00:10:34,559 --> 00:10:40,009
and a pile of raisins, and you
wanted to maximize your value.

199
00:10:40,009 --> 00:10:42,889
Well, you'd fill up
your knapsack with gold

200
00:10:42,889 --> 00:10:45,904
until you either ran out of
gold or ran out of space.

201
00:10:45,904 --> 00:10:48,230
If you haven't run
out of space, you'll

202
00:10:48,230 --> 00:10:52,576
now put silver in until
you run out of space.

203
00:10:52,576 --> 00:10:54,159
If you still haven't
run out of space,

204
00:10:54,159 --> 00:10:57,659
well, then you'll take as many
raisins as you can fit in.

205
00:10:57,659 --> 00:11:01,089
But you can solve it with what's
called a greedy algorithm,

206
00:11:01,090 --> 00:11:03,410
and we'll talk much more
about this as we go forward.

207
00:11:03,409 --> 00:11:07,860


208
00:11:07,860 --> 00:11:10,919
Where you take the best
thing first as long as

209
00:11:10,919 --> 00:11:15,319
you can and then you move
on to the next thing.

210
00:11:15,320 --> 00:11:18,920
As we'll see, the
0/1 knapsack problem

211
00:11:18,919 --> 00:11:22,819
is much more complicated because
once you make a decision,

212
00:11:22,820 --> 00:11:26,950
it will affect the
future decisions.

213
00:11:26,950 --> 00:11:30,790
Let's look at an example, and
I should probably warn you,

214
00:11:30,789 --> 00:11:35,120
if you're hungry, this is not
going to be a fun lecture.

215
00:11:35,120 --> 00:11:38,019
So here is my least
favorite because I always

216
00:11:38,019 --> 00:11:41,029
want to eat more than
I'm supposed to eat.

217
00:11:41,029 --> 00:11:44,399
So the point is typically
knapsack problems

218
00:11:44,399 --> 00:11:48,730
are not physical knapsacks
but some conceptual idea.

219
00:11:48,730 --> 00:11:53,830
So let's say that I'm allowed
1,500 calories of food,

220
00:11:53,830 --> 00:11:56,810
and these are my options.

221
00:11:56,809 --> 00:12:00,579
I have to go about deciding,
looking at this food--

222
00:12:00,580 --> 00:12:02,830
and it's interesting, again,
there's things showing up

223
00:12:02,830 --> 00:12:06,050
on your screen that are not
showing up on my screen,

224
00:12:06,049 --> 00:12:10,029
but they're harmless, things
like how my mouse works.

225
00:12:10,029 --> 00:12:17,000
Anyway, so I'm trying to take
some fraction of this food,

226
00:12:17,000 --> 00:12:23,240
and it can't add up to
more than 1,500 calories.

227
00:12:23,240 --> 00:12:27,919
The problem might be that
once I take something that's

228
00:12:27,919 --> 00:12:30,829
1,485 calories, I
can't take anything

229
00:12:30,830 --> 00:12:34,639
else, or maybe 1,200 calories
and everything else is

230
00:12:34,639 --> 00:12:36,379
more than 300.

231
00:12:36,379 --> 00:12:40,759
So once I take one thing, it
constrains possible solutions.

232
00:12:40,759 --> 00:12:42,539
A greedy algorithm,
as we'll see,

233
00:12:42,539 --> 00:12:46,669
is not guaranteed to
give me the best answer.

234
00:12:46,669 --> 00:12:49,669
Let's look at a
formalization of it.

235
00:12:49,669 --> 00:12:55,509
So each item is represented by
a pair, the value of the item

236
00:12:55,509 --> 00:12:56,669
and the weight of the item.

237
00:12:56,669 --> 00:13:01,269


238
00:13:01,269 --> 00:13:04,539
And let's assume the knapsack
can accommodate items

239
00:13:04,539 --> 00:13:10,000
with the total weight
of no more than w.

240
00:13:10,000 --> 00:13:12,559
I apologize for the
short variable names,

241
00:13:12,559 --> 00:13:16,089
but they're easier
to fit on a slide.

242
00:13:16,090 --> 00:13:19,540
Finally, we're going
to have a vector l

243
00:13:19,539 --> 00:13:24,509
of length n representing
the set of available items.

244
00:13:24,509 --> 00:13:29,210
This is assuming we have
n items to choose from.

245
00:13:29,210 --> 00:13:31,840
So each element of the
vector represents an item.

246
00:13:31,840 --> 00:13:37,290


247
00:13:37,289 --> 00:13:39,599
So those are the items we have.

248
00:13:39,600 --> 00:13:43,139
And then another
vector v is going

249
00:13:43,139 --> 00:13:47,600
to indicate whether or
not an item was taken.

250
00:13:47,600 --> 00:13:49,850
So essentially I'm going
to use a binary number

251
00:13:49,850 --> 00:13:54,700
to represent the set of
items I choose to take.

252
00:13:54,700 --> 00:13:58,810
For item three say,
if bit three is zero

253
00:13:58,809 --> 00:14:01,029
I'm not taking the item.

254
00:14:01,029 --> 00:14:06,269
If bit three is one, then
I am taking the item.

255
00:14:06,269 --> 00:14:09,449
So it just shows I
can now very nicely

256
00:14:09,450 --> 00:14:14,201
represent what I've done
by a single vector of zeros

257
00:14:14,201 --> 00:14:14,700
and ones.

258
00:14:14,700 --> 00:14:17,509


259
00:14:17,509 --> 00:14:20,000
Let me pause for a second.

260
00:14:20,000 --> 00:14:23,590
Does anyone have any
questions about this setup?

261
00:14:23,590 --> 00:14:25,629
It's important to get
this setup because what

262
00:14:25,629 --> 00:14:31,840
we're going to see now depends
upon that setting in your head.

263
00:14:31,840 --> 00:14:35,590
So I've kind of used mathematics
to describe the backpack

264
00:14:35,590 --> 00:14:36,860
problem.

265
00:14:36,860 --> 00:14:39,580
And that's typically the way
we deal with these optimization

266
00:14:39,580 --> 00:14:40,690
problems.

267
00:14:40,690 --> 00:14:43,870
We start with some
informal description,

268
00:14:43,870 --> 00:14:48,919
and then we translate them into
a mathematical representation.

269
00:14:48,919 --> 00:14:51,079
So here it is.

270
00:14:51,080 --> 00:14:52,850
We're going to try
and find a vector

271
00:14:52,850 --> 00:15:02,430
v that maximizes the sum
of V sub i times I sub i.

272
00:15:02,429 --> 00:15:05,759


273
00:15:05,759 --> 00:15:09,750
Now, remember I sub i is
the value of the item.

274
00:15:09,750 --> 00:15:17,740
V sub i is either zero or one
So if I didn't take the item,

275
00:15:17,740 --> 00:15:20,350
I'm multiplying
its value by zero.

276
00:15:20,350 --> 00:15:23,409
So it contributes
nothing to the sum.

277
00:15:23,409 --> 00:15:27,039
If I did take the item, I'm
multiplying its value by one.

278
00:15:27,039 --> 00:15:31,269
So the value of the item
gets added to the sum.

279
00:15:31,269 --> 00:15:35,909
So that tells me the
value of V. And I

280
00:15:35,909 --> 00:15:38,159
want to get the
most valuable V I

281
00:15:38,159 --> 00:15:43,289
can get subject
to the constraint

282
00:15:43,289 --> 00:15:48,849
that if I look at the item's
dot weight and multiply it by V,

283
00:15:48,850 --> 00:15:54,670
the sum of the weights
is no greater than w.

284
00:15:54,669 --> 00:15:56,939
So I'm playing the same
trick with the values

285
00:15:56,940 --> 00:16:01,620
of multiplying each
one by zero or one,

286
00:16:01,620 --> 00:16:04,412
and that's my constraint.

287
00:16:04,412 --> 00:16:08,480


288
00:16:08,480 --> 00:16:11,259
Make sense?

289
00:16:11,259 --> 00:16:16,960
All right, so now we have
the problem formalized.

290
00:16:16,960 --> 00:16:19,370
How do we solve it?

291
00:16:19,370 --> 00:16:24,860
Well, the most obvious
solution is brute force.

292
00:16:24,860 --> 00:16:27,509
I enumerate all
possible combinations

293
00:16:27,509 --> 00:16:36,066
of items; that is to say,
I generate all subsets

294
00:16:36,066 --> 00:16:37,440
of the items that
are available--

295
00:16:37,440 --> 00:16:40,020
I don't know why it
says subjects here,

296
00:16:40,019 --> 00:16:41,519
but we should have said items.

297
00:16:41,519 --> 00:16:44,470
Let me fix that.

298
00:16:44,470 --> 00:16:47,170
This is called the power set.

299
00:16:47,169 --> 00:16:51,370
So the power set of a set
includes the empty subset.

300
00:16:51,370 --> 00:16:54,669
It includes the set
that includes everything

301
00:16:54,669 --> 00:16:58,729
and everything in between.

302
00:16:58,730 --> 00:17:03,550
So subsets of size one,
subsets of size two, et cetera.

303
00:17:03,549 --> 00:17:07,450
So now I've generated all
possible sets of items.

304
00:17:07,450 --> 00:17:10,960
I can now go through
and sum up the weights

305
00:17:10,960 --> 00:17:16,460
and remove all those sets that
weigh more than I'm allowed.

306
00:17:16,460 --> 00:17:18,779
And then from the
remaining combinations,

307
00:17:18,779 --> 00:17:23,389
choose any one whose
value is the largest.

308
00:17:23,390 --> 00:17:25,280
I say choose any
one because there

309
00:17:25,279 --> 00:17:27,894
could be ties, in which case
I don't care which I choose.

310
00:17:27,894 --> 00:17:30,740


311
00:17:30,740 --> 00:17:34,799
So it's pretty obvious
that this is going

312
00:17:34,799 --> 00:17:37,169
to give you a correct answer.

313
00:17:37,170 --> 00:17:39,539
You're considering
all possibilities

314
00:17:39,539 --> 00:17:40,619
and choosing a winner.

315
00:17:40,619 --> 00:17:43,289


316
00:17:43,289 --> 00:17:47,279
Unfortunately, it's
usually not very practical.

317
00:17:47,279 --> 00:17:51,910
What we see here is
that's what the power

318
00:17:51,910 --> 00:17:54,420
set is if you have 100 vec.

319
00:17:54,420 --> 00:17:57,789
Not very practical, right,
even for a fast computer

320
00:17:57,789 --> 00:18:01,170
generating that many
possibilities is going

321
00:18:01,170 --> 00:18:04,200
to take a rather long time.

322
00:18:04,200 --> 00:18:05,910
So kind of disappointing.

323
00:18:05,910 --> 00:18:09,340
We look at it and say, well,
we got a brute force algorithm.

324
00:18:09,339 --> 00:18:13,740
It will solve the problem,
but it'll take too long.

325
00:18:13,740 --> 00:18:15,089
We can't actually do it.

326
00:18:15,089 --> 00:18:17,399
100 is a pretty
small number, right.

327
00:18:17,400 --> 00:18:19,860
We often end up solving
optimization problems

328
00:18:19,859 --> 00:18:22,829
where n is something
closer to 1,000, sometimes

329
00:18:22,829 --> 00:18:25,019
even a million.

330
00:18:25,019 --> 00:18:27,970
Clearly, brute force
isn't going to work.

331
00:18:27,970 --> 00:18:30,039
So that raises
the next question,

332
00:18:30,039 --> 00:18:32,420
are we just being stupid?

333
00:18:32,420 --> 00:18:34,970
Is there a better algorithm
that I should have showed you?

334
00:18:34,970 --> 00:18:35,970
I shouldn't say we.

335
00:18:35,970 --> 00:18:37,730
Am I just being stupid?

336
00:18:37,730 --> 00:18:42,950
Is there a better algorithm that
would have given us the answer?

337
00:18:42,950 --> 00:18:48,960
The sad answer to that is
no for the knapsack problem.

338
00:18:48,960 --> 00:18:52,819
And indeed many
optimization problems

339
00:18:52,819 --> 00:18:56,240
are inherently exponential.

340
00:18:56,240 --> 00:19:00,589
What that means is there
is no algorithm that

341
00:19:00,589 --> 00:19:04,879
provides an exact solution
to this problem whose worst

342
00:19:04,880 --> 00:19:08,846
case running time is not
exponential in the number

343
00:19:08,846 --> 00:19:09,345
of items.

344
00:19:09,345 --> 00:19:12,640


345
00:19:12,640 --> 00:19:14,770
It is an exponentially
hard problem.

346
00:19:14,769 --> 00:19:17,470


347
00:19:17,470 --> 00:19:21,809
There is no really
good solution.

348
00:19:21,809 --> 00:19:28,009
But that should not make you
sad because while there's

349
00:19:28,009 --> 00:19:32,059
no perfect solution, we're going
to look at a couple of really

350
00:19:32,059 --> 00:19:36,019
very good solutions that
will make this poor woman

351
00:19:36,019 --> 00:19:38,400
a happier person.

352
00:19:38,400 --> 00:19:40,220
So let's start with
the greedy algorithm.

353
00:19:40,220 --> 00:19:44,360
I already talked to you
about greedy algorithms.

354
00:19:44,359 --> 00:19:47,929
So it could hardly be simpler.

355
00:19:47,930 --> 00:19:50,600
We say while the
knapsack is not full,

356
00:19:50,599 --> 00:19:52,769
put the best available
item into the knapsack.

357
00:19:52,769 --> 00:19:57,915


358
00:19:57,915 --> 00:19:59,039
When it's full, we're done.

359
00:19:59,039 --> 00:20:03,710


360
00:20:03,710 --> 00:20:06,100
You do need to ask a question.

361
00:20:06,099 --> 00:20:09,289
What does best mean?

362
00:20:09,289 --> 00:20:14,099
Is the best item
the most valuable?

363
00:20:14,099 --> 00:20:16,230
Is it the least
expensive in terms

364
00:20:16,230 --> 00:20:20,190
of, say, the fewest
calories, in my case?

365
00:20:20,190 --> 00:20:24,049
Or is it the highest
ratio of value to units?

366
00:20:24,049 --> 00:20:27,119
Now, maybe I think a
calorie in a glass of beer

367
00:20:27,119 --> 00:20:30,589
is worth more than a calorie
in a bar of chocolate,

368
00:20:30,589 --> 00:20:33,329
maybe vice versa.

369
00:20:33,329 --> 00:20:37,379
Which gets me to a
concrete example.

370
00:20:37,380 --> 00:20:40,680
So you're about to
sit down to a meal.

371
00:20:40,680 --> 00:20:44,190
You know how much you value
the various different foods.

372
00:20:44,190 --> 00:20:45,930
For example, maybe
you like donuts

373
00:20:45,930 --> 00:20:48,360
more than you like apples.

374
00:20:48,359 --> 00:20:50,069
You have a calorie
budget, and here we're

375
00:20:50,069 --> 00:20:52,289
going to have a fairly
austere budget--

376
00:20:52,289 --> 00:20:54,980
it's only one meal;
it's not the whole day--

377
00:20:54,980 --> 00:20:58,920
of 750 calories, and we're going
to have to go through menus

378
00:20:58,920 --> 00:21:01,470
and choose what to eat.

379
00:21:01,470 --> 00:21:04,720
That is as we've seen
a knapsack problem.

380
00:21:04,720 --> 00:21:06,640
They should probably
have a knapsack solver

381
00:21:06,640 --> 00:21:10,210
at every McDonald's
and Burger King.

382
00:21:10,210 --> 00:21:16,690
So here's a menu I just made up
of wine, beer, pizza, burger,

383
00:21:16,690 --> 00:21:19,930
fries, Coke,
apples, and a donut,

384
00:21:19,930 --> 00:21:24,580
and the value I might
place on each of these

385
00:21:24,579 --> 00:21:29,349
and the number of calories that
actually are in each of these.

386
00:21:29,349 --> 00:21:32,049
And we're going to
build a program that

387
00:21:32,049 --> 00:21:33,879
will find an optimal menu.

388
00:21:33,880 --> 00:21:36,710


389
00:21:36,710 --> 00:21:40,150
And if you don't like this
menu, you can run the program

390
00:21:40,150 --> 00:21:42,340
and change the values
to be whatever you like.

391
00:21:42,339 --> 00:21:46,720


392
00:21:46,720 --> 00:21:49,930
Well, as you saw
if you took 60001,

393
00:21:49,930 --> 00:21:54,039
we like to start with
an abstract data type,

394
00:21:54,039 --> 00:21:57,519
like to organize our program
around data abstractions.

395
00:21:57,519 --> 00:22:00,579
So I've got this class food.

396
00:22:00,579 --> 00:22:02,889
I can initialize things.

397
00:22:02,890 --> 00:22:07,880
I have a getValue,
a getCost, density,

398
00:22:07,880 --> 00:22:11,515
which is going to be the value
divided by the cost, and then

399
00:22:11,515 --> 00:22:14,580
a string representation.

400
00:22:14,579 --> 00:22:19,480
So nothing here that you should
not all be very familiar with.

401
00:22:19,480 --> 00:22:23,009


402
00:22:23,009 --> 00:22:26,950
Then I'm going to have a
function called buildMenu,

403
00:22:26,950 --> 00:22:29,410
which will take
in a list of names

404
00:22:29,410 --> 00:22:34,225
and a list of values of equal
length and a list of calories.

405
00:22:34,224 --> 00:22:36,549
They're all the same length.

406
00:22:36,549 --> 00:22:37,730
And it will build the menu.

407
00:22:37,730 --> 00:22:41,380


408
00:22:41,380 --> 00:22:44,740
So it's going to be
a menu of tuples--

409
00:22:44,740 --> 00:22:46,839
a menu of foods, rather.

410
00:22:46,839 --> 00:22:49,990
And I build each food by
giving it its name, its value,

411
00:22:49,990 --> 00:22:53,140
and its caloric content.

412
00:22:53,140 --> 00:22:53,980
Now I have a menu.

413
00:22:53,980 --> 00:22:57,210


414
00:22:57,210 --> 00:22:59,759
Now comes the fun part.

415
00:22:59,759 --> 00:23:03,089
Here is an implementation
of a greedy algorithm.

416
00:23:03,089 --> 00:23:06,809
I called it a flexible
greedy primarily because

417
00:23:06,809 --> 00:23:08,440
of this key function over here.

418
00:23:08,440 --> 00:23:11,070


419
00:23:11,069 --> 00:23:15,589
So you'll notice in red there's
a parameter called keyfunction.

420
00:23:15,589 --> 00:23:18,449


421
00:23:18,450 --> 00:23:22,779
That's going to be-- map the
elements of items to numbers.

422
00:23:22,779 --> 00:23:25,309


423
00:23:25,309 --> 00:23:33,589
So it will be used
to sort the items.

424
00:23:33,589 --> 00:23:37,109
So I want to sort them
from best to worst,

425
00:23:37,109 --> 00:23:42,649
and this function will be used
to tell me what I mean by best.

426
00:23:42,650 --> 00:23:47,660
So maybe keyfunction will
just return the value or maybe

427
00:23:47,660 --> 00:23:50,000
it will return the weight
or maybe it will return

428
00:23:50,000 --> 00:23:53,960
some function of the density.

429
00:23:53,960 --> 00:23:56,750
But the idea here
is I want to use

430
00:23:56,750 --> 00:24:00,829
one greedy algorithm
independently

431
00:24:00,829 --> 00:24:03,500
of my definition of best.

432
00:24:03,500 --> 00:24:07,025
So I use keyfunction to
define what I mean by best.

433
00:24:07,025 --> 00:24:11,721


434
00:24:11,721 --> 00:24:12,720
So I'm going to come in.

435
00:24:12,720 --> 00:24:15,920
I'm going to sort it
from best to worst.

436
00:24:15,920 --> 00:24:21,019
And then for i in range
len of items sub copy--

437
00:24:21,019 --> 00:24:21,980
I'm being good.

438
00:24:21,980 --> 00:24:22,789
I've copied it.

439
00:24:22,789 --> 00:24:25,579
That's why you sorted
rather than sort.

440
00:24:25,579 --> 00:24:28,669
I don't want to have a side
effect in the parameter.

441
00:24:28,670 --> 00:24:33,750
In general, it's not
good hygiene to do that.

442
00:24:33,750 --> 00:24:37,609
And so for-- I'll go through
it in order from best to worst.

443
00:24:37,609 --> 00:24:44,240
And if the value is less
than the maximum cost,

444
00:24:44,240 --> 00:24:47,190
if putting it in would keep
me under the cost or not

445
00:24:47,190 --> 00:24:50,309
over the cost, I put
it in, and I just

446
00:24:50,309 --> 00:24:53,829
do that until I can't
put anything else in.

447
00:24:53,829 --> 00:24:56,609


448
00:24:56,609 --> 00:25:00,119
So I might skip a few because
I might get to the point

449
00:25:00,119 --> 00:25:02,399
where there's only
a few calories left,

450
00:25:02,400 --> 00:25:07,380
and the next best item is
over that budget but maybe

451
00:25:07,380 --> 00:25:12,040
further down I'll find one that
is not over it and put it in.

452
00:25:12,039 --> 00:25:16,210
That's why I can't exit
as soon as I reach--

453
00:25:16,210 --> 00:25:19,600
as soon as I find an
item that won't fit.

454
00:25:19,599 --> 00:25:22,819
And then I'll just return.

455
00:25:22,819 --> 00:25:24,781
Does this make sense?

456
00:25:24,781 --> 00:25:28,009
Does anyone have any doubts
about whether this algorithm

457
00:25:28,009 --> 00:25:28,775
actually works?

458
00:25:28,775 --> 00:25:33,974


459
00:25:33,973 --> 00:25:35,639
I hope not because I
think it does work.

460
00:25:35,640 --> 00:25:38,280


461
00:25:38,279 --> 00:25:39,644
Let's ask the next question.

462
00:25:39,644 --> 00:25:41,940


463
00:25:41,940 --> 00:25:44,549
How efficient do we think it is?

464
00:25:44,549 --> 00:25:47,839


465
00:25:47,839 --> 00:25:50,454
What is the efficiency
of this algorithm?

466
00:25:50,454 --> 00:25:57,250


467
00:25:57,250 --> 00:26:00,836
Let's see where the time goes.

468
00:26:00,836 --> 00:26:04,339
That's the algorithm
we just looked at.

469
00:26:04,339 --> 00:26:06,388
So I deleted the
comment, so we'd

470
00:26:06,388 --> 00:26:07,929
have a little more
room in the slide.

471
00:26:07,930 --> 00:26:11,150


472
00:26:11,150 --> 00:26:13,765
Who wants to make a guess?

473
00:26:13,765 --> 00:26:15,140
By the way, this
is the question.

474
00:26:15,140 --> 00:26:17,430
So please go answer
the questions.

475
00:26:17,430 --> 00:26:19,890
We'll see how people do.

476
00:26:19,890 --> 00:26:21,765
But we can think about
it as well together.

477
00:26:21,765 --> 00:26:25,009


478
00:26:25,009 --> 00:26:30,109
Well, let's see
where the time goes.

479
00:26:30,109 --> 00:26:33,559
The first thing is at the sort.

480
00:26:33,559 --> 00:26:37,940
So I'm going to
sort all the items.

481
00:26:37,940 --> 00:26:41,330
And we heard from
Professor Grimson

482
00:26:41,329 --> 00:26:44,579
how long the sort takes.

483
00:26:44,579 --> 00:26:47,159
See who remembers.

484
00:26:47,160 --> 00:26:50,190
Python uses something
called timsort,

485
00:26:50,190 --> 00:26:54,240
which is a variant of something
called quicksort, which

486
00:26:54,240 --> 00:26:59,940
has the same worst-case
complexity as merge sort.

487
00:26:59,940 --> 00:27:09,259
And so we know that is n
log n where n in this case

488
00:27:09,259 --> 00:27:10,519
would be the len of items.

489
00:27:10,519 --> 00:27:17,599


490
00:27:17,599 --> 00:27:20,919
So we know we have that.

491
00:27:20,920 --> 00:27:25,779


492
00:27:25,779 --> 00:27:27,389
Then we have a loop.

493
00:27:27,390 --> 00:27:29,140
How many times do we
go through this loop?

494
00:27:29,140 --> 00:27:34,670


495
00:27:34,670 --> 00:27:42,029
Well, we go through the loop
n times, once for each item

496
00:27:42,029 --> 00:27:43,879
because we do end up
looking at every item.

497
00:27:43,880 --> 00:27:47,250


498
00:27:47,250 --> 00:27:51,276
And if we know that,
what's the order?

499
00:27:51,276 --> 00:27:52,758
AUDIENCE: [INAUDIBLE].

500
00:27:52,758 --> 00:27:59,673


501
00:27:59,673 --> 00:28:03,855
JOHN GUTTAG: N log n plus n--

502
00:28:03,855 --> 00:28:09,569
I guess is order n log n, right?

503
00:28:09,569 --> 00:28:14,279
So it's pretty efficient.

504
00:28:14,279 --> 00:28:17,369
And we can do this for big
numbers like a million.

505
00:28:17,369 --> 00:28:20,219


506
00:28:20,220 --> 00:28:23,190
Log of a million times a million
is not a very big number.

507
00:28:23,190 --> 00:28:26,150


508
00:28:26,150 --> 00:28:29,411
So it's very efficient.

509
00:28:29,411 --> 00:28:32,720


510
00:28:32,720 --> 00:28:34,400
Here's some code
that uses greedy.

511
00:28:34,400 --> 00:28:37,000


512
00:28:37,000 --> 00:28:41,390
Takes in the items, the
constraint, in this case

513
00:28:41,390 --> 00:28:46,800
will be the weight,
and just calls greedy,

514
00:28:46,799 --> 00:28:49,970
but with the keyfunction
and prints what we have.

515
00:28:49,970 --> 00:28:56,140


516
00:28:56,140 --> 00:28:58,509
So we're going to test greedy.

517
00:28:58,509 --> 00:29:02,279
I actually think I used 750 in
the code, but we can use 800.

518
00:29:02,279 --> 00:29:03,750
It doesn't matter.

519
00:29:03,750 --> 00:29:08,430
And here's something
we haven't seen before.

520
00:29:08,430 --> 00:29:10,980
So used greedy by
value to allocate

521
00:29:10,980 --> 00:29:15,569
and calls testGreedy with food,
maxUnits and Food.getValue.

522
00:29:15,569 --> 00:29:17,259
Notice it's passing
the function.

523
00:29:17,259 --> 00:29:18,410
That's why it's not--

524
00:29:18,410 --> 00:29:21,560
no closed parentheses after it.

525
00:29:21,559 --> 00:29:24,779
Used greedy to allocate.

526
00:29:24,779 --> 00:29:27,238
And then we have something
pretty interesting.

527
00:29:27,238 --> 00:29:29,930


528
00:29:29,930 --> 00:29:31,830
What's going on
with this lambda?

529
00:29:31,829 --> 00:29:35,659


530
00:29:35,660 --> 00:29:41,210
So here we're going to be using
greedy by density to allocate--

531
00:29:41,210 --> 00:29:44,569
actually, sorry, this
is greedy by cost.

532
00:29:44,569 --> 00:29:47,029
And you'll notice
what we're doing is--

533
00:29:47,029 --> 00:29:50,180
we don't want to
pass in the cost,

534
00:29:50,180 --> 00:29:56,730
right, because we really want
the opposite of the cost.

535
00:29:56,730 --> 00:30:00,299
We want to reverse the sort
because we want the cheaper

536
00:30:00,299 --> 00:30:02,609
items to get chosen first.

537
00:30:02,609 --> 00:30:04,949
The ones that have fewer
calories, not the ones that

538
00:30:04,950 --> 00:30:07,080
have more calories.

539
00:30:07,079 --> 00:30:10,740
As it happens,
when I define cost,

540
00:30:10,740 --> 00:30:15,130
I defined it in the obvious way,
the total number of calories.

541
00:30:15,130 --> 00:30:19,020
So I could have gone and written
another function to do it,

542
00:30:19,019 --> 00:30:24,299
but since it was so simple,
I decided to do it in line.

543
00:30:24,299 --> 00:30:28,460
So let's talk about lambda
and then come back to it.

544
00:30:28,460 --> 00:30:32,880
Lambda is used to create
an anonymous function,

545
00:30:32,880 --> 00:30:37,560
anonymous in the sense
that it has no name.

546
00:30:37,559 --> 00:30:41,109
So you start with
the keyword lambda.

547
00:30:41,109 --> 00:30:45,039
You then give it a
sequence of identifiers

548
00:30:45,039 --> 00:30:46,210
and then some expression.

549
00:30:46,210 --> 00:30:50,210


550
00:30:50,210 --> 00:30:55,559
What lambda does is
it builds a function

551
00:30:55,559 --> 00:31:01,409
that evaluates that expression
on those parameters and returns

552
00:31:01,410 --> 00:31:05,009
the result of evaluating
the expression.

553
00:31:05,009 --> 00:31:12,129
So instead of writing def, I
have inline defined a function.

554
00:31:12,130 --> 00:31:17,190
So if we go back to it here,
you can see that what I've done

555
00:31:17,190 --> 00:31:24,761
is lambda x one divided
by Food.getCost of x.

556
00:31:24,761 --> 00:31:29,250


557
00:31:29,250 --> 00:31:33,289
Notice food is the
class name here.

558
00:31:33,289 --> 00:31:38,480
So I'm taking the function
getCost from the class food,

559
00:31:38,480 --> 00:31:46,349
and I'm passing it the parameter
x, which is going to be what?

560
00:31:46,349 --> 00:31:47,959
What's the type
of x going to be?

561
00:31:47,960 --> 00:31:56,170


562
00:31:56,170 --> 00:31:59,200
I can wait you out.

563
00:31:59,200 --> 00:32:02,569
What is the type of x have to
be for this lambda expression

564
00:32:02,569 --> 00:32:03,159
to make sense?

565
00:32:03,160 --> 00:32:09,830


566
00:32:09,829 --> 00:32:14,240
Well, go back to the class food.

567
00:32:14,240 --> 00:32:16,039
What's the type of the
argument of getCost?

568
00:32:16,039 --> 00:32:22,019


569
00:32:22,019 --> 00:32:24,487
What's the name of the
argument to getCost?

570
00:32:24,487 --> 00:32:25,570
That's an easier question.

571
00:32:25,569 --> 00:32:31,211


572
00:32:31,211 --> 00:32:32,670
We'll go back and
we'll look at it.

573
00:32:32,670 --> 00:32:40,979


574
00:32:40,979 --> 00:32:42,769
What's the type of the
argument to getCost?

575
00:32:42,769 --> 00:32:46,309


576
00:32:46,309 --> 00:32:47,809
AUDIENCE: Food.

577
00:32:47,809 --> 00:32:48,759
JOHN GUTTAG: Food.

578
00:32:48,759 --> 00:32:50,890
Thank you.

579
00:32:50,890 --> 00:32:55,140
So I do have--
speaking of food, we

580
00:32:55,140 --> 00:32:57,600
do have a tradition
in this class

581
00:32:57,599 --> 00:33:00,490
that people who answer
questions correctly get

582
00:33:00,490 --> 00:33:03,339
rewarded with food.

583
00:33:03,339 --> 00:33:07,789
Oh, Napoli would
have caught that.

584
00:33:07,789 --> 00:33:12,559


585
00:33:12,559 --> 00:33:15,750
So it has to be of
type food because it's

586
00:33:15,750 --> 00:33:18,460
self in the class food.

587
00:33:18,460 --> 00:33:28,190


588
00:33:28,190 --> 00:33:35,150
So if we go back to here, this
x has to be of type food, right.

589
00:33:35,150 --> 00:33:40,450


590
00:33:40,450 --> 00:33:44,680
And sure enough, when
we use it, it will be.

591
00:33:44,680 --> 00:33:48,240
Let's now use it.

592
00:33:48,240 --> 00:33:54,349
I should point out that lambda
can be really handy as it

593
00:33:54,349 --> 00:33:58,250
is here, and it's
possible to write

594
00:33:58,250 --> 00:34:02,269
amazing, beautiful,
complicated lambda expressions.

595
00:34:02,269 --> 00:34:08,789
And back in the good old days of
6001 people learned to do that.

596
00:34:08,789 --> 00:34:12,800
And then they learned
that they shouldn't.

597
00:34:12,800 --> 00:34:15,590
My view on lambda expressions
is if I can't fit it

598
00:34:15,590 --> 00:34:17,329
in a single line,
I just go right

599
00:34:17,329 --> 00:34:19,699
def and write a
function definition

600
00:34:19,699 --> 00:34:22,579
because it's easier to debug.

601
00:34:22,579 --> 00:34:25,009
But for one-liners,
lambda is great.

602
00:34:25,010 --> 00:34:28,690


603
00:34:28,690 --> 00:34:31,159
Let's look at using greedy.

604
00:34:31,159 --> 00:34:34,340
So here's this
function testGreedy,

605
00:34:34,340 --> 00:34:36,650
takes foods and the
maximum number of units.

606
00:34:36,650 --> 00:34:39,519


607
00:34:39,519 --> 00:34:42,420
And it's going to
go through and it's

608
00:34:42,420 --> 00:34:45,791
going to test all three
greedy algorithms.

609
00:34:45,791 --> 00:34:48,750


610
00:34:48,750 --> 00:34:52,340
And we just saw that, and
then here is the call of it.

611
00:34:52,340 --> 00:34:55,730
And so I picked up some
names and the values.

612
00:34:55,730 --> 00:34:57,940
This is just the menu we saw.

613
00:34:57,940 --> 00:34:59,690
I'm going to build the
menus, and then I'm

614
00:34:59,690 --> 00:35:02,900
going to call testGreedys.

615
00:35:02,900 --> 00:35:06,250
So let's go look at the
code that does this.

616
00:35:06,250 --> 00:35:10,949


617
00:35:10,949 --> 00:35:15,469
So here you have it or maybe
you don't, because every time

618
00:35:15,469 --> 00:35:19,909
I switch applications
Windows decides I don't want

619
00:35:19,909 --> 00:35:21,210
to show you the screen anyway.

620
00:35:21,210 --> 00:35:27,720


621
00:35:27,719 --> 00:35:29,259
This really shouldn't
be necessary.

622
00:35:29,260 --> 00:35:35,230


623
00:35:35,230 --> 00:35:37,409
Keep changes.

624
00:35:37,409 --> 00:35:39,239
Why it keeps forgetting,
I don't know.

625
00:35:39,239 --> 00:35:41,269
Anyway, so here's the code.

626
00:35:41,269 --> 00:35:42,860
It's all the code
we just looked at.

627
00:35:42,860 --> 00:35:43,670
Now let's run it.

628
00:35:43,670 --> 00:35:47,690


629
00:35:47,690 --> 00:35:51,829
Well, what we see
here is that we

630
00:35:51,829 --> 00:35:56,000
use greedy by value to
allocate 750 calories,

631
00:35:56,000 --> 00:35:57,769
and it chooses a
burger, the pizza,

632
00:35:57,769 --> 00:36:00,980
and the wine for a total of--

633
00:36:00,980 --> 00:36:07,139
a value of 284 happiness
points, if you will.

634
00:36:07,139 --> 00:36:10,369
On the other hand, if
we use greedy by cost,

635
00:36:10,369 --> 00:36:16,909
I get 318 happiness points and
a different menu, the apple,

636
00:36:16,909 --> 00:36:19,279
the wine, the cola, the
beer, and the donut.

637
00:36:19,280 --> 00:36:21,500
I've lost the pizza
and the burger.

638
00:36:21,500 --> 00:36:25,010


639
00:36:25,010 --> 00:36:27,620
I guess this is what
I signed up for when

640
00:36:27,619 --> 00:36:28,909
I put my preferences on.

641
00:36:28,909 --> 00:36:31,819


642
00:36:31,820 --> 00:36:42,330
And here's another solution
with 318, apple, wine--

643
00:36:42,329 --> 00:36:44,489
yeah, all right.

644
00:36:44,489 --> 00:36:47,289
So I actually got
the same solution,

645
00:36:47,289 --> 00:36:49,759
but it just found them
in a different order.

646
00:36:49,760 --> 00:36:51,510
Why did it find them
in a different order?

647
00:36:51,510 --> 00:36:55,200
Because the sort order was
different because in this case

648
00:36:55,199 --> 00:36:56,939
I was sorting by density.

649
00:36:56,940 --> 00:37:00,389


650
00:37:00,389 --> 00:37:03,239
From this, we see
an important point

651
00:37:03,239 --> 00:37:08,669
about greedy algorithms, right,
that we used the algorithm

652
00:37:08,670 --> 00:37:10,260
and we got different answers.

653
00:37:10,260 --> 00:37:13,110


654
00:37:13,110 --> 00:37:14,625
Why do we have
different answers?

655
00:37:14,625 --> 00:37:18,070


656
00:37:18,070 --> 00:37:20,860
The problem is that
a greedy algorithm

657
00:37:20,860 --> 00:37:25,570
makes a sequence of
local optimizations,

658
00:37:25,570 --> 00:37:29,410
chooses the locally optimal
answer at every point,

659
00:37:29,409 --> 00:37:31,389
and that doesn't
necessarily add up

660
00:37:31,389 --> 00:37:34,509
to a globally optimal answer.

661
00:37:34,510 --> 00:37:39,010
This is often illustrated by
showing an example of, say,

662
00:37:39,010 --> 00:37:40,730
hill climbing.

663
00:37:40,730 --> 00:37:47,409
So imagine you're in a terrain
that looks something like this,

664
00:37:47,409 --> 00:37:52,420
and you want to get to the
highest point you can get.

665
00:37:52,420 --> 00:37:56,409
So you might choose
as a greedy algorithm

666
00:37:56,409 --> 00:38:03,519
if you can go up, go up; if
you can't go up, you stop.

667
00:38:03,519 --> 00:38:06,710
So whenever you get
a choice, you go up.

668
00:38:06,710 --> 00:38:14,590
And so if I start here, I
could right in the middle

669
00:38:14,590 --> 00:38:18,950
maybe say, all right, it's not
up but it's not down either.

670
00:38:18,949 --> 00:38:20,509
So I'll go either left or right.

671
00:38:20,510 --> 00:38:23,840


672
00:38:23,840 --> 00:38:27,120
And let's say I go
right, so I come to here.

673
00:38:27,119 --> 00:38:30,500
Then I'll just make my way
up to the top of the hill,

674
00:38:30,500 --> 00:38:34,670
making a locally optimal
decision head up at each point,

675
00:38:34,670 --> 00:38:38,210
and I'll get here and I'll
say, well, now any place I go

676
00:38:38,210 --> 00:38:40,190
takes me to a lower point.

677
00:38:40,190 --> 00:38:44,329
So I don't want to do it, right,
because the greedy algorithm

678
00:38:44,329 --> 00:38:47,110
says never go backwards.

679
00:38:47,110 --> 00:38:49,539
So I'm here and I'm happy.

680
00:38:49,539 --> 00:38:56,559
On the other hand, if I had
gone here for my first step,

681
00:38:56,559 --> 00:39:01,960
then my next step up would take
me up, up, up, I'd get to here,

682
00:39:01,960 --> 00:39:08,250
and I'd stop and say, OK,
no way to go but down.

683
00:39:08,250 --> 00:39:09,250
I don't want to go down.

684
00:39:09,250 --> 00:39:10,449
I'm done.

685
00:39:10,449 --> 00:39:14,169
And what I would find is I'm
at a local maximum rather than

686
00:39:14,170 --> 00:39:14,985
a global maximum.

687
00:39:14,985 --> 00:39:17,740


688
00:39:17,739 --> 00:39:21,159
And that's the problem
with greedy algorithms,

689
00:39:21,159 --> 00:39:26,379
that you can get stuck
at a local optimal point

690
00:39:26,380 --> 00:39:30,590
and not get to the best one.

691
00:39:30,590 --> 00:39:37,019
Now, we could ask
the question, can

692
00:39:37,019 --> 00:39:39,300
I just say don't
worry about a density

693
00:39:39,300 --> 00:39:43,260
will always get me
the best answer?

694
00:39:43,260 --> 00:39:45,520
Well, I've tried a
different experiment.

695
00:39:45,519 --> 00:39:47,619
Let's say I'm feeling
expansive and I'm going

696
00:39:47,619 --> 00:39:57,819
to allow myself 1,000 calories.

697
00:39:57,820 --> 00:40:09,800
Well, here what we see is the
winner will be greedy by value,

698
00:40:09,800 --> 00:40:13,630
happens to find a better
answer, 424 instead of 413.

699
00:40:13,630 --> 00:40:15,990


700
00:40:15,989 --> 00:40:19,699
So there is no way
to know in advance.

701
00:40:19,699 --> 00:40:22,519
Sometimes this definition
of best might work.

702
00:40:22,519 --> 00:40:24,349
Sometimes that might work.

703
00:40:24,349 --> 00:40:27,949
Sometimes no definition
of best will work,

704
00:40:27,949 --> 00:40:31,579
and you can't get
to a good solution--

705
00:40:31,579 --> 00:40:33,170
you get to a good solution.

706
00:40:33,170 --> 00:40:35,119
You can't get to
an optimal solution

707
00:40:35,119 --> 00:40:37,369
with a greedy algorithm.

708
00:40:37,369 --> 00:40:40,940
On Wednesday, we'll talk
about how do you actually

709
00:40:40,940 --> 00:40:44,599
guarantee finding an
optimal solution in a better

710
00:40:44,599 --> 00:40:46,730
way than brute force.

711
00:40:46,730 --> 00:40:48,619
See you then.

712
00:40:48,619 --> 00:40:56,228


