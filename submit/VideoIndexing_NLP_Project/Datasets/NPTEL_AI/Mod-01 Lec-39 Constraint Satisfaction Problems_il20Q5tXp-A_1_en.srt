1
00:00:10,589 --> 00:00:19,410
So, today we want look at different approach
to problem solving and this approach is

2
00:00:19,410 --> 00:00:36,570
called constraint satisfactions or some people
called it constraint processing. And we talk

3
00:00:36,570 --> 00:00:52,070
of constraint satisfaction problems 
and we call them CSP essentially. So, this

4
00:00:52,070 --> 00:00:54,880
constraint
satisfaction approach to solving problems

5
00:00:54,880 --> 00:01:02,780
is unified way of representing problems as
constraint satisfaction problems as we will

6
00:01:02,780 --> 00:01:10,920
see today. And then solving the CSP
essentially so essentially what this says.

7
00:01:10,920 --> 00:01:12,629
So, for example, in state space search we
talked

8
00:01:12,629 --> 00:01:18,118
about states end, moves end and going to new
states and so on. And then we looked at

9
00:01:18,118 --> 00:01:23,868
solution space search and these method in
constraint satisfaction problems everything

10
00:01:23,868 --> 00:01:28,859
is
expressed in the following way. There is set

11
00:01:28,859 --> 00:01:45,469
of variables x, x one, x two, a finite set,
a set

12
00:01:45,469 --> 00:02:07,539
of domains d which you will denote by d 1
d 2 and so on. And the meaning of this

13
00:02:07,539 --> 00:02:13,969
domain says that variable x 1 can take values
from domain d 1 variable x 2 can take

14
00:02:13,969 --> 00:02:17,430
value from domain d 2 and so on. So, each
variable has it is own domain it does not

15
00:02:17,430 --> 00:02:20,000
have
to be the same set of values.

16
00:02:20,000 --> 00:02:24,650
.So, one can be numbers another can be colors
another can be day of the week; another

17
00:02:24,650 --> 00:02:30,180
can be name of the students; another can be
the grade that the student has got anything

18
00:02:30,180 --> 00:02:33,099
in
the variable. And each variable has a domain

19
00:02:33,098 --> 00:02:41,620
from the third thing is a set of constraints
c

20
00:02:41,620 --> 00:02:58,299
which you will say c 1 c 2 let us say up to
c k I will come to constraints in a moment

21
00:02:58,299 --> 00:03:00,689
first
let us talk about variables. So, we will assume

22
00:03:00,689 --> 00:03:02,709
that there is final set of variables which
is

23
00:03:02,709 --> 00:03:12,640
always the case so x n which means d n. And
we will also assume far as for as we are

24
00:03:12,639 --> 00:03:24,358
concern that this domains are discrete domains
essentially and not only discrete. But we

25
00:03:24,359 --> 00:03:31,498
will assume that they are finainic essentially
which means that the set of values that

26
00:03:31,498 --> 00:03:38,400
available can take we will assume it is finite
essentially. Because of the particular kind

27
00:03:38,400 --> 00:03:40,688
of
sub problems that you want to look at and

28
00:03:40,688 --> 00:03:49,388
the solutions to those problems essentially
now obviously many problems can be posed as

29
00:03:49,389 --> 00:03:55,120
variations of finite discrete domain. So,
let us first discuss the constraint.

30
00:03:55,120 --> 00:04:11,920
So, each constraint c i is a pair S i and
R i where S i is called scope of the constraint.

31
00:04:11,919 --> 00:04:15,708
And
it is basically a subset of x which means

32
00:04:15,709 --> 00:04:18,889
that a constraint is defined over a subset
of the

33
00:04:18,889 --> 00:04:22,969
variables and that subset that particular
sub set was for the i t h constraint is called

34
00:04:22,970 --> 00:04:27,430
the
scope of that constraint c i and R i. So,

35
00:04:27,430 --> 00:04:34,709
this subset let us say this sub set is made
up of

36
00:04:34,709 --> 00:04:52,490
variables x i 1 x i 2 x i p. Let us say that
there are p variables each of them has a

37
00:04:52,490 --> 00:05:00,139
corresponding domain and the relation R i
is basically defined over those variables.

38
00:05:00,139 --> 00:05:09,069
So, it
is a sub set of d i 1 cross d i 2 cross d

39
00:05:09,069 --> 00:05:14,430
i p that is the most generate way of defining
a

40
00:05:14,430 --> 00:05:19,850
constraint satisfaction problems a set of
variables a set of domains for each variable.

41
00:05:19,850 --> 00:05:22,370
And
a set of constraint defined over subsets of

42
00:05:22,370 --> 00:05:30,660
variable. And we have just using the generic
definition of a relation here simply saying

43
00:05:30,660 --> 00:05:33,090
that is the subset of the gross product of
all the

44
00:05:33,089 --> 00:05:42,529
domains in practice this could be explicit
or implicit.

45
00:05:42,529 --> 00:05:50,829
So, we will assume that the relations are
explicit as for as we are concern for this

46
00:05:50,829 --> 00:05:56,370
discussion. So, for example, if you say that
there is a number between 1 and 5 or the days

47
00:05:56,370 --> 00:06:02,340
of the week can be numbered from let say 1
to 7 when you will simply list this set as

48
00:06:02,339 --> 00:06:04,888
1
comma 2 comma 3 up to 7. We could have said

49
00:06:04,889 --> 00:06:10,720
it in some implicit way like greater than
0 and less than 8. But we will not go into

50
00:06:10,720 --> 00:06:12,500
those things here and in many case it does
not

51
00:06:12,500 --> 00:06:19,430
really matter. So, we will assume that the
domain the relations are available to us as

52
00:06:19,430 --> 00:06:28,490
explicit pairs of tuples which is the subset
of this cross product of the domains. Now,

53
00:06:28,490 --> 00:06:35,019
you
will you must have for example, solved set

54
00:06:35,019 --> 00:06:38,589
of linear equation they can also be seen as
a

55
00:06:38,589 --> 00:06:46,009
.constraint satisfaction problems except that
the domains may be continues in linear

56
00:06:46,009 --> 00:06:50,610
programming. Whereas, domains are discrete
in integer programming and they have their

57
00:06:50,610 --> 00:06:56,740
own so specialized kind of constraint satisfaction
problems have their own methods for

58
00:06:56,740 --> 00:06:58,139
solving them essentially

59
00:06:58,139 --> 00:07:02,329
So, for example, you know how to solve set
of linear e Q inequalities or a set of linear

60
00:07:02,329 --> 00:07:07,589
equations. We will not going to specialize
methods they eve those specialized methods

61
00:07:07,589 --> 00:07:12,068
obviously more efficient than the general
methods that we want to look at that. We want

62
00:07:12,069 --> 00:07:17,199
to explode is that for general kind of constraint
satisfaction problems. And we will be

63
00:07:17,199 --> 00:07:22,210
interested in those problems where the relations
are explicit and the domains are finite

64
00:07:22,209 --> 00:07:28,289
and discrete. We will called this a finite
constraint satisfaction problems and we want

65
00:07:28,290 --> 00:07:34,060
to
look at ways of solving those problems what

66
00:07:34,060 --> 00:07:54,060
is the solution a solution to a CSP. So, we
often say that a CSP is denoted often by R

67
00:07:54,060 --> 00:08:01,269
as this triple x d and c. An very often we
use

68
00:08:01,269 --> 00:08:10,698
the term constraint network it is the standard
term which the community uses. So, we

69
00:08:10,699 --> 00:08:15,038
will also stick to that but when you say as
a CSP or constraint network basically mean

70
00:08:15,038 --> 00:08:20,468
the same thing this is triple of set of variables
set of domains for the variables. And

71
00:08:20,468 --> 00:08:30,870
constraints was this variables solution to
a CSP is an assignment 

72
00:08:30,870 --> 00:08:44,480
to each variable
obviously from their domains such that each

73
00:08:44,480 --> 00:08:48,830
constraint is satisfied.

74
00:08:48,830 --> 00:09:01,480
So, they will define what we mean by constraint
in a moment essentially. But that is a

75
00:09:01,480 --> 00:09:06,840
general idea of a constraint satisfaction
problem again to repeat we have a set of

76
00:09:06,840 --> 00:09:12,950
variables we have set of domains for 1 domain
for each variable from which can take

77
00:09:12,950 --> 00:09:21,900
values. And we have a set of constraints defined
over a subset of those variables without

78
00:09:21,899 --> 00:09:27,130
loss of generality will assume that for each
possible scope there is only 1 constraint

79
00:09:27,130 --> 00:09:33,399
define. So, for example, if I take variable
x 1 and x 2 i define only 1 constraint on

80
00:09:33,399 --> 00:09:36,370
that I
will not define 2 separate constraints, because

81
00:09:36,370 --> 00:09:41,649
you can always combine the 2 constraints
into 1. So, we are assume that there is 1

82
00:09:41,649 --> 00:09:46,169
and the solution to CSP is an assignment to
each

83
00:09:46,169 --> 00:09:51,969
variable such that each constraint is satisfied
essentially. Now, this is very generate way

84
00:09:51,970 --> 00:09:57,879
of looking a things but it is very useful,
because it turns out that a lot of problems

85
00:09:57,879 --> 00:10:00,409
can be
as constraint satisfaction problems.

86
00:10:00,409 --> 00:10:06,919
And we can now subscribe to this strategy
of saying that if you solving a new problem

87
00:10:06,919 --> 00:10:14,299
just as a CSP then takes an of the self CSP
solver and use it to solve the CSP essentially.

88
00:10:14,299 --> 00:10:20,509
.So, we can capitalize upon the expertise
of people who have worked on constraint

89
00:10:20,509 --> 00:10:25,830
satisfaction problems and use their solutions
directly. So, only thing when you need to

90
00:10:25,830 --> 00:10:28,600
do
is so to pose it has a CSP and he turns out

91
00:10:28,600 --> 00:10:35,409
many, many problems can be pose as finite
discrete C S P’s for which we can use the

92
00:10:35,409 --> 00:10:40,899
methods that have discussed in the committee.
We will not have time to discuss those methods

93
00:10:40,899 --> 00:10:45,459
again as I said this is just giving you an
exposure to this particular field and for

94
00:10:45,460 --> 00:10:47,759
those of you who are interested you should
come

95
00:10:47,759 --> 00:10:51,649
to the planning and constraint satisfaction
course like semester in which you been look

96
00:10:51,649 --> 00:10:54,829
at
all the defined methods which we will not

97
00:10:54,830 --> 00:10:56,620
have time to discuss here.

98
00:10:56,620 --> 00:11:07,860
So, as in a side you should also observe that
is the problem is a special case of a CSP

99
00:11:07,860 --> 00:11:10,620
and
what is what kind of CSP it is? It is the

100
00:11:10,620 --> 00:11:16,269
CSP in which the domains each domain has 2
values 0 or 1 or true or false or whatever.

101
00:11:16,269 --> 00:11:18,120
And the constraints are defined in terms of
the

102
00:11:18,120 --> 00:11:24,750
logical operators that we talk about and or
and not and so on. And if you have such a

103
00:11:24,750 --> 00:11:29,110
problem where you have this then you have
a sat problem essentially. So, the sat problem

104
00:11:29,110 --> 00:11:34,850
is special kind of a CSP and again of course
sat has its own specialize approaches to

105
00:11:34,850 --> 00:11:39,540
solving them. So, there are approaches to
sat and all kinds of things. So, again we

106
00:11:39,539 --> 00:11:41,689
will
not going to the special ways of solving things

107
00:11:41,690 --> 00:11:43,990
essentially but we just observe that that
is

108
00:11:43,990 --> 00:11:46,740
also a CSP.

109
00:11:46,740 --> 00:11:47,740
.

110
00:11:47,740 --> 00:11:52,320
.Now, our favorite problem one of our favorite
problem small problems is this n queen

111
00:11:52,320 --> 00:12:01,510
problems. So, if you look at this problem
let say we are looking 4 queen and how can

112
00:12:01,509 --> 00:12:03,509
we
represent this? We can say that there are

113
00:12:03,509 --> 00:12:10,110
4 variables let say x 1 one for this column
x 2

114
00:12:10,110 --> 00:12:16,120
for this column x 3 for this column x 4 for
this column. And let us say the values the

115
00:12:16,120 --> 00:12:24,600
that
can take a ne 2 3 4 4 numbers 

116
00:12:24,600 --> 00:12:29,560
then we can express this as a CSP there equine
problems

117
00:12:29,559 --> 00:12:36,919
by 
specifying the constraint So, I will use the

118
00:12:36,919 --> 00:12:43,250
short form R 1 2 to stand for constraint
number 1 which has the scope of variables

119
00:12:43,250 --> 00:12:50,370
x 1 and x 2. So, will uses directly in a relation
here so it sort of clear between us. Then

120
00:12:50,370 --> 00:12:52,060
we are talking about a constraint which is
over

121
00:12:52,059 --> 00:12:57,309
the first 2 variables what us those constraints
we can simply specify it as saying that

122
00:12:57,309 --> 00:13:02,389
these pairs are allowed. So, for example,
you have placed the queen on first row the

123
00:13:02,389 --> 00:13:04,230
first
queen on the first row second queen I can

124
00:13:04,230 --> 00:13:05,730
only place on the third row.

125
00:13:05,730 --> 00:13:18,779
So, 1 comma 3 is allowed or 1 comma 4 is allowed
or 2 comma 4 is allowed or 3 comma

126
00:13:18,779 --> 00:13:29,470
1 is allowed or 4 comma 1 and 4 comma 2. So,
this is what I meant by saying that we

127
00:13:29,470 --> 00:13:33,950
have it available to us explicitly it does
not have to be implemented like this. As far

128
00:13:33,950 --> 00:13:36,970
as it
is only for our discussion that we are assuming

129
00:13:36,970 --> 00:13:40,389
that this constraint between the first
queen and the second queen i e expressed available

130
00:13:40,389 --> 00:13:44,990
to us as a pair of values that is 2
variables can take. So, each variable can

131
00:13:44,990 --> 00:13:48,009
take 4 on of this 4 values the domains are
all the

132
00:13:48,009 --> 00:13:54,689
same and this constraint is expressed like
this likewise you will have to express R 2

133
00:13:54,690 --> 00:14:06,330
3 R
1 3 R 1 4 R 2 4 and R 3 4. So, there are 6

134
00:14:06,330 --> 00:14:11,600
constraints, because you can choose 2 variables
in 6 place and all those 6 which I am leave

135
00:14:11,600 --> 00:14:18,220
as a small exercise for you is to be can be
expressed as a solution essentially. And then

136
00:14:18,220 --> 00:14:23,570
of course the problem is to find the set of
values for this variables such that the values

137
00:14:23,570 --> 00:14:26,430
satisfy all this constrain which means if
I

138
00:14:26,429 --> 00:14:33,199
taken a value for variable 1 and some value
for variable 2 let us call it i and j. Then

139
00:14:33,200 --> 00:14:36,200
that
pair i j must occur in set of topples here

140
00:14:36,200 --> 00:14:37,890
then that essentially.

141
00:14:37,889 --> 00:14:38,889
..

142
00:14:38,889 --> 00:14:52,970
So, we have some definitions we say that a
constraint or we say that assignment. We will

143
00:14:52,970 --> 00:15:08,120
use a bar as an assignment which will be a
short form for a set of so a over scope s.

144
00:15:08,120 --> 00:15:14,009
So,
basically this means that this scope as says

145
00:15:14,009 --> 00:15:20,549
on which variables this assignment is done
and this assignment selects 1 value for each

146
00:15:20,549 --> 00:15:25,819
variable from their respective domain
essentially. So, explicitly I would say something

147
00:15:25,820 --> 00:15:37,300
like ah x 1 is equal to some value a then
x 2 is equal to some value b and so on. But

148
00:15:37,299 --> 00:15:40,309
implicitly we will just assume that we will
as

149
00:15:40,309 --> 00:15:47,429
a vector of a b and so on. And we assume that
somehow we are able to specify what the

150
00:15:47,429 --> 00:15:53,259
variables are essentially it does not really
matter the only important thing is that

151
00:15:53,259 --> 00:15:58,850
assignment is over a scope S. The scope S
basically says that these are the variables

152
00:15:58,850 --> 00:16:01,800
to be
giving value essentially. So, an assignment

153
00:16:01,799 --> 00:16:15,799
a a over a scope S satisfies a constraint
ci if

154
00:16:15,799 --> 00:16:26,429
the following wholes that the scope of this
constrain which you will call S i is a subset

155
00:16:26,429 --> 00:16:30,559
of
this scope S which means every variable in

156
00:16:30,559 --> 00:16:37,039
the constraint has a value and we will use
the

157
00:16:37,039 --> 00:16:40,189
term pie to talk of a projection.

158
00:16:40,190 --> 00:16:49,110
So, I am sure you are familiar with a notion
of a projection here of a bar over this set

159
00:16:49,110 --> 00:16:54,180
S i.
So, why by this we mean that from this assignment

160
00:16:54,179 --> 00:16:58,479
a which is over some set of variables
which you called S select only those values

161
00:16:58,480 --> 00:17:04,650
which correspond to those variables which
belong to S i. And this is projection of a

162
00:17:04,650 --> 00:17:11,110
bar onto the subset of variable is a subset
of R i

163
00:17:11,109 --> 00:17:17,490
so an assignment satisfies. So, if I given
assignment here for example, i put a queen

164
00:17:17,490 --> 00:17:18,490
here

165
00:17:18,490 --> 00:17:35,089
.and i put the queen let say here and i put
queen here So, this assignment says a is equal

166
00:17:35,089 --> 00:17:40,048
to
1 for the first queen 4 for the second queen

167
00:17:40,048 --> 00:17:43,769
and 2 for the third queen that is an a bar
for

168
00:17:43,769 --> 00:17:48,628
this particular assignment and I can say that
this assignment a satisfies the solution R

169
00:17:48,628 --> 00:17:53,538
1 2
why because if I take the projection of the

170
00:17:53,538 --> 00:17:59,099
of the these variables on the first and the
second variable which is 1 and 4 I can find

171
00:17:59,099 --> 00:18:01,349
that 1 4 of course in my relation R.

172
00:18:01,349 --> 00:18:20,609
So, it satisfy the relation R then we say
that an assignment a bar is consistent. If

173
00:18:20,609 --> 00:18:26,689
it
satisfies all 

174
00:18:26,690 --> 00:18:37,860
constraints in its scope I will not expand
upon this. Basically we are saying

175
00:18:37,859 --> 00:18:43,449
this a bar has a scope S and for whichever
constraint that scope of that constraint is

176
00:18:43,450 --> 00:18:48,450
a
subset of S. It must satisfy that constraints

177
00:18:48,450 --> 00:18:52,650
which means projection over those variables
must be belong to that particular triples

178
00:18:52,650 --> 00:19:01,980
essentially. So, you can see that this particular
assignment which I have here where first queen

179
00:19:01,980 --> 00:19:05,558
is here the fourth queen second queen is
here and the third queen is here is consistent.

180
00:19:05,558 --> 00:19:08,359
So, I have not written those constraints,
but

181
00:19:08,359 --> 00:19:12,798
you can see that between 1 and 2. It is satisfying
the expected constraints what is the

182
00:19:12,798 --> 00:19:16,589
constraints that the queen must know the attack
another queen which here express

183
00:19:16,589 --> 00:19:21,668
explicitly here you could have express. It
has a relation which says x if that is the

184
00:19:21,669 --> 00:19:25,650
array
then xi not equal to y i or something like

185
00:19:25,650 --> 00:19:28,440
that essentially if x 1 xi why location of
the

186
00:19:28,440 --> 00:19:33,659
queen that they are not on the diagonal. They
are not on the same row they are not on the

187
00:19:33,659 --> 00:19:39,230
same column you could have express it something
like that essentially but we have

188
00:19:39,230 --> 00:19:40,259
expressed explicit here.

189
00:19:40,259 --> 00:19:44,419
So, we can see that the first 2 queens are
not attacking each other .So, they and be

190
00:19:44,419 --> 00:19:47,360
that
shown by this the second and the third also

191
00:19:47,359 --> 00:19:49,699
not attacking. So, if you are written R 2
3 you

192
00:19:49,700 --> 00:19:52,990
could have seen that and the first and the
third also not attacking and they would have

193
00:19:52,990 --> 00:19:57,740
been present in this essentially. So, we say
that this assignment a bar is consistent

194
00:19:57,740 --> 00:20:01,829
essentially sometime you use the term partial
assignment which means that if an

195
00:20:01,829 --> 00:20:06,528
assignment only 2 a subset of the variables.
But we will use the time term

196
00:20:06,528 --> 00:20:12,788
interchangeably or a partial solution some
time we say. So, an assignment is consistent

197
00:20:12,788 --> 00:20:15,829
if
it satisfies all the constraints which call

198
00:20:15,829 --> 00:20:20,760
within the scope in this case there are 3
constraints between queen 1, queen 2, queen

199
00:20:20,760 --> 00:20:24,960
1, queen 3 and queen 2, queen 3 and all the
3 are satisfied. So, this assignment is consistent

200
00:20:24,960 --> 00:20:29,929
now observe that just because it is
consistent it does not mean it can be a part

201
00:20:29,929 --> 00:20:35,150
of a solution. Because you can you surely
know that this cannot be extended to a complete

202
00:20:35,150 --> 00:20:37,259
solution essentially you cannot put a

203
00:20:37,259 --> 00:20:41,919
.value and you this thing you put it here
it will attack these 2. If you put it here

204
00:20:41,919 --> 00:20:44,179
it will
attack these 2 if you put it here it will

205
00:20:44,179 --> 00:20:46,509
attack this if you put here it will attack
these 2. So,

206
00:20:46,509 --> 00:20:47,919
you cannot place a variable.

207
00:20:47,919 --> 00:20:53,220
So, this a consistent partial solution but
it is not a consistent full solution. A full

208
00:20:53,220 --> 00:20:59,450
solution
is a consistent assignment to all the variables

209
00:20:59,450 --> 00:21:04,870
which is another way of saying that what
you are said here that a CSP solution to a

210
00:21:04,869 --> 00:21:08,888
CSP assignment to each variable which
satisfies all the constrain essentially which

211
00:21:08,888 --> 00:21:12,918
is the same thing that is saying that if you
assign all the variables and it is consistent

212
00:21:12,919 --> 00:21:30,940
it is a solution essentially. So, how do we
solve? So, again we want to look at general

213
00:21:30,940 --> 00:21:36,870
purpose methods of solving CS P's just like
with it for state space or we did not care

214
00:21:36,869 --> 00:21:41,888
what the state was and where the moves end
came from as long as we had move zen function

215
00:21:41,888 --> 00:21:45,569
and as long as we had a goal test
function. We said we will use the search algorithm

216
00:21:45,569 --> 00:21:49,668
that are used likewise we have just
made an observation that many problems can

217
00:21:49,669 --> 00:21:53,320
be posed as C S P’s I have mentioned
sometime during planning. That planning can

218
00:21:53,319 --> 00:21:57,839
be posed as a CSP which we will not have
time to going here but it can be planning

219
00:21:57,839 --> 00:22:00,709
can be also posed as sat which is the special
case of C S P.

220
00:22:00,710 --> 00:22:08,190
Both are slightly different formulation and
we will look at in due course couple of more

221
00:22:08,190 --> 00:22:16,159
problems which can be posed as CSP but we
want to look at general purpose ways of

222
00:22:16,159 --> 00:22:23,710
solvency C S P’s essentially. So, let me
discuss 1 more problem before we go just to

223
00:22:23,710 --> 00:22:26,029
to
highlight what are the issues involved. So,

224
00:22:26,029 --> 00:22:33,138
let say we are doing this map coloring map
coloring can also be posed as CSP before we

225
00:22:33,138 --> 00:22:39,299
come to map coloring we are not said
anything about the scopes of this constraints

226
00:22:39,299 --> 00:22:43,158
essentially do we have any constraints on
the scope of this constraints. I have posed

227
00:22:43,159 --> 00:22:51,320
this problem where the scope was 2 variables
between queen 1 queen 2 or queen 1 queen 3

228
00:22:51,319 --> 00:22:55,319
or between queen 1 and queen 4 and so on
and so forth why not between 3 variables between

229
00:22:55,319 --> 00:23:01,950
4 variables in this. You can express
constraints and in more variables for example,

230
00:23:01,950 --> 00:23:06,970
if I had express the constraints as a
constraint of 4 variables I would actually

231
00:23:06,970 --> 00:23:09,350
be expressing the solution itself, because
I

232
00:23:09,349 --> 00:23:13,959
would have just basically the set of solutions
in that essentially. So, in fact, this kind

233
00:23:13,960 --> 00:23:17,669
of
illustrates the idea that we pursue in constraint

234
00:23:17,669 --> 00:23:21,649
satisfaction problems that you do not have
to specify the problem completely as long

235
00:23:21,648 --> 00:23:24,219
as you give some specification of the set
of

236
00:23:24,220 --> 00:23:33,298
constraints it is a task of the solver to
elicit a solution out of that essentially.

237
00:23:33,298 --> 00:23:38,158
.So, what is the solution to this? You know
that solution to the CSP there in fact only

238
00:23:38,159 --> 00:23:51,960
2
solution 1 is 3 1 2 4 and the other is 2 3

239
00:23:51,960 --> 00:24:09,379
1 4 2 3 1 4 2. And the other 1 is if I start
with 2

240
00:24:09,378 --> 00:24:18,519
and 4 1 and 3 I have only these 3 now this
particular relation is a relation on the set

241
00:24:18,519 --> 00:24:21,429
of 4
variables this is called a solution relation

242
00:24:21,429 --> 00:24:32,190
where R refers to this constraint satisfaction
problem. So, correspondent to a constraint

243
00:24:32,190 --> 00:24:36,580
satisfaction problem there is a solution
relation and it is task of the solver to elicit

244
00:24:36,579 --> 00:24:42,569
the this solution from the CSP I have only
specify binary constraints here between 2

245
00:24:42,569 --> 00:24:44,428
variables. And the solver will eventually
tell

246
00:24:44,429 --> 00:24:48,500
me the these are the 2 possible solutions
it may not express in this form but it gave

247
00:24:48,500 --> 00:24:51,490
me an
assignment of all possible variables and we

248
00:24:51,490 --> 00:24:59,038
will do that. So, without again loss of
generality we will assume that we are working

249
00:24:59,038 --> 00:25:06,058
with binary relations.

250
00:25:06,058 --> 00:25:12,960
A binary C S P’s and a binary C S P’s
we mean that C S P’s which have scopes of

251
00:25:12,960 --> 00:25:17,038
size
either 1 or 2 essentially scope of size 1

252
00:25:17,038 --> 00:25:19,700
basically says that I am defining subset of
domain

253
00:25:19,700 --> 00:25:25,808
scope of size to subset of the cross product
of 2 domains. So, binary CSP has scopes 1

254
00:25:25,808 --> 00:25:28,908
or
2 and such a CSP is called binary CSP and

255
00:25:28,909 --> 00:25:34,309
it has been shown that any higher order CSP
can be converted to a binary CSP by adding

256
00:25:34,308 --> 00:25:38,629
more variable essentially. So, I will leave
this as a small thought exercise for you to

257
00:25:38,630 --> 00:25:44,890
work on how can I converted into how can I
convert this. For example, into a binary CSP

258
00:25:44,890 --> 00:25:49,970
if this was my original CSP which is the
solution itself how can converted into a binary

259
00:25:49,970 --> 00:25:58,179
CSP. So, we will stick to binary C S P’s
because we know the there is a whole lot of

260
00:25:58,179 --> 00:26:05,259
methods which obtain those problems and
other problems can be express as a binary

261
00:26:05,259 --> 00:26:13,659
C S P's. So, this map coloring problem is
naturally pose as a binary CSP ao.

262
00:26:13,659 --> 00:26:14,659
..

263
00:26:14,659 --> 00:26:24,450
Let say I have 3 countries will not name them
and let us say my formulation of C S P’s

264
00:26:24,450 --> 00:26:32,639
that I have a relation between this, this,
and this. So, let us just called this x 1

265
00:26:32,638 --> 00:26:37,569
x 2 and x 3
and let us say they have the same domains

266
00:26:37,569 --> 00:26:40,980
which is let say just 2 colors are allowed
red

267
00:26:40,980 --> 00:26:51,868
and blue. So, I think that I think the domains
inside this circles and the relation is not

268
00:26:51,868 --> 00:27:02,558
equal to now we can see that this problem
has 2 solutions. You can color these 2 red

269
00:27:02,558 --> 00:27:04,999
and
this 1 blue or you can color these 2 blue

270
00:27:04,999 --> 00:27:15,379
and this 1 red essentially which means implicitly
there is a constraint between these 2 variables.

271
00:27:15,378 --> 00:27:16,939
But that constraint is not explicit it has
not

272
00:27:16,940 --> 00:27:21,690
been mentioned in the CSP the CSP only says
that I have a constrain between x 1 and x

273
00:27:21,690 --> 00:27:24,070
2
and between x 1 and x 3. I do not say anything

274
00:27:24,069 --> 00:27:28,128
about x 2 and x 3 but eventually off
course, this can be again elicit ate through

275
00:27:28,128 --> 00:27:32,969
a process of solving the constraint. And we
will try and see whether we get some insight

276
00:27:32,970 --> 00:27:48,819
into how we acquire new relations in the in
some manner essentially. So, how so let us

277
00:27:48,819 --> 00:27:53,178
look at these 2 problems. So, we have now
you know in those case 4 variables in this

278
00:27:53,179 --> 00:28:00,909
case 3 variables and we have some domains
and so on. How can we solve a C S P?

279
00:28:00,909 --> 00:28:18,679
The simplest approach you can go back to state
space search. You try you sign a value

280
00:28:18,679 --> 00:28:23,120
for the first variable; you have sign a value
for the second variable; you assign a value

281
00:28:23,119 --> 00:28:29,489
for third variable assign a value for fourth
variable and so on. Finish an assignment in

282
00:28:29,490 --> 00:28:33,298
state space search we would have finish the
assignment and then check whether it is goal

283
00:28:33,298 --> 00:28:43,038
.state or not in constraint satisfaction problems.
We can backtrack earlier why because the

284
00:28:43,038 --> 00:28:48,079
moment you know that some constraint is not
being satisfied or some we have defined

285
00:28:48,079 --> 00:28:52,638
the lotion of consistent assignment or consistent
partial solution. The moment we know

286
00:28:52,638 --> 00:28:58,648
that the assignment is not consistent we can
backtrack from their essentially. So, you

287
00:28:58,648 --> 00:29:00,859
do
not have to assign values to all variables.

288
00:29:00,859 --> 00:29:02,670
So, in other words you do not have to assign
values to all variables. So, in other words

289
00:29:02,671 --> 00:29:03,671
you do not have to as in this case of course
you

290
00:29:03,671 --> 00:29:07,769
will backtrack only when you see the fourth
when you try to put the fourth queen. But

291
00:29:07,769 --> 00:29:10,099
if
you let us try a 6 queen problem, you will

292
00:29:10,099 --> 00:29:14,099
see that there is some kind of processing
you

293
00:29:14,099 --> 00:29:17,629
can do when you can back track only or you
might be able to backtrack only.

294
00:29:17,630 --> 00:29:18,630
.

295
00:29:18,630 --> 00:29:30,380
So, the simplest algorithm for solving a CSP
is called backtracking it is a official name

296
00:29:30,380 --> 00:29:39,850
of name of this algorithm essentially. So,
everybody uses this term essentially. So,

297
00:29:39,849 --> 00:29:42,109
what
do we have? We have constraint satisfaction

298
00:29:42,109 --> 00:29:49,490
problems given x given d and given c
essentially. So, let us this outline this

299
00:29:49,490 --> 00:29:58,788
algorithm So, 1 issue that keep in mind is
that let

300
00:29:58,788 --> 00:30:04,220
say you have assigned some value to x 2 and
then you are trying for values of e c. And

301
00:30:04,220 --> 00:30:10,569
let say you assigned the third value to x
2 let us say in a set of domain you are trying

302
00:30:10,569 --> 00:30:14,269
the
third value 2 x 2. Then you go forward to

303
00:30:14,269 --> 00:30:17,638
x 3 and you find that there is no values to
x 3

304
00:30:17,638 --> 00:30:28,269
and you need to back track to the fourth value
of x 2 and then try all values of x 3 again.

305
00:30:28,269 --> 00:30:32,058
So, the fact that you every time you go back
and forth you have to keep track of what

306
00:30:32,058 --> 00:30:38,519
.values left for you to try this algorithm
does takes a very approach it makes a copy

307
00:30:38,519 --> 00:30:39,740
of the
domain every time.

308
00:30:39,740 --> 00:30:54,269
So, it start up by saying i gets the value
1 di is a copy of di in this case d 1 and

309
00:30:54,269 --> 00:31:19,058
while i is
in this range n it does the following 

310
00:31:19,058 --> 00:31:26,950
it calls off function call select value. So,
let say x

311
00:31:26,950 --> 00:31:45,859
gets a value from a function called select
value I should also initialize a equal to

312
00:31:45,858 --> 00:31:50,648
empty
initially I do not have a value for the partial

313
00:31:50,648 --> 00:32:00,629
solution given a select value for this x i
x i d

314
00:32:00,630 --> 00:32:11,390
i c. So, what this select value function will
do is it will give me the next value for xi

315
00:32:11,390 --> 00:32:15,278
from
its domain d i; d i prime actually with this

316
00:32:15,278 --> 00:32:22,288
consistent 
by this you mean it is consistent

317
00:32:22,288 --> 00:32:29,960
with all the previous variables that have
been given values. So, if xi is equal to 4

318
00:32:29,960 --> 00:32:34,460
let us
say then if there is a constraint between

319
00:32:34,460 --> 00:32:39,298
1 3 and 4. Then this value for the first variable
must be consistent with those first and third

320
00:32:39,298 --> 00:32:45,700
value since essentially the way that you have
just defined there essentially. So, it will

321
00:32:45,700 --> 00:32:50,340
written 2 things it will either it something
called

322
00:32:50,339 --> 00:33:29,048
null which means it cannot find a value then
we say i goes to i minus 1 D i prime hence

323
00:33:29,048 --> 00:33:58,788
i
goes to i plus 1 you have got some value for

324
00:33:58,788 --> 00:34:09,960
x 1. You got some value for x 2 you got
some value for x 3 or let me try and draw

325
00:34:09,960 --> 00:34:26,199
more elaborate diagram let say x 1 has theses
values x 2 has or d 1.

326
00:34:26,199 --> 00:34:38,219
So, let us say you are looking at x 4 now
and let say you have always progressing from

327
00:34:38,219 --> 00:34:43,000
let say your select value function always
fix the value from left to right, because

328
00:34:43,000 --> 00:34:45,869
they are
in some list and it has selected this value

329
00:34:45,869 --> 00:34:50,359
for d 1 and this value for d 2 and this value
for

330
00:34:50,360 --> 00:34:57,440
d 3. And now we are trying to find if any
of these values for d 4 is consistent with

331
00:34:57,440 --> 00:35:04,659
this
assignment we have here essentially. So their

332
00:35:04,659 --> 00:35:13,110
2 thing that can happen either it can it will
say that no nothing is possible here which

333
00:35:13,110 --> 00:35:16,480
means I was go and look for a new value for
d

334
00:35:16,480 --> 00:35:22,630
3 here, because we are tried this. So, we
are doing simple that first search over this

335
00:35:22,630 --> 00:35:25,160
3 of
possibilities where you start with the first

336
00:35:25,159 --> 00:35:27,299
1 here then the first 1 here then the first
1 here

337
00:35:27,300 --> 00:35:32,769
and then keep back trap. If you cannot find
a variable value here you must go back to

338
00:35:32,769 --> 00:35:36,500
this
1 and try the next value for this essentially

339
00:35:36,500 --> 00:35:43,250
which means you must set i is equal to i
minus 1. So, I do not need to change this

340
00:35:43,250 --> 00:35:46,099
right.

341
00:35:46,099 --> 00:35:56,579
So, let see what select value is going to
do 

342
00:35:56,579 --> 00:36:00,081
essentially what it will do? So, let say you
are

343
00:36:00,081 --> 00:36:15,769
looking at xi from di and c it will say let
us say a gets head of di if it is a list it

344
00:36:15,769 --> 00:36:31,070
takes a
first value and it says di di before that

345
00:36:31,070 --> 00:36:37,559
it must have check which says that if di is
equal to

346
00:36:37,559 --> 00:36:51,070
.empty then return null. So, if any point
di becomes empty it must return null otherwise

347
00:36:51,070 --> 00:36:55,620
it
it should go into the this loops looking for

348
00:36:55,619 --> 00:37:06,779
consistent value if a i if a sorry let us
call this

349
00:37:06,780 --> 00:37:13,780
a a i if a comma a i. It means the whole solution
that has been constructed so far which

350
00:37:13,780 --> 00:37:21,740
we will as a. So, this 3 values in this examples
plus this fourth value that we are we are

351
00:37:21,739 --> 00:37:27,979
just picked from its domain we put them all
together and that is a new partial solution

352
00:37:27,980 --> 00:37:34,369
if
this is consistent 

353
00:37:34,369 --> 00:37:44,750
then return a i. Well I called it x here you
could have called it x it does

354
00:37:44,750 --> 00:37:51,539
not matter. So, it is in a loop inside taking
out values from the domain taking out and

355
00:37:51,539 --> 00:37:59,679
showing them to speak essentially. So, when
it was doing d 3 that d 3 prime had thrown

356
00:37:59,679 --> 00:38:01,809
away these two values from the domain.

357
00:38:01,809 --> 00:38:06,519
So, they were not there in d 3 prime anymore.
So, when it backtrack it must try the next

358
00:38:06,519 --> 00:38:11,460
value essentially then it must try the next
value then the next value. And if you cannot

359
00:38:11,460 --> 00:38:15,710
find there is must backtrack that is the standard.
Therefore search chronological

360
00:38:15,710 --> 00:38:23,170
backtracking that we have been talking about
this other form of backtracking that we had

361
00:38:23,170 --> 00:38:28,789
mentioned dependency directed backtracking
was actually invented for solving for

362
00:38:28,789 --> 00:38:33,539
improving this algorithm backtrackings. So,
that instead of if you cannot find a value

363
00:38:33,539 --> 00:38:39,090
for
d 4 just to give an example that let say only

364
00:38:39,090 --> 00:38:43,320
constraint that d 4 participate it is in let
us

365
00:38:43,320 --> 00:38:52,070
call it R 1 2 4 which means this variables
1 and 2 and 4 essentially or if you want to

366
00:38:52,070 --> 00:38:56,370
work
with binary constraints and let us say R 1

367
00:38:56,369 --> 00:39:01,769
4 and R 2 4. So, let say the only constraints
d 4

368
00:39:01,769 --> 00:39:08,380
participates as in with variable 1 and variable
2 with variable 2 then if you cannot find

369
00:39:08,380 --> 00:39:13,280
the value for d 4. What is the point of looking
for new value for d 3? Because d 3

370
00:39:13,280 --> 00:39:19,540
anyway not influencing the consistency of
the choice of d 4 essentially the only thing

371
00:39:19,539 --> 00:39:24,139
that d 4 is getting influences by this relation
R 1 4 or by R 2 4.

372
00:39:24,139 --> 00:39:28,500
And the fact that you cannot find value for
d 4 means that one of this relations you

373
00:39:28,500 --> 00:39:33,119
cannot satisfy which means actually you should
really jump back here. But of course we

374
00:39:33,119 --> 00:39:37,400
will not get into that here, because it needs
a little bit more formulization. So, that

375
00:39:37,400 --> 00:39:39,760
is the
general idea of dependency directed backtracking

376
00:39:39,760 --> 00:39:42,841
that if you can keep track of which
constraint is being evaluated. Then you can

377
00:39:42,840 --> 00:39:48,639
jump back to one of the variables in that
constraint in this case they have binary here

378
00:39:48,639 --> 00:39:50,769
essentially. But in our example we just to
i is

379
00:39:50,769 --> 00:39:54,849
equal to i minus 1 which is like doing chronological
backtracking if you cannot find a

380
00:39:54,849 --> 00:40:10,599
value for d 4 try a new value for d 3 and
so on essentially. So, that is a i mean I

381
00:40:10,599 --> 00:40:12,940
have
written may be it is not quite correct something

382
00:40:12,940 --> 00:40:14,400
is missing here. But you can work that

383
00:40:14,400 --> 00:40:22,010
.out work out the details, but the basic idea
is to go down this set of choices looking

384
00:40:22,010 --> 00:40:24,650
for a
new value for the is variable. If you cannot

385
00:40:24,650 --> 00:40:29,320
find it if you can find it go to the next
variable which is what we have doing here

386
00:40:29,320 --> 00:40:35,120
i is equal to i plus 1 di copied the domain
and

387
00:40:35,119 --> 00:40:39,589
solution that we have made and then keep going
forward in that session if you cannot

388
00:40:39,590 --> 00:40:45,740
find it backtrack. So, it is simple depth
first search being done over this structure

389
00:40:45,739 --> 00:40:57,149
of the
now this algorithm is actually the simplest

390
00:40:57,150 --> 00:41:00,769
the starting point for constraint satisfaction
problem algorithms.

391
00:41:00,769 --> 00:41:05,460
The other algorithm which improve upon that
do the following is that for example, some

392
00:41:05,460 --> 00:41:10,229
algorithms when they are doing select value
though look head to see whether or given

393
00:41:10,230 --> 00:41:17,639
choice will in future conflicts with some
vary variable essentially. So, that is one

394
00:41:17,639 --> 00:41:21,629
kind of
you know improvement which is called look

395
00:41:21,630 --> 00:41:26,349
ahead algorithm then we have this kind of
intelligent backtracking algorithm. So, dependency

396
00:41:26,349 --> 00:41:30,799
directed backtracking algorithm that
we are talking about essentially and there

397
00:41:30,800 --> 00:41:33,850
are some other things that we will discuss.
So,

398
00:41:33,849 --> 00:41:41,170
that you get a flavor of that essentially,
but this by and large is a the simple algorithm.

399
00:41:41,170 --> 00:41:50,519
Now observe that backtracking happens the
moment of partial solution is what is a

400
00:41:50,519 --> 00:42:03,259
partial solution we are talking about here
it is a value for a 1 for a 2 and up to a

401
00:42:03,260 --> 00:42:07,440
i minus
1. And we cannot find we cannot extend this

402
00:42:07,440 --> 00:42:13,110
to a i or the is value for the is variable
or 2

403
00:42:13,110 --> 00:42:21,130
x i. Let say we cannot find a value for this
is variable and we backtrack at this point

404
00:42:21,130 --> 00:42:24,309
itself
we do not go further to see you know, because

405
00:42:24,309 --> 00:42:55,309
at this point as you can see no by
definition not right no a solution is a consistent

406
00:42:55,309 --> 00:43:01,110
assignment to all the variables. Or in
other words a solution is an assignment to

407
00:43:01,110 --> 00:43:02,110
all the variables.

408
00:43:02,110 --> 00:43:07,930
So, that every constraint is satisfied and
a partial solution or a or a partial assignment

409
00:43:07,929 --> 00:43:11,299
is
consistent. If it satisfies all the constrain

410
00:43:11,300 --> 00:43:17,630
for whom values have been selected or who's
scope fall within this essentially here. So,

411
00:43:17,630 --> 00:43:29,130
we say that constraint ci assignment a bar
satisfies ci if the scope of the ci is has

412
00:43:29,130 --> 00:43:33,510
a value which means it is already in the
assignment. And the projection of this assignment

413
00:43:33,510 --> 00:43:38,570
over this scope of S i is a subset of
this which means it which actually I should

414
00:43:38,570 --> 00:43:51,690
say belongs to this belongs word here belong
to this and in. So, that is only for with

415
00:43:51,690 --> 00:43:54,940
respect to 1 constraint ci and assignment
is

416
00:43:54,940 --> 00:43:58,929
consistent if it is satisfies the all the
constrain with satisfy this property which

417
00:43:58,929 --> 00:44:03,289
means to
scope are contained in this and who's projection

418
00:44:03,289 --> 00:44:07,670
is contained in that correspondent
essentially. So, it can only be that it can

419
00:44:07,670 --> 00:44:10,610
never be the case that a that assignment which
is

420
00:44:10,610 --> 00:44:19,820
.a partial solution which is not consistent
can never consistency. So, when I was talking

421
00:44:19,820 --> 00:44:25,760
about beginning on CSP one of the thing. So,
I had said was that CSP is very interesting

422
00:44:25,760 --> 00:44:30,610
because it allows you to combine search with
reasoning now that reasoning part web

423
00:44:30,610 --> 00:44:35,740
have not seemed. Let me just give you a motivation
for that and then in the next class,

424
00:44:35,739 --> 00:44:50,739
we will see how that is done. So, one of the
another problem which is pose as a CSP you

425
00:44:50,739 --> 00:45:02,799
know if you solving a crossword puzzle. Or
if you are solving sudoku or something you

426
00:45:02,800 --> 00:45:06,380
do a lot of reasoning in fact you are supposed
to do more reasoning than search.

427
00:45:06,380 --> 00:45:07,380
.

428
00:45:07,380 --> 00:45:24,019
So, they these problems are similar they are
called some of you must have looked at such

429
00:45:24,019 --> 00:45:30,190
problem and if you just search on the web
you will find examples. So, for example, you

430
00:45:30,190 --> 00:45:44,909
might say send plus more. So, these are sort
of arithmetic problems in which we the

431
00:45:44,909 --> 00:45:51,239
digits have not been revealed, but they have
been replaced by letters and your task is

432
00:45:51,239 --> 00:45:55,390
to
find out what digit does each letter stand

433
00:45:55,391 --> 00:46:12,630
for. So, we assume that each assignment is
distinct that that 1 letter stands for exactly

434
00:46:12,630 --> 00:46:18,559
1 digit and so on. So, how would you solve
such a problem essentially? So, if you want

435
00:46:18,559 --> 00:46:37,619
solve this or let me take another example.
So, here is a another example. So, this plus

436
00:46:37,619 --> 00:46:44,420
this should give you apple essentially. So,
if

437
00:46:44,420 --> 00:46:50,230
you wanted to solve something like this then
what you would do is you would create a

438
00:46:50,230 --> 00:47:00,211
variable for each a place for each letter
of course the number of variables are number

439
00:47:00,210 --> 00:47:07,000
of
distinct letters in this problem, but you

440
00:47:07,000 --> 00:47:09,159
want to find vales for them. So, these boxes
that

441
00:47:09,159 --> 00:47:19,239
.an creating are boxes for values this a plus
and obviously you must create some more

442
00:47:19,239 --> 00:47:24,399
boxes which are for carry over.

443
00:47:24,400 --> 00:47:32,480
So, 4 boxes for carry over and you can define
the domains of so these variables so the

444
00:47:32,480 --> 00:47:38,789
domain of this is 0 slash 1, because we adding
2 numbers we can never have carry over

445
00:47:38,789 --> 00:47:45,389
moves and 1 and the domains of these are 0
to 9 essentially. So, the kind of reasoning

446
00:47:45,389 --> 00:47:50,920
that Sangeetha was talking about we can do
here essentially. So, for example, you can

447
00:47:50,920 --> 00:47:58,110
observe that this must be 1, because you can
never be get a value of more than 1 which

448
00:47:58,110 --> 00:48:02,440
means this carry over must of course we are
not interested on this. But never the less

449
00:48:02,440 --> 00:48:04,750
the
what the moment we have said this a a equal

450
00:48:04,750 --> 00:48:10,260
to 1 we know that this is equal to 1 and this
equal to 1. We can fill in the value there

451
00:48:10,260 --> 00:48:20,810
t is 9, why t 9? And it must be distinct this
a p

452
00:48:20,809 --> 00:48:34,909
and t are distinct they cannot stand for same
digit. So, which means this p cannot be 1

453
00:48:34,909 --> 00:48:46,259
and in any case p cannot be 1 So, if t is
nine then what is p is 0 this must be 1 we

454
00:48:46,260 --> 00:48:54,760
have 0
here also know and we have nine for t here

455
00:48:54,760 --> 00:48:56,960
we have nine here nine here So, this must
be

456
00:48:56,960 --> 00:49:01,400
eight this must be 1 So, we know this must
be 3.

457
00:49:01,400 --> 00:49:15,480
So this is 0, now, we need to fill in this

458
00:49:15,480 --> 00:49:21,719
is 8. So, this leaves only 2 for this. So,
we have

459
00:49:21,719 --> 00:49:25,049
off course, solved in this problem now, and
we are solved it through a process of

460
00:49:25,050 --> 00:49:30,019
reasoning certain some rezoning with it you
know this can only be 1 and know this kind

461
00:49:30,019 --> 00:49:37,130
of stuff. Now, if you off course, were not
should I say smart enough to do this kind

462
00:49:37,130 --> 00:49:40,160
of
reasoning you could still have try this algorithm

463
00:49:40,159 --> 00:49:44,210
backtracking here you could have said
try a value for a try a value for b and so

464
00:49:44,210 --> 00:49:47,980
on and so forth. Off course, we have to express
the constraint, how do we express the constraints

465
00:49:47,980 --> 00:49:57,170
that this plus this must be either this
must be either equal to this plus this or

466
00:49:57,170 --> 00:50:02,440
this plus this this plus carry over 1 and
modulo

467
00:50:02,440 --> 00:50:08,650
10. So, we have to express that carefully
essentially, but the point is that we a try

468
00:50:08,650 --> 00:50:12,869
to make
here is that solving constraint satisfaction

469
00:50:12,869 --> 00:50:17,869
problems not necessarily have to be done
through a search method like backtracking.

470
00:50:17,869 --> 00:50:23,409
They can be done through other processes
like reasoning in some way now can this reasoning

471
00:50:23,409 --> 00:50:25,529
be done in general purposely
essentially.

472
00:50:25,530 --> 00:50:33,269
Of course, here we are exploding the rules
of arithmetic and it turns out that yes indeed

473
00:50:33,269 --> 00:50:45,230
you can do a certain amount of. So, this process
is called constraint propagation. So, we

474
00:50:45,230 --> 00:50:53,230
are saying that if this is 1 this must be
0; this is 0; this must be 9 and this must

475
00:50:53,230 --> 00:50:54,230
we are

476
00:50:54,230 --> 00:50:58,039
.propagating the constraint. So, what are
we doing here basically reducing the domains

477
00:50:58,039 --> 00:51:00,289
of
the variable we have reduce this from 0 to

478
00:51:00,289 --> 00:51:03,869
9 to just 1 value 1 and just to 0 and so on
so

479
00:51:03,869 --> 00:51:09,289
forth. And the moment we reduce the value
of some domain some variable we can

480
00:51:09,289 --> 00:51:15,199
propagate a reduction to another domain. This
idea of propagation is of course very

481
00:51:15,199 --> 00:51:20,730
common in reasoning. And we will see in the
next class little bit about how this can be

482
00:51:20,730 --> 00:51:26,699
generalized. And we will look at another interesting
problem that propagation demands

483
00:51:26,699 --> 00:51:32,579
that quite effectively. So, we will stop here
with this.

484
00:51:32,579 --> 00:51:42,579
.

