1
00:00:10,808 --> 00:00:15,768
.Let us begin; we are looking at rule based
systems.

2
00:00:15,769 --> 00:00:24,698
As we discussed earlier, in rule
based system, the program part, if you want

3
00:00:24,699 --> 00:00:28,660
to call it, is written as a set of rules.

4
00:00:28,660 --> 00:00:32,168
Now,
these rules can do all kind of things.

5
00:00:32,168 --> 00:00:37,750
They can do what you would do in normal
programming, for example, sort an array, and

6
00:00:37,750 --> 00:00:44,320
things like that, but they are also, by
instrumental, in capturing what we would say

7
00:00:44,320 --> 00:00:45,738
as expert knowledge, essentially.

8
00:00:45,738 --> 00:00:50,448
So, we
catch a domain expert and try to get knowledge

9
00:00:50,448 --> 00:00:54,588
out of expert, and put it in the form of
rules.

10
00:00:54,588 --> 00:00:59,140
So, you could mix up rules of different kinds
into one system.

11
00:00:59,140 --> 00:01:04,849
That is why, in the
70s and 80s, this was known as the domain

12
00:01:04,849 --> 00:01:07,209
of expert systems.

13
00:01:07,209 --> 00:01:12,719
It was quite in exercise to
get to experts and elicit their knowledge

14
00:01:12,719 --> 00:01:13,719
from them.

15
00:01:13,719 --> 00:01:17,590
There was a whole exercise of what
they use to call as knowledge acquisition

16
00:01:17,590 --> 00:01:20,200
where, they have protocols of how to talk
to

17
00:01:20,200 --> 00:01:24,549
expert, and how to extract knowledge from
them, and then put it in the form of rules,

18
00:01:24,549 --> 00:01:25,549
essentially.

19
00:01:25,549 --> 00:01:32,608
Eventually, as I said in my last class, this
technology, all this has stabilized

20
00:01:32,608 --> 00:01:39,919
into something, which is more popular among
business users, because users in banks and

21
00:01:39,920 --> 00:01:46,409
other such organizations; they are able to
express what they call as business rules in

22
00:01:46,409 --> 00:01:49,310
a
very simple language, and the rest of the

23
00:01:49,310 --> 00:01:51,739
programs takes care of everything else,
essentially.

24
00:01:51,739 --> 00:01:52,739
..

25
00:01:52,739 --> 00:02:13,150
If you remember that a rule based system,
consists of set of rules 

26
00:02:13,150 --> 00:02:20,269
what we call as a
working memory, which basically, holds the

27
00:02:20,269 --> 00:02:28,090
data and an inference engine.

28
00:02:28,090 --> 00:02:33,900
Inference
engine is a program, whose job is to select

29
00:02:33,900 --> 00:02:40,400
rules, and apply them to data, and repeatedly
do that, essentially.

30
00:02:40,400 --> 00:02:46,289
So, we saw that what this does is that it
is a process, three stage

31
00:02:46,289 --> 00:02:47,359
process.

32
00:02:47,360 --> 00:02:56,830
We have match; what match does?

33
00:02:56,830 --> 00:02:58,689
It takes inputs.

34
00:02:58,688 --> 00:03:07,609
So, this is the most important
part of a rule based system; what it does

35
00:03:07,610 --> 00:03:11,290
is it takes a working memory as an input,
and it

36
00:03:11,289 --> 00:03:19,769
takes the set of rules as input, and produces
what we call as a conflict set.

37
00:03:19,769 --> 00:03:23,260
So, what is this
doing?

38
00:03:23,259 --> 00:03:39,459
If you remember that each rule is of the form
pattern 1, pattern 2, pattern n, and

39
00:03:39,459 --> 00:03:41,009
some actions on the other side.

40
00:03:41,009 --> 00:03:47,090
The actions were, as we discussed earlier;
either, making

41
00:03:47,090 --> 00:03:54,060
new data elements or deleting some.

42
00:03:54,060 --> 00:04:00,490
So, if you look at these patterns, this is
what is used

43
00:04:00,490 --> 00:04:02,890
for matching the data.

44
00:04:02,889 --> 00:04:05,958
If you collect together, all the patterns
from all the rules, then you

45
00:04:05,959 --> 00:04:21,379
would have pattern 11, pattern 12, pattern,
let us say, 31, pattern 32.

46
00:04:21,379 --> 00:04:27,709
So, we will have a
whole list of patterns, and this working memory

47
00:04:27,709 --> 00:04:35,198
is an ordered set; ordered, in the sense
of time stamp.

48
00:04:35,199 --> 00:04:40,430
So, all these are working memory elements.

49
00:04:40,430 --> 00:04:49,180
In the match phase, because we want to be
complete; every pattern must be compared

50
00:04:49,180 --> 00:04:53,650
with every working memory element, because
you want to produce all instances of rules

51
00:04:53,649 --> 00:04:55,750
which are matching; not just one instance.

52
00:04:55,750 --> 00:04:59,360
So, every pattern has to be compared with
every working memory element, and that is

53
00:04:59,360 --> 00:05:00,360
to be done for this.

54
00:05:00,360 --> 00:05:05,819
So, it is a human less
amount of task to be done.

55
00:05:05,819 --> 00:05:07,339
What this produces is a conflict set.

56
00:05:07,339 --> 00:05:14,179
The conflict set is a list of
rules or instances of rules, along with a

57
00:05:14,180 --> 00:05:18,629
time stamp, like this 1, 2, 3 and so on; time

58
00:05:18,629 --> 00:05:19,930
.stamps of the data.

59
00:05:19,930 --> 00:05:25,420
Then, the task is to select which of those
matching rules, we have to

60
00:05:25,420 --> 00:05:26,420
fire.

61
00:05:26,420 --> 00:05:32,069
We discussed a few conflict resolution strategies,
like specificity, and recency, and

62
00:05:32,069 --> 00:05:34,830
mean sense analysis, and so on.

63
00:05:34,829 --> 00:05:43,300
So, this is given to an section called resolve,
which

64
00:05:43,300 --> 00:05:50,509
selects one rule from the conflict set, along
with its data and then, this is given to rule

65
00:05:50,509 --> 00:06:03,080
plus data, and by data, we mean the working
memory elements; execute.

66
00:06:03,079 --> 00:06:08,339
If you remember, the effect of execute is
either, to make, which means to create new

67
00:06:08,339 --> 00:06:12,779
data
elements, or to delete, or remove.

68
00:06:12,779 --> 00:06:17,279
These are the two principle effects we are
interested in.

69
00:06:17,279 --> 00:06:24,649
Others, like read, print and halt, are immaterial
at this point of view, and then, this is

70
00:06:24,649 --> 00:06:32,508
repeated into a cycle, again and again.

71
00:06:32,509 --> 00:06:38,569
So, we have observed that this brute force
match

72
00:06:38,569 --> 00:06:46,360
has two deficiencies; one there is possible
that different rules may be looking at the

73
00:06:46,360 --> 00:06:50,770
some
of the patterns, they are using, may be shared,

74
00:06:50,769 --> 00:06:51,769
essentially.

75
00:06:51,769 --> 00:06:56,669
So, for the upper, this pattern 1
may be there in many rules; pattern 2 may

76
00:06:56,670 --> 00:06:59,860
be there in many rules, and so on, but here,
we

77
00:06:59,860 --> 00:07:03,830
have listed them as, you know; patterns of
rule 1; patterns of rule 2; patterns of rule

78
00:07:03,829 --> 00:07:05,288
3;
and so on.

79
00:07:05,288 --> 00:07:09,439
So, they are matched multiple number of times.

80
00:07:09,439 --> 00:07:13,350
They may be even shared
partially, as we will see in an example today.

81
00:07:13,350 --> 00:07:18,910
That even, if they are shared partially, we
should be able to minimize the number of matches

82
00:07:18,910 --> 00:07:20,530
that we do.

83
00:07:20,529 --> 00:07:24,829
Remember that these
patterns are made up of class names and attribute

84
00:07:24,829 --> 00:07:25,829
value pairs.

85
00:07:25,829 --> 00:07:31,079
For every attribute, there is
a test condition, which could be equality

86
00:07:31,079 --> 00:07:35,519
that it must match the data, or it must be
something, like greater than a value, or not

87
00:07:35,519 --> 00:07:37,330
equal to a value and things like that.

88
00:07:37,331 --> 00:07:42,979
So, that is one thing that we would like to
do.

89
00:07:42,978 --> 00:07:44,579
The other thing that you would like to do
is

90
00:07:44,579 --> 00:07:53,800
that, because when we, let us say this, some
rule 3 is selected in the resolve phase, and

91
00:07:53,800 --> 00:08:02,050
let us say this rule 3 matches these pieces
of data; let us say 3 pieces of data.

92
00:08:02,050 --> 00:08:12,430
It is
possible that when this rule 3 executes, it

93
00:08:12,430 --> 00:08:14,340
may say, delete this data.

94
00:08:14,339 --> 00:08:20,138
So, let me put a cross
here; delete this data and may be, it might

95
00:08:20,139 --> 00:08:28,360
say, add a new data, or let me use a term;
make here.

96
00:08:28,360 --> 00:08:30,720
So, let us just take this simple example.

97
00:08:30,720 --> 00:08:34,370
We are deleting two elements.

98
00:08:34,370 --> 00:08:39,941
Let us
call these elements, A and B, and you are

99
00:08:39,941 --> 00:08:44,790
adding a third element, which let us call
as C,

100
00:08:44,789 --> 00:08:45,789
essentially.

101
00:08:45,789 --> 00:08:48,120
That is the only change you are making into
a working memory.

102
00:08:48,120 --> 00:08:52,259
Two
elements have been removed and one has been

103
00:08:52,259 --> 00:08:53,480
added.

104
00:08:53,480 --> 00:08:59,050
So, what we expect in such a
situation is that most of the other rules,

105
00:08:59,049 --> 00:09:01,750
which are matching with some data, earlier
in the

106
00:09:01,750 --> 00:09:06,570
last cycle, will continue to match in the
next cycle.

107
00:09:06,570 --> 00:09:12,580
We would like to avoid the trouble of
matching them all over, again.

108
00:09:12,580 --> 00:09:13,580
..

109
00:09:13,580 --> 00:09:21,660
So, these two properties of this particular
match algorithm are done away with by the

110
00:09:21,659 --> 00:09:24,449
algorithm that we are looking at today, and
it is called the Rete algorithm.

111
00:09:24,450 --> 00:09:36,680
It was, as I
mentioned earlier, given by Charles Forgy

112
00:09:36,679 --> 00:09:42,349
in 1979 as a part of his PHD work.

113
00:09:42,350 --> 00:09:46,370
Based on
this, he divides the language called OPS5

114
00:09:46,370 --> 00:09:51,220
which, some people say, stands for Official
Production System Language.

115
00:09:51,220 --> 00:09:56,639
Remember that, we also called rules as productions,
and

116
00:09:56,639 --> 00:09:59,519
all this was happening in CMU at that time.

117
00:09:59,519 --> 00:10:06,169
Today, we want to look at the details of this
algorithm; the Rete algorithm and its structure.

118
00:10:06,169 --> 00:10:12,629
So, let me also rewrite the rules that I
wrote in the last class.

119
00:10:12,629 --> 00:10:18,059
So, remember this card playing rules, we have
said.

120
00:10:18,059 --> 00:10:19,059
.

121
00:10:19,059 --> 00:10:39,239
.This is an OPS5 syntax; something like this.

122
00:10:39,240 --> 00:10:46,060
If you remember, the first element in this
list is the class name of the data structure;

123
00:10:46,059 --> 00:10:48,500
the second element which, with this symbol
is

124
00:10:48,500 --> 00:10:53,730
the attribute name; the third element is the
value of the attribute name, this attribute;

125
00:10:53,730 --> 00:10:57,139
and
you can have multiple attributes and their

126
00:10:57,139 --> 00:10:58,139
values.

127
00:10:58,139 --> 00:11:00,960
When we enclose something in angular
brackets like this that represents a variable,

128
00:11:00,960 --> 00:11:03,139
essentially, which means, it will match
anything.

129
00:11:03,139 --> 00:11:08,129
There are no data types involved here.

130
00:11:08,129 --> 00:11:17,340
Let us say, we also have a working
memory element, which says, who has to play.

131
00:11:17,340 --> 00:11:20,649
So, this one says, it is a turn of some
player P, of course, this is a variable.

132
00:11:20,649 --> 00:11:34,769
So, it could be applied to any player, and
card suit s

133
00:11:34,769 --> 00:11:49,509
name X, and we are saying, in this third pattern
that there is a card, which is also;

134
00:11:49,509 --> 00:11:53,370
whenever, we have same variable name in two
different patterns in the same left hand

135
00:11:53,370 --> 00:11:57,320
side of the rule, they must match identically,
to the same value, essentially.

136
00:11:57,320 --> 00:11:58,778
They cannot
match different values.

137
00:11:58,778 --> 00:12:03,470
So, if there is a card of this group is played,
whose name is X and

138
00:12:03,470 --> 00:12:08,320
is held by player P, then this player can
play this card.

139
00:12:08,320 --> 00:12:12,199
I will not write at the right hand side, because
today, we are only interested in the match

140
00:12:12,198 --> 00:12:13,198
part of the algorithm.

141
00:12:13,198 --> 00:12:20,698
Then, we had written another rule, P highest
card.

142
00:12:20,698 --> 00:12:25,319
So, instead of
playing any card, now, I have a different

143
00:12:25,320 --> 00:12:29,149
rule, which says that you know, in that suit,
play the highest card.

144
00:12:29,149 --> 00:12:34,419
So, this 1 and 2 will be the same; I will
not repeat that here, but

145
00:12:34,419 --> 00:12:40,360
this is 1 and this is 2; it is just for our
sake, but not part of the language syntax.

146
00:12:40,360 --> 00:12:43,990
So,
anyway, let me rub it off from here.

147
00:12:43,990 --> 00:12:50,620
The first was same, the third one is similar
card; it

148
00:12:50,620 --> 00:12:57,860
must be of this suit, s; it must have some
name, because you want to use that name in

149
00:12:57,860 --> 00:13:02,079
the
output, say, play this card, and must be held

150
00:13:02,078 --> 00:13:05,500
by this player, whose turn it is to play,
and

151
00:13:05,500 --> 00:13:16,100
this card has a rank, let us say R. Now, we
are interested in playing the highest card.

152
00:13:16,100 --> 00:13:18,060
So,
we have this extra bit of information in this

153
00:13:18,059 --> 00:13:19,269
particular pattern.

154
00:13:19,269 --> 00:13:24,419
Obviously, notice that
patterns can select any subset of the class

155
00:13:24,419 --> 00:13:31,689
information.

156
00:13:31,690 --> 00:13:49,520
I put this in bracket, just to make it show;
this is the condition that we are looking

157
00:13:49,519 --> 00:13:53,019
at; yes,
and this is the negation sign.

158
00:13:53,019 --> 00:13:57,320
This should be right as saying, the first
two conditions are

159
00:13:57,320 --> 00:14:02,440
the same that the suit being played is s;
it is a turn of player P. Player P has a card

160
00:14:02,440 --> 00:14:06,769
in this
suit s whose, rank is R, and there is no card

161
00:14:06,769 --> 00:14:10,769
held by player P, in this suit s whose, rank
is

162
00:14:10,769 --> 00:14:15,419
smaller than R, which means higher than R;
we assume that.

163
00:14:15,419 --> 00:14:17,958
Then, we will say, play this
card.

164
00:14:17,958 --> 00:14:27,138
So, in both instances, we will play this card
name s of this suit; play this jack of

165
00:14:27,139 --> 00:14:29,700
spade, something like that.

166
00:14:29,700 --> 00:14:38,339
So, let me just give you a third rule.

167
00:14:38,339 --> 00:14:44,060
Those of you are literate,
will recognize as playing a trump card in

168
00:14:44,059 --> 00:14:47,929
a, when you do not have a card like this.

169
00:14:47,929 --> 00:14:48,929
So, the

170
00:14:48,929 --> 00:14:55,269
.first condition is the same; the second condition
is the same; we have a third condition,

171
00:14:55,269 --> 00:15:03,610
which is saying that from trump suit t.

172
00:15:03,610 --> 00:15:08,789
So, those of you have played cards, would
know

173
00:15:08,789 --> 00:15:14,860
that there is something called a trump suit,
and essentially, the effect of calling a suit,

174
00:15:14,860 --> 00:15:17,190
a
trump suit is that its cards are always, higher

175
00:15:17,190 --> 00:15:19,190
than other suit cards.

176
00:15:19,190 --> 00:15:21,710
But they can only be
played, when you do not have the other suit

177
00:15:21,710 --> 00:15:22,710
cards.

178
00:15:22,710 --> 00:15:26,860
Again, we are talking about a card
here.

179
00:15:26,860 --> 00:15:36,720
So, I will not write this name and all, but
what I will write here is that the suit is

180
00:15:36,720 --> 00:15:41,069
trump.

181
00:15:41,068 --> 00:15:47,269
Everything else will be the same that there
is a card, held by player P, whose

182
00:15:47,269 --> 00:15:52,889
name is X, and blank; we are not bothered
about here, but this suit that I am selecting

183
00:15:52,889 --> 00:15:56,079
is
this trump suit T, and not the suit s, which

184
00:15:56,078 --> 00:16:00,019
I have said here.

185
00:16:00,019 --> 00:16:08,549
I can even, to be explicit, I can even say,
instead of writing just T, I can write t not

186
00:16:08,549 --> 00:16:14,750
equal
to s, but it turns out that in this particular

187
00:16:14,750 --> 00:16:16,528
example, that does not really matter; so,
I have

188
00:16:16,528 --> 00:16:20,730
not written it like that, but those are the
kind of things you can write as condition

189
00:16:20,730 --> 00:16:30,430
checks,
essentially, and no card.

190
00:16:30,429 --> 00:16:41,549
So, this is the another root, which says that
if the suit in place s;

191
00:16:41,549 --> 00:16:48,289
if the turn of the player is P, is there;
the trump suit is T, and this player P has

192
00:16:48,289 --> 00:16:52,539
a card of
the trump suit, and he does not have any card

193
00:16:52,539 --> 00:16:55,519
in the suit, which is in play; then we can
play the trump suit.

194
00:16:55,519 --> 00:17:00,250
So, just three different left hand sides that
we are interested in, and

195
00:17:00,250 --> 00:17:02,839
we will see how Rete net handled it.

196
00:17:02,839 --> 00:17:06,640
So, Rete net is the structure, which is maintained
by

197
00:17:06,640 --> 00:17:09,610
the Rete algorithm or Rete algorithm, as some
people call it.

198
00:17:09,609 --> 00:17:17,169
Rete is the latin word,
which actually, means net, essentially.

199
00:17:17,170 --> 00:17:18,170
.

200
00:17:18,170 --> 00:17:26,788
.The Rete net is made up of two layers.

201
00:17:26,788 --> 00:17:30,279
You might think of it as on the network.

202
00:17:30,279 --> 00:17:40,220
On the
top, is a discrimination network, and we will

203
00:17:40,220 --> 00:17:43,720
see what the structure is.

204
00:17:43,720 --> 00:17:56,120
Below, is an
assimilative network.

205
00:17:56,119 --> 00:18:08,969
So, the top part of the network is what some
people called as a

206
00:18:08,970 --> 00:18:13,289
mainly sorted, decision key or discriminative
network.

207
00:18:13,289 --> 00:18:15,940
The bottom part collects together;
this is updated.

208
00:18:15,940 --> 00:18:20,670
So, what do you mean by assimilative; that
for every rule, I need a set of

209
00:18:20,670 --> 00:18:28,210
patterns to match, and the bottom parts will
see that it gets those three patterns matched,

210
00:18:28,210 --> 00:18:29,210
essentially.

211
00:18:29,210 --> 00:18:30,299
How does this work?

212
00:18:30,299 --> 00:18:37,299
This basically, works by inserting at the
top, these three

213
00:18:37,299 --> 00:18:38,299
tokens.

214
00:18:38,299 --> 00:18:42,710
So, when you say you want to delete this working
memory element, we generate

215
00:18:42,710 --> 00:18:49,190
a token; let us say we call it minus a; minus
stands for the factor we want to deleting

216
00:18:49,190 --> 00:18:55,130
it,
and one for this token b, which is minus b,

217
00:18:55,130 --> 00:19:00,430
and one for this token c, which is plus c.

218
00:19:00,430 --> 00:19:08,410
So, as the algorithm is progressing, every
time it fires the rule, it will generate some

219
00:19:08,410 --> 00:19:10,380
positive tokens and some negative tokens.

220
00:19:10,380 --> 00:19:17,680
Those tokens would be inserted here, at the
top of the network, which is, as I said in

221
00:19:17,680 --> 00:19:25,420
the last class, changes in the working memory.

222
00:19:25,420 --> 00:19:29,300
These tokens capture what has changed in the
working memory; which things have been

223
00:19:29,299 --> 00:19:32,819
removed from the working memory; what things
have been added to the working

224
00:19:32,819 --> 00:19:33,819
memory.

225
00:19:33,819 --> 00:19:39,259
What the Rete algorithm does is that takes
changes into working memory and

226
00:19:39,259 --> 00:19:47,240
produces changes in a complete set.

227
00:19:47,240 --> 00:19:59,309
So, here, are the different rules R1, R2,
Rk; so, the

228
00:19:59,309 --> 00:20:04,759
network, which you will see in a little bit
more detailed in a moment, is a compilation

229
00:20:04,759 --> 00:20:06,099
of
the rules, essentially.

230
00:20:06,099 --> 00:20:12,089
This network is defined by the rules that
we have in the system, and

231
00:20:12,089 --> 00:20:17,819
it is basically, a different representation
of the same rules in a network form.

232
00:20:17,819 --> 00:20:24,099
The
working memory, this part, sits in locations,

233
00:20:24,099 --> 00:20:26,929
which are nodes in this network, as we will
see in detail.

234
00:20:26,930 --> 00:20:31,060
So, the working memories, kind of, distributed
over this network, and you

235
00:20:31,059 --> 00:20:35,940
can imagine that tokens are flowing from top
to down, just like you would do, for

236
00:20:35,940 --> 00:20:39,700
example, in the very simple case of binary
search key; you want to find out, whether

237
00:20:39,700 --> 00:20:42,630
there is a record whose, key value is 17.

238
00:20:42,630 --> 00:20:47,690
You will put it at the top, and you will check,
whether that root node is greater than 17

239
00:20:47,690 --> 00:20:49,799
or less than 17, and it will send it down
one

240
00:20:49,799 --> 00:20:50,799
branch.

241
00:20:50,799 --> 00:20:52,369
You will keep doing that.

242
00:20:52,369 --> 00:20:54,609
Eventually, it will filter down to the node,
whose value

243
00:20:54,609 --> 00:20:56,009
is 17.

244
00:20:56,009 --> 00:21:01,819
In our case, also we are looking for tokens
with, of a specific kind, but what we are

245
00:21:01,819 --> 00:21:04,939
looking for, tokens with match our rules,
essentially.

246
00:21:04,940 --> 00:21:10,259
So, our tokens will follow down this path,
and for example, in the first two, we need

247
00:21:10,259 --> 00:21:11,259
three tokens.

248
00:21:11,259 --> 00:21:18,470
So, three different tokens, if they come there,
this part is only to make the

249
00:21:18,470 --> 00:21:21,640
search efficient, just like in a search tree.

250
00:21:21,640 --> 00:21:23,280
This part is to collect together, the different

251
00:21:23,279 --> 00:21:25,049
.pattern set or rule need.

252
00:21:25,049 --> 00:21:30,079
So, if you can somehow, collect three tokens
for this tool one,

253
00:21:30,079 --> 00:21:33,289
and the three tokens arrive here, then we
will say rule one is matching.

254
00:21:33,289 --> 00:21:36,180
Once it is
matching, and as long as these tokens are

255
00:21:36,180 --> 00:21:38,400
sitting there, it will continue to match,
essentially.

256
00:21:38,400 --> 00:21:42,220
Only, when we make these changes, if something
happens, then it may go

257
00:21:42,220 --> 00:21:45,839
out of the conflict set or something like
that.

258
00:21:45,839 --> 00:21:51,970
So, these rules, this gives us the conflict
set, here somewhere.

259
00:21:51,970 --> 00:21:59,140
Remember, conflict set is
a collection of instances of these rules.

260
00:21:59,140 --> 00:22:01,080
Each rule may have more than one instance
with

261
00:22:01,079 --> 00:22:03,769
different pieces of data.

262
00:22:03,769 --> 00:22:08,549
Collection of instance of this rule, along
with the identifiers of

263
00:22:08,549 --> 00:22:12,079
the data elements; they are matching, which
is the time stamps that we use here.

264
00:22:12,079 --> 00:22:13,279
So,
these are the identifiers.

265
00:22:13,279 --> 00:22:17,700
They basically, tell you when this token meet
was.

266
00:22:17,700 --> 00:22:20,950
So, to start
with, you can imagine that whatever the data

267
00:22:20,950 --> 00:22:24,370
that you have, you just put the whole thing
into the net.

268
00:22:24,369 --> 00:22:28,469
Instead of just having a few changes, the
whole working that is a starting

269
00:22:28,470 --> 00:22:32,569
point, and it will go and figure out different
set of rules; you will get the conflict set.

270
00:22:32,569 --> 00:22:37,299
Then, the resolve face will select one of
those rules in the conflict set; execute that;

271
00:22:37,299 --> 00:22:39,619
generate a few tokens like this.

272
00:22:39,619 --> 00:22:42,799
Those few tokens would be put in here, and
they will

273
00:22:42,799 --> 00:22:47,039
again, tickle down this network, and make
some changes on the way, but otherwise, the

274
00:22:47,039 --> 00:22:51,869
rest of the match is, sort of, static in these
networks.

275
00:22:51,869 --> 00:22:56,459
So, let us see what this network
looks like.

276
00:22:56,460 --> 00:23:02,860
As I said, the top part is discriminative
in nature, which tries to separate

277
00:23:02,859 --> 00:23:04,250
tokens of different kinds.

278
00:23:04,250 --> 00:23:06,089
So, that you do not have to do a sequential
match.

279
00:23:06,089 --> 00:23:10,369
That is a
basic idea in many of these search algorithms.

280
00:23:10,369 --> 00:23:13,339
The first thing, we test for, is a class
name.

281
00:23:13,339 --> 00:23:19,549
So, we have one class name here, suit.

282
00:23:19,549 --> 00:23:20,549
..

283
00:23:20,549 --> 00:23:30,119
So, let us say this 
is the root and there is a node; first nodes

284
00:23:30,119 --> 00:23:35,899
are called alpha nodes.

285
00:23:35,900 --> 00:23:42,920
Just
some nomenclature; nothing to do with the

286
00:23:42,920 --> 00:23:46,400
game playing algorithm that we have been
looking at.

287
00:23:46,400 --> 00:23:54,320
And what alpha nodes do is that they have
exactly, one parent and they do a

288
00:23:54,319 --> 00:23:57,919
certain test, and the test is what we are
writing in the box, and in the first level,

289
00:23:57,920 --> 00:24:04,220
it is a
class name; that the class name is suit here.

290
00:24:04,220 --> 00:24:11,950
They may have more than one child,
depending on what the rules are saying.

291
00:24:11,950 --> 00:24:16,960
For example, here, we have for the card, some
different rules.

292
00:24:16,960 --> 00:24:25,299
So, you may have more children, essentially.

293
00:24:25,299 --> 00:24:32,329
So, the second one is for
some attribute from the class name.

294
00:24:32,329 --> 00:24:38,669
Now, in our case, the attribute is played
and our

295
00:24:38,670 --> 00:24:40,140
value is only a variable.

296
00:24:40,140 --> 00:24:43,400
So, we do not really have much, but you can
imagine that if we

297
00:24:43,400 --> 00:24:48,820
had one rule for spades, and another rule
for hearts, then you would have one branch

298
00:24:48,819 --> 00:24:51,029
for
spades here, and another branch for hearts

299
00:24:51,029 --> 00:24:53,079
here, and this test would be more specific.

300
00:24:53,079 --> 00:24:57,960
You could say if the suit being played is
spades or the suit being played is hearts,

301
00:24:57,960 --> 00:25:00,380
then
the rest of the network would be different.

302
00:25:00,380 --> 00:25:01,800
In our example we have only a variable.

303
00:25:01,799 --> 00:25:02,799
So, it does not matter.

304
00:25:02,799 --> 00:25:05,279
We have only one.

305
00:25:05,279 --> 00:25:09,200
Then,
let us finish up the easier path first, which

306
00:25:09,200 --> 00:25:13,779
is the second last name, which is turn, and
it

307
00:25:13,779 --> 00:25:19,389
has also, only one value; see, in all the
rules, we have only one value; turn of P;

308
00:25:19,390 --> 00:25:23,770
turn of
P. Again, you can imagine if we discriminated

309
00:25:23,769 --> 00:25:28,289
between the different players, if we said
turn of south, or turn of north, or turn of

310
00:25:28,289 --> 00:25:30,730
east; where, north, east, south, west are
the

311
00:25:30,730 --> 00:25:34,750
names of the place, then we would have different
branches coming out of here.

312
00:25:34,750 --> 00:25:44,660
So, again,
we have only one branch, because there is

313
00:25:44,660 --> 00:25:48,080
only one pattern of this kind.

314
00:25:48,079 --> 00:25:50,859
Every path in

315
00:25:50,859 --> 00:25:53,500
.this represents a pattern.

316
00:25:53,500 --> 00:25:56,000
If we have different patterns, which are slightly
different, then

317
00:25:56,000 --> 00:26:01,619
they will diverge, you know; one pattern will
go this way, and another pattern will go

318
00:26:01,619 --> 00:26:02,619
that way.

319
00:26:02,619 --> 00:26:05,399
So, it is like a structure, which is similar
to the Trie structure; I do not know if

320
00:26:05,400 --> 00:26:09,900
you have studied the Trie structure.

321
00:26:09,900 --> 00:26:12,210
It is a little bit like that, essentially.

322
00:26:12,210 --> 00:26:16,040
So, all these are alpha nodes.

323
00:26:16,040 --> 00:26:24,629
Alpha nodes have one
parent, and every node has a memory, associated

324
00:26:24,630 --> 00:26:27,500
with it in which, tokens can sit,
essentially.

325
00:26:27,500 --> 00:26:31,450
So, let us assume that memories, behind it,
and we cannot see properly.

326
00:26:31,450 --> 00:26:36,690
Then, other kinds of nodes are beta nodes.

327
00:26:36,690 --> 00:26:42,410
I will draw the beta notes with the circle,
and

328
00:26:42,410 --> 00:26:48,769
what they do is; pull together, tokens from
different patterns; tokens, which are of

329
00:26:48,769 --> 00:26:50,450
different patterns, essentially.

330
00:26:50,450 --> 00:26:53,080
In our example, there is no test to be done.

331
00:26:53,079 --> 00:26:56,159
These are kind
of independent and all we are saying is that

332
00:26:56,160 --> 00:26:58,790
we should have one token of this kind, and
one token of this kind.

333
00:26:58,789 --> 00:27:01,629
Then, we have these two patterns, at least.

334
00:27:01,630 --> 00:27:04,720
Our first tool needs
three patterns; we have collected two.

335
00:27:04,720 --> 00:27:06,710
So, these are beta nodes.

336
00:27:06,710 --> 00:27:12,460
Beta nodes may have or
in the implementation that we have described

337
00:27:12,460 --> 00:27:14,019
here, have exactly two parents.

338
00:27:14,019 --> 00:27:19,829
We can
have more than two, but let us assume that

339
00:27:19,829 --> 00:27:22,559
this is like a joint of two structures.

340
00:27:22,559 --> 00:27:27,980
We are
only joining two patterns at a time, essentially.

341
00:27:27,980 --> 00:27:31,259
So, if we have three patterns, then we will
first join two, and then, the third one, and

342
00:27:31,259 --> 00:27:32,879
so on.

343
00:27:32,880 --> 00:27:40,730
Beta node also, may do a test as you will
see in the moment.

344
00:27:40,730 --> 00:27:48,549
So, let me do this rough rule first, at this
end.

345
00:27:48,549 --> 00:27:53,769
Obviously, one thing
we need is card, because that is one of our

346
00:27:53,769 --> 00:28:01,230
class names, and the last one that we need
is

347
00:28:01,230 --> 00:28:06,099
trump.

348
00:28:06,099 --> 00:28:15,259
It has one attribute called suit, and it has
the value called t.

349
00:28:15,259 --> 00:28:21,029
So, this last rule needs
five patterns; one and two, which we have

350
00:28:21,029 --> 00:28:22,029
here.

351
00:28:22,029 --> 00:28:26,579
Then, one pattern will come down this
path, which is that trump path, and then,

352
00:28:26,579 --> 00:28:28,699
two patterns will go down this path.

353
00:28:28,700 --> 00:28:33,819
So, two
patterns are talking about cards, essentially.

354
00:28:33,819 --> 00:28:45,899
So, one of them says that player; I have not
written that there, but it is a part of that

355
00:28:45,900 --> 00:28:54,290
pattern, and this P must match this P, as
you will see.

356
00:28:54,289 --> 00:29:00,099
So, card player P suit t.

357
00:29:00,099 --> 00:29:06,269
So, all we
are saying now is that if this player has

358
00:29:06,269 --> 00:29:12,690
a card of this suit t, then he is allowed
to play.

359
00:29:12,690 --> 00:29:20,400
So, we joined together, these two patterns
by a beta node, and we put a condition that

360
00:29:20,400 --> 00:29:26,420
this t, which is coming from this side, and
this t, which is coming from this side, equal

361
00:29:26,420 --> 00:29:27,420
to.

362
00:29:27,420 --> 00:29:32,080
So, we are using the equality condition, because
we are just identifying that; see the

363
00:29:32,079 --> 00:29:36,129
variable names I have used the same, but they
do not have be the same.

364
00:29:36,130 --> 00:29:43,580
There could have
been different variable names, but this test

365
00:29:43,579 --> 00:29:50,740
is saying that in this case, it is the same.

366
00:29:50,740 --> 00:29:56,440
So,
let us see.

367
00:29:56,440 --> 00:30:03,980
.Let us say I use this variable s here, and
then, I will have to say this s equal to t,

368
00:30:03,980 --> 00:30:09,569
or let me
just keep to simple thing; see, this is t.

369
00:30:09,569 --> 00:30:12,649
We will look at the other one in a moment.

370
00:30:12,650 --> 00:30:16,530
So, it
has got four, but four these things, but it

371
00:30:16,529 --> 00:30:21,869
still needs one pattern, which says that it
does

372
00:30:21,869 --> 00:30:32,329
not have a card of this suit s.

373
00:30:32,329 --> 00:30:40,109
Now, we want to do a match, which says that
he does not

374
00:30:40,109 --> 00:30:45,339
have, or such a data element, does not exist.

375
00:30:45,339 --> 00:30:47,970
Now, that can be done in a various number
of ways.

376
00:30:47,970 --> 00:30:55,370
Remember that we said that every node is associated
with a memory,

377
00:30:55,369 --> 00:30:56,369
essentially.

378
00:30:56,369 --> 00:31:01,129
Now, I will just use some symbol, which I
will claim is a symbol for

379
00:31:01,130 --> 00:31:10,310
negation.

380
00:31:10,309 --> 00:31:16,049
The way to read this is that the token will
flow down this path, only if the

381
00:31:16,049 --> 00:31:21,529
count; now, this is a bit weird; only the
count of the number of tokens, passing down

382
00:31:21,529 --> 00:31:24,319
this
path, with this value P and with this value

383
00:31:24,319 --> 00:31:26,509
S, is 0, essentially.

384
00:31:26,509 --> 00:31:32,879
So, you must have; I am
just trying to use the simple way of talking

385
00:31:32,880 --> 00:31:33,880
about it, essentially.

386
00:31:33,880 --> 00:31:37,290
What you want to really
say is that if a token of this kind want to

387
00:31:37,289 --> 00:31:39,889
actually, come here, then its effect on the
rule

388
00:31:39,890 --> 00:31:43,060
will be that it will not match, essentially.

389
00:31:43,059 --> 00:31:44,659
You can think of it like that.

390
00:31:44,660 --> 00:31:47,519
You can think of it
as saying that the count of the number of

391
00:31:47,519 --> 00:31:48,519
tokens.

392
00:31:48,519 --> 00:31:50,269
What are these tokens?

393
00:31:50,269 --> 00:31:54,049
This is the
pattern, which says that is the card held

394
00:31:54,049 --> 00:31:57,960
by player P of suit S. Now, if the player
had

395
00:31:57,960 --> 00:32:01,410
three cards of this suit; let us say we are
talking about spades.

396
00:32:01,410 --> 00:32:05,200
If the player had three cards of spades, then
three tokens would come down here,

397
00:32:05,200 --> 00:32:08,259
essentially, because that should be in the
working memory.

398
00:32:08,259 --> 00:32:11,869
What this test is doing is
counting, how many tokens are coming here,

399
00:32:11,869 --> 00:32:13,779
and if the tokens is greater than 0, then
it

400
00:32:13,779 --> 00:32:20,930
will say, no, this rule cannot fire.

401
00:32:20,930 --> 00:32:24,130
The other way to look at is that if a token
wants to

402
00:32:24,130 --> 00:32:28,990
come here, then it will immediately, disable
the rule to which, it is pointing to.

403
00:32:28,990 --> 00:32:38,880
So, in any
case, we need a joint here, and the joint

404
00:32:38,880 --> 00:32:42,510
should say that this S is the same as this
S; so, S

405
00:32:42,509 --> 00:32:53,640
equal to S. I will just write, and this P
is the same as this P. So, by this moment,

406
00:32:53,640 --> 00:32:56,150
we have
looked at three patterns.

407
00:32:56,150 --> 00:32:59,690
There are two positive patterns and one negative
pattern.

408
00:32:59,690 --> 00:33:01,420
In that
branch, we have looked at two patterns; both

409
00:33:01,420 --> 00:33:02,600
of them are positive patterns.

410
00:33:02,599 --> 00:33:08,259
If all the five
patterns match, which means, the appropriate

411
00:33:08,259 --> 00:33:14,109
tokens come down here, then we can join
them together, and we have to be careful here.

412
00:33:14,109 --> 00:33:23,659
So, P is equal to P, for example, and that
is the only thing, you have to worry about,

413
00:33:23,660 --> 00:33:28,440
and here is a rule called ruff.

414
00:33:28,440 --> 00:33:40,490
So far, we have drawn the network for only
one rule, which is the third rule.

415
00:33:40,490 --> 00:33:43,000
The third
rule has five patterns; this one and two are

416
00:33:43,000 --> 00:33:45,819
same as this; that the suit will play is that
the

417
00:33:45,819 --> 00:33:49,069
turn of player P. The third one says that
the trump suit is t.

418
00:33:49,069 --> 00:33:52,029
The fourth one says that
player has a card of t, and the fifth one

419
00:33:52,029 --> 00:33:55,230
says that the player has no cards of the suit,
which

420
00:33:55,230 --> 00:33:57,309
.is being played S, essentially.

421
00:33:57,309 --> 00:34:00,409
So, this snow card is captured here, because
of this

422
00:34:00,410 --> 00:34:01,980
symbol.

423
00:34:01,980 --> 00:34:08,648
This captures the first two patterns, and
this is the third pattern, which is the trump

424
00:34:08,648 --> 00:34:11,019
suit,
which defines a trump suit.

425
00:34:11,019 --> 00:34:13,280
This is the fourth pattern, which says that
the player has a

426
00:34:13,280 --> 00:34:18,110
card of this trump suit, because T equal to
T, and here, all the five patterns will come

427
00:34:18,110 --> 00:34:20,149
and
sit here, and we will say, this rule is now,

428
00:34:20,148 --> 00:34:22,710
gone to the conflict set.

429
00:34:22,710 --> 00:34:29,970
Let us take the first
tool, which is the simple rule.

430
00:34:29,969 --> 00:34:35,388
All it says is there is a card of suit S,
name X, player P. So,

431
00:34:35,389 --> 00:34:46,280
I could simply say it here.

432
00:34:46,280 --> 00:34:52,300
I could say here, I need one more thing which
is named.

433
00:34:52,300 --> 00:35:00,000
So, if
a pattern wants to come down this path, it

434
00:35:00,000 --> 00:35:02,409
would say that it is the card held by player
P

435
00:35:02,409 --> 00:35:08,699
variable P, some suit, which is a variable
S, and some name, which is variable X, and

436
00:35:08,699 --> 00:35:16,549
I
can join it with this, and put all the conditions;

437
00:35:16,550 --> 00:35:20,390
that S equal to S, which means S coming
from this side, is the same as the S coming

438
00:35:20,389 --> 00:35:26,989
from this side, likewise, for the P coming
from this side, P equal to P and I would have

439
00:35:26,989 --> 00:35:32,750
that any card.

440
00:35:32,750 --> 00:35:44,539
Now, you can observe that the only thing I
did at this moment, for the rule number one

441
00:35:44,539 --> 00:35:47,769
was to add this box here, and this beta node
here.

442
00:35:47,769 --> 00:35:53,090
This is the alpha node and this is the
beta node, and nothing else, I have to do.

443
00:35:53,090 --> 00:35:58,190
The rest of the match, it is the first pattern;
the

444
00:35:58,190 --> 00:36:02,720
suit being played is S; the second pattern,
the turn of player P is already there, in

445
00:36:02,719 --> 00:36:03,719
the
network.

446
00:36:03,719 --> 00:36:08,629
I have to just take a lead from there, and
I have already joined them together.

447
00:36:08,630 --> 00:36:12,809
Then, take this third token from here, and
at this point, I have three tokens coming

448
00:36:12,809 --> 00:36:23,489
together, which is what I need from a first
rule, essentially.

449
00:36:23,489 --> 00:36:34,089
So, this intra cycle savings,
so to speak, that in the same cycle, I am

450
00:36:34,090 --> 00:36:39,559
matching this rule and this rule, but I am
sharing

451
00:36:39,559 --> 00:36:43,019
in this network; the matching work, which
is required for those rules.

452
00:36:43,019 --> 00:36:47,150
Only, some things
are different, which I do separately, essentially.

453
00:36:47,150 --> 00:36:52,090
You can take the middle rule, as you can
see, it always takes something from here,

454
00:36:52,090 --> 00:36:56,640
and it needs a card of suit S name X player
P

455
00:36:56,639 --> 00:36:57,639
rank Y.

456
00:36:57,639 --> 00:37:01,940
So, we can take this from here.

457
00:37:01,940 --> 00:37:04,740
Let me use a different color.

458
00:37:04,739 --> 00:37:13,829
So, we can take this
from here, and add another alpha node of rank

459
00:37:13,829 --> 00:37:28,739
R. I can take still, one more from here,
and add another alpha node, which you will

460
00:37:28,739 --> 00:37:32,159
say, rank less than R. Remember, R is still
a

461
00:37:32,159 --> 00:37:34,339
variable at this point of time.

462
00:37:34,340 --> 00:37:40,210
Then, I can combine them by saying this R
equal to R. So,

463
00:37:40,210 --> 00:37:42,699
what is happening in, if you can see this
purple part?

464
00:37:42,699 --> 00:37:48,679
We are talking about two tokens
flowing down this path up to here.

465
00:37:48,679 --> 00:37:55,219
Actually, we do not need this name, sorry.

466
00:37:55,219 --> 00:38:01,039
So, this
should actually, come from here.

467
00:38:01,039 --> 00:38:16,789
.The card held by player of suit S, whose
name is X, and whose name is R, and somebody

468
00:38:16,789 --> 00:38:19,059
should have pointed this out.

469
00:38:19,059 --> 00:38:26,820
I need this negation node here.

470
00:38:26,820 --> 00:38:35,880
So, in this rule, the third
pattern is flowing from here; card held by

471
00:38:35,880 --> 00:38:43,599
player P suit S name X rank R, and its coming
here.

472
00:38:43,599 --> 00:38:49,460
The fourth pattern is coming from here; card
held by player P suit X, then it is

473
00:38:49,460 --> 00:38:54,840
coming here, whose rank is less than R, but
then, there is a negation here, which means

474
00:38:54,840 --> 00:39:02,640
the player does not have a card of higher
rank, and this I can combine with this.

475
00:39:02,639 --> 00:39:10,940
With all that P equal to P, and S equal to
S, and I will get the second rule, which is

476
00:39:10,940 --> 00:39:22,570
highest card.

477
00:39:22,570 --> 00:39:25,950
In this network, see, we started off by creating
network for the third rule.

478
00:39:25,949 --> 00:39:33,089
Then, we added few more edges and nodes for
the first rule, and then, a few more edges,

479
00:39:33,090 --> 00:39:34,430
missing for the third rule.

480
00:39:34,429 --> 00:39:40,489
So, notice that there is only one branch going
down for the

481
00:39:40,489 --> 00:39:46,039
cards being held by players, which means that
every card that every player holds, a token

482
00:39:46,039 --> 00:39:48,779
will go down this branch.

483
00:39:48,780 --> 00:39:53,300
The same token, if you look at this structure
here, all you are

484
00:39:53,300 --> 00:39:58,350
saying is that it is of suit S, and this is
of suit T where, S and T are variables.

485
00:39:58,349 --> 00:40:01,079
So,
obviously, every card, let us say it is spades.

486
00:40:01,079 --> 00:40:09,119
So, if there is a spade card held by this
player P, the token will come here, as well

487
00:40:09,119 --> 00:40:14,980
as, it will also go here, but only if it matches
this, it will match this rule number four;

488
00:40:14,980 --> 00:40:23,099
otherwise, it will not match this rule number
four, and only if this matches this suit,

489
00:40:23,099 --> 00:40:26,259
which is in play, will the player played this
card,

490
00:40:26,260 --> 00:40:31,120
essentially
The Rete network is a network, which is a

491
00:40:31,119 --> 00:40:32,119
compilation of the rules.

492
00:40:32,119 --> 00:40:35,150
So, if you have this
network, then you do not need the rules, essentially,

493
00:40:35,150 --> 00:40:41,820
because it is just a different way of
writing these rules.

494
00:40:41,820 --> 00:40:50,130
The task of the software engineer here, is
to be able to view the set of

495
00:40:50,130 --> 00:40:55,559
rules, and construct a latter network corresponding
to this, essentially.

496
00:40:55,559 --> 00:40:59,909
That is the first
part, building the network or compiling the

497
00:40:59,909 --> 00:41:06,509
program, as you might say, and then, you put
in all the data from the top.

498
00:41:06,510 --> 00:41:11,430
This act like a discrimination network, if
the token working

499
00:41:11,429 --> 00:41:14,789
on the element is of class name, card; it
will follow this path.

500
00:41:14,789 --> 00:41:18,230
If it is of class name,
trump; it will follow that path, and that

501
00:41:18,231 --> 00:41:21,850
each stage, it is a test; that it has to satisfy;
call it

502
00:41:21,849 --> 00:41:23,139
to move on.

503
00:41:23,139 --> 00:41:29,230
This one says that the effect is opposite,
that if such a token exist, and this

504
00:41:29,230 --> 00:41:31,860
rule will not fire.

505
00:41:31,860 --> 00:41:34,900
If there is no such token coming here, then
this rule will fire,

506
00:41:34,900 --> 00:41:35,900
essentially.

507
00:41:35,900 --> 00:41:41,079
So, obviously, you can see that this needs
four tokens; four positive tokens, and one

508
00:41:41,079 --> 00:41:44,659
negative pattern, which stands for the fact
that they must be no such token.

509
00:41:44,659 --> 00:41:50,179
So, if a token
comes down this path, that rule will get disabled.

510
00:41:50,179 --> 00:41:52,899
Now, we can also understand what is

511
00:41:52,900 --> 00:41:54,250
.going to happen in this cycle here.

512
00:41:54,250 --> 00:41:59,250
Whenever, we execute a rule, we add these
new

513
00:41:59,250 --> 00:42:06,530
tokens, and put them down the network; sort
of, we push them from here, and they will

514
00:42:06,530 --> 00:42:07,530
travel some down.

515
00:42:07,530 --> 00:42:08,530
.

516
00:42:08,530 --> 00:42:14,060
So, it is possible that we have created, only
these three; let us say these two tokens,

517
00:42:14,059 --> 00:42:20,818
and
this tokens come in later, or let us say we

518
00:42:20,818 --> 00:42:24,639
have these four tokens, and in the last; and
let

519
00:42:24,639 --> 00:42:31,579
us say that the suit being played is spades,
and in the last round, if the program played

520
00:42:31,579 --> 00:42:34,000
a
spade, then we will have a negative token

521
00:42:34,000 --> 00:42:35,940
of saying that that card has been played by
the

522
00:42:35,940 --> 00:42:39,950
suit, and if that player had only one card
of the suit, there is the negative token,

523
00:42:39,949 --> 00:42:40,949
will
come here.

524
00:42:40,949 --> 00:42:46,359
It will cancel the positive token, which was
sitting earlier, and then, this rule

525
00:42:46,360 --> 00:42:50,380
will certainly, come into the conflict set.

526
00:42:50,380 --> 00:42:54,650
Essentially, the effect of throwing these
tokens

527
00:42:54,650 --> 00:43:04,240
down, this network is to either, activate
some new rules or to deactivate some existing

528
00:43:04,239 --> 00:43:23,519
rules, essentially.

529
00:43:23,519 --> 00:43:25,590
Any questions at this point?

530
00:43:25,590 --> 00:43:34,680
So, I will expect that if I give you a set
of rules of some

531
00:43:34,679 --> 00:43:42,019
domain like I define, you can look at some
past papers, for example, you should be able

532
00:43:42,019 --> 00:43:44,849
to construct the network, and show, where
the tokens are.

533
00:43:44,849 --> 00:43:46,730
Of course, here, we have not
created the tokens.

534
00:43:46,730 --> 00:43:53,860
So, we do not know where the tokens will sit,
and here, every test is a

535
00:43:53,860 --> 00:43:55,269
very variable kind of a test.

536
00:43:55,269 --> 00:43:58,739
So, it will not stop tokens here, but supposing,
this was

537
00:43:58,739 --> 00:44:02,299
played spades; let us say this rule was only
for spades.

538
00:44:02,300 --> 00:44:09,220
So, if I had spades here, then if a
token with hearts or diamonds or clubs come,

539
00:44:09,219 --> 00:44:10,289
it will just sit here.

540
00:44:10,289 --> 00:44:12,880
It will never be able to

541
00:44:12,880 --> 00:44:17,220
.reach this place, because there is no rule
to tackle those kinds of processes, essentially.

542
00:44:17,219 --> 00:44:23,299
So, we should able to say where the tokens
are sitting, essentially.

543
00:44:23,300 --> 00:44:31,310
So, as the last bit, we
started off by saying that this whole idea

544
00:44:31,309 --> 00:44:39,119
of rule based systems was motivated by a
cognitive approach to problem solving.

545
00:44:39,119 --> 00:44:40,119
.

546
00:44:40,119 --> 00:44:46,990
We are also said that the rules, for example,
are the long term memory of the problem

547
00:44:46,989 --> 00:44:51,349
solver, because that is the knowledge, which
is acquired over a period of time, whereas,

548
00:44:51,349 --> 00:44:56,549
this working memory elements are the short
term memory of the problem solver, because

549
00:44:56,550 --> 00:44:59,769
that is the data that the problem solver is
interacting with.

550
00:44:59,769 --> 00:45:03,019
There are cognitive models of
the brain, which says that this is where,

551
00:45:03,019 --> 00:45:06,059
you store short term data, and this is where,
you

552
00:45:06,059 --> 00:45:07,130
store long term data.

553
00:45:07,130 --> 00:45:12,710
So, in some sense, this is the model for doing
this kind of reasoning.

554
00:45:12,710 --> 00:45:15,820
There are variations of this, we can think
of.

555
00:45:15,820 --> 00:45:21,530
For example, you can think of a language in
which, you can create rules on the fly, essentially.

556
00:45:21,530 --> 00:45:24,150
That would be difficult to handle in
this, because here, the network that we have

557
00:45:24,150 --> 00:45:28,079
described is a static network, and we have
said it is a compilation of the rule that

558
00:45:28,079 --> 00:45:32,319
we have; how do we handle a situation where,
the

559
00:45:32,320 --> 00:45:37,740
rules can be themselves, added or deleted
from a knowledge base?

560
00:45:37,739 --> 00:45:38,739
..

561
00:45:38,739 --> 00:45:48,019
Finally, I should add that you should look
up system called Soar, which is a successor

562
00:45:48,019 --> 00:45:52,670
of
this language, which amongst, apart from this

563
00:45:52,670 --> 00:46:00,769
whole idea of using a Rete network; the
Rete network has become like a fixture in

564
00:46:00,769 --> 00:46:04,360
all these business, I said, last time we have
mentioned that.

565
00:46:04,360 --> 00:46:08,110
You know this Rule Business Management System
or Business Rule

566
00:46:08,110 --> 00:46:11,390
Management System; BRMS.

567
00:46:11,389 --> 00:46:18,059
So, there is lots of software, which is commercially
available for managing business.

568
00:46:18,059 --> 00:46:23,239
Rete networks or its improvements; I also
said that 4G

569
00:46:23,239 --> 00:46:29,599
created a newer version of Rete network, which
is called Rete NT, which is 500 times

570
00:46:29,599 --> 00:46:36,130
faster than this network that we have just
described, but unfortunately, we do not have

571
00:46:36,130 --> 00:46:40,900
descriptions of that network, because it is
a trade secret, and it has not been revealed,

572
00:46:40,900 --> 00:46:42,289
but
they have been several improvements, in terms

573
00:46:42,289 --> 00:46:45,440
of speed, that have been made to the Rete
network.

574
00:46:45,440 --> 00:46:50,289
It is a big part of business rule, in general,
essentially.

575
00:46:50,289 --> 00:46:55,309
This Soar, on the other
hand, was continued in the university environment,

576
00:46:55,309 --> 00:47:04,549
again CMU, by a guy called John
Laird.

577
00:47:04,550 --> 00:47:09,960
So, if you look up John Laird or if you look
up Soar, you would get more information

578
00:47:09,960 --> 00:47:10,960
out of it.

579
00:47:10,960 --> 00:47:16,010
John Laird also made an observation about
four or five years ago.

580
00:47:16,010 --> 00:47:20,600
He said that
we all know that the computing industry is

581
00:47:20,599 --> 00:47:22,179
virtually driven by games, essentially.

582
00:47:22,179 --> 00:47:25,089
I mean,
most of the faster processors, for example,

583
00:47:25,090 --> 00:47:32,860
are developed, because people want faster
games; you should be able to do things faster.

584
00:47:32,860 --> 00:47:38,760
But what John Laird observed was that
games, or at least, the graphic capabilities

585
00:47:38,760 --> 00:47:44,280
of games, you know the ability to render
scenes, which are realistic, and ability to

586
00:47:44,280 --> 00:47:46,619
have characters moving around, which look
like

587
00:47:46,619 --> 00:47:49,960
.realistic characters, has kind of saturated;
that there is not much improvement you can

588
00:47:49,960 --> 00:47:52,449
do
on that front, essentially.

589
00:47:52,449 --> 00:47:56,439
What he says is that the next level of improvement
in games

590
00:47:56,440 --> 00:48:01,179
will be in giving a quote unquote; intelligence
to the characters.

591
00:48:01,179 --> 00:48:06,269
So, whatever, avatar or
whatever, characters we have in game; if they

592
00:48:06,269 --> 00:48:09,721
are intelligent, which means if they have
some knowledge of some kind, and they can

593
00:48:09,721 --> 00:48:13,630
do some useful, what you may call,
thinking; then, that is going to be the next

594
00:48:13,630 --> 00:48:16,920
level of interesting list in game, essentially.

595
00:48:16,920 --> 00:48:20,970
He
is the same guy, who is maintaining this Soar

596
00:48:20,969 --> 00:48:21,969
architecture.

597
00:48:21,969 --> 00:48:27,019
So, those of you are interested in games;
I am sure, most of you are; I would encourage

598
00:48:27,019 --> 00:48:31,420
you to look at Soar, and if you want to build
a game, which has intelligent characters

599
00:48:31,420 --> 00:48:35,289
inside it, then this is a mechanism; this
is a language, which allows you to; which

600
00:48:35,289 --> 00:48:37,980
is a
kind of decedent of OPS5, which allows you

601
00:48:37,980 --> 00:48:44,400
to express what kind of knowledge that you
want put into to an agent, inside a game.

602
00:48:44,400 --> 00:48:48,650
So, we will stop here with this.

603
00:48:48,650 --> 00:48:50,780
In the next class, I want to move to a different
topic,

604
00:48:50,780 --> 00:48:51,830
which is that of planning.

605
00:48:51,829 --> 00:48:57,539
We have talked of planning on and off, but
we will look at a

606
00:48:57,539 --> 00:48:58,929
closer look in a little while.

607
00:48:58,929 --> 00:49:00,039
So, we stop here.

608
00:49:00,039 --> 00:49:10,039
.

