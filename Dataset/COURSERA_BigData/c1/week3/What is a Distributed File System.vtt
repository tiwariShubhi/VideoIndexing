WEBVTT

1
00:00:00.540 --> 00:00:02.593
What is a Distributed File System?

2
00:00:16.485 --> 00:00:19.336
Most of us have file
cabinets in our offices or

3
00:00:19.336 --> 00:00:22.420
homes that help us store
our printed documents.

4
00:00:24.170 --> 00:00:27.280
Everyone has their own
method of organizing files,

5
00:00:27.280 --> 00:00:31.410
including the way we bin similar
documents into one file, or

6
00:00:31.410 --> 00:00:35.210
the way we sort them in alphabetical or
date order.

7
00:00:35.210 --> 00:00:38.380
When computers first came out,
the information and

8
00:00:38.380 --> 00:00:40.970
programs were stored in punch cards.

9
00:00:42.280 --> 00:00:45.374
These punch cards were
stored in file cabinets,

10
00:00:45.374 --> 00:00:48.760
just like the physical
file cabinets today.

11
00:00:48.760 --> 00:00:51.940
This is where the name,
file system, comes from.

12
00:00:51.940 --> 00:00:55.970
The need to store information in
files comes from a larger need

13
00:00:55.970 --> 00:00:58.720
to store information in the long-term.

14
00:00:58.720 --> 00:01:03.360
This way the information lives
after the computer program, or

15
00:01:03.360 --> 00:01:07.350
what we call process,
that produced it terminates.

16
00:01:07.350 --> 00:01:12.450
If we don't have files, our access to
such information would not be possible

17
00:01:12.450 --> 00:01:15.560
once a program using or producing it.

18
00:01:15.560 --> 00:01:20.430
Even during the process, we might need
to store large amounts of information

19
00:01:20.430 --> 00:01:25.240
that we cannot store within the program
components or computer memory.

20
00:01:25.240 --> 00:01:28.690
In addition, once the data is in a file,

21
00:01:28.690 --> 00:01:33.120
multiple processes can access
the same information if needed.

22
00:01:33.120 --> 00:01:38.940
For all these reasons, we store
information in files on a hard disk.

23
00:01:38.940 --> 00:01:41.350
There are many of these files, and

24
00:01:41.350 --> 00:01:45.750
they get managed by your operating system,
like Windows or Linux.

25
00:01:45.750 --> 00:01:50.640
How the operating system manages
files is called a file system.

26
00:01:50.640 --> 00:01:55.930
How this information is stored
on disk drives has high impact

27
00:01:55.930 --> 00:02:02.090
on the efficiency and speed of access to
data, especially in the big data case.

28
00:02:02.090 --> 00:02:07.420
While the files have exact addresses for
their locations in the drive, referring

29
00:02:07.420 --> 00:02:13.274
to the data units of sequence of these
blocks, that's called the flat structure,

30
00:02:13.274 --> 00:02:18.510
or hierarchy construction of index
records, that's called the database.

31
00:02:18.510 --> 00:02:24.710
They also have human readable symbolic
names, generally followed by an extension.

32
00:02:25.750 --> 00:02:29.140
Extensions tell what kind of file it is,
in general.

33
00:02:29.140 --> 00:02:33.640
Programs and
users can access files with their names.

34
00:02:33.640 --> 00:02:39.010
The contents of a file can be numeric,
alphabetic, alphanumeric,

35
00:02:39.010 --> 00:02:40.160
or binary executables.

36
00:02:41.180 --> 00:02:45.250
Most computer users work
on personal laptops or

37
00:02:45.250 --> 00:02:48.050
desktop computers with
a single hard drive.

38
00:02:49.050 --> 00:02:53.780
In this model, the user is limited
to the capacity of their hard drive.

39
00:02:53.780 --> 00:02:57.060
The capacity of different devices vary.

40
00:02:57.060 --> 00:02:59.460
For example, while your phone or

41
00:02:59.460 --> 00:03:04.380
tablet might have a storage capacity
in the order of gigabytes, your

42
00:03:04.380 --> 00:03:10.210
laptop computer might have a terabyte of
storage, but what if you have more data?

43
00:03:10.210 --> 00:03:13.290
Some of you probably had
issues in the past with

44
00:03:13.290 --> 00:03:15.950
running out of space on your hard drive.

45
00:03:15.950 --> 00:03:19.250
A way to solve this is to have
an external hard drive and

46
00:03:19.250 --> 00:03:23.390
store your files there or,
you can buy a bigger disk.

47
00:03:23.390 --> 00:03:28.580
Both options are a bit of a hassle, to
copy the data to a new disk, aren't they?

48
00:03:28.580 --> 00:03:30.520
They might not even be
an option sometimes.

49
00:03:31.560 --> 00:03:35.620
Now imagine, you having two computers and

50
00:03:35.620 --> 00:03:41.050
storing some of your data in one and
the rest of your data in another.

51
00:03:41.050 --> 00:03:45.560
How you organize and partition your data
between these computers is up to you.

52
00:03:46.570 --> 00:03:50.400
You might want to store your
work data in one computer and

53
00:03:50.400 --> 00:03:53.030
your personal data in another.

54
00:03:53.030 --> 00:03:57.120
Distributing data on multiple
computers might be an option, but

55
00:03:57.120 --> 00:03:59.030
it raises new issues.

56
00:03:59.030 --> 00:04:04.800
In this situation, you need to know
where to find the files you need,

57
00:04:04.800 --> 00:04:06.630
depending on what you’re doing.

58
00:04:06.630 --> 00:04:10.080
You can find it manageable,
if it’s just your data.

59
00:04:10.080 --> 00:04:14.500
But now imagine having
thousands of computers

60
00:04:14.500 --> 00:04:18.373
to store your data with big volumes and
variety.

61
00:04:18.373 --> 00:04:23.240
Wouldn't it be good to have a system
that can handle the data access and

62
00:04:23.240 --> 00:04:24.330
do this for you?

63
00:04:24.330 --> 00:04:29.450
This is a case that can be handled
by a distributive file system.

64
00:04:29.450 --> 00:04:33.590
Now, let's assume that there
are racks of these computers,

65
00:04:33.590 --> 00:04:37.758
often even distributed across the local or

66
00:04:37.758 --> 00:04:43.400
wide area network, because such file
systems, distributed file systems.

67
00:04:44.910 --> 00:04:48.800
Data sets, or parts of a data set,

68
00:04:48.800 --> 00:04:52.900
can be replicated across the nodes
of a distributed file system.

69
00:04:53.900 --> 00:04:58.900
Since data is already on these nodes,
then analysis of parts of the data

70
00:04:58.900 --> 00:05:05.030
is needed in a data parallel fashion,
computation can be moved to these nodes.

71
00:05:06.500 --> 00:05:11.590
Additionally, distributed file
systems replicate the data

72
00:05:11.590 --> 00:05:16.720
between the racks, and also computers
distributed across geographical regions.

73
00:05:18.180 --> 00:05:22.160
Data replication makes
the system more fault tolerant.

74
00:05:23.250 --> 00:05:28.290
That means, if some nodes or
a rack goes down,

75
00:05:28.290 --> 00:05:33.764
there are other parts of the system,
the same data can be found and analyzed.

76
00:05:33.764 --> 00:05:40.080
Data replication also helps with scaling
the access to this data by many users.

77
00:05:41.170 --> 00:05:47.110
Often, if the data is popular, many
reader processes will want access to it.

78
00:05:48.310 --> 00:05:51.240
In a highly parallelized replication,

79
00:05:51.240 --> 00:05:55.680
each reader can get their own node
to access to and analyze data.

80
00:05:56.920 --> 00:05:59.450
This increases overall system performance.

81
00:06:00.935 --> 00:06:05.600
Note that a problem with having
such a distributive replication is,

82
00:06:05.600 --> 00:06:09.490
that it is hard to make
changes to data over time.

83
00:06:09.490 --> 00:06:15.090
However, in most big data systems,
the data is written once and

84
00:06:15.090 --> 00:06:20.570
the updates to data is maintained
as additional data sets over time.

85
00:06:20.570 --> 00:06:25.500
As a summary, a file system is
responsible from the organization of

86
00:06:25.500 --> 00:06:28.970
the long term information
storage in a computer.

87
00:06:28.970 --> 00:06:33.991
When many storage computers
are connected through the network,

88
00:06:33.991 --> 00:06:36.916
we call it a distributed file system.

89
00:06:36.916 --> 00:06:42.035
Distributed file systems provide data
scalability, fault tolerance, and

90
00:06:42.035 --> 00:06:47.321
high concurrency through partitioning and
replication of data on many nodes.