1
00:00:10,660 --> 00:00:24,599
We are looking at planning. In the last class
we saw two approaches; one was a forward

2
00:00:24,599 --> 00:00:33,939
state space planning, and the other was backward
state space planning. The forward state

3
00:00:33,939 --> 00:00:40,000
space search; forward state space planning;
thus, forward state space search, it starts

4
00:00:40,000 --> 00:00:55,549
from the start state and keeps applying actions,
till it finds a goal state, considers actions

5
00:00:55,549 --> 00:01:06,989
in forward direction. This one considers actions
in a backward direction. It constructs

6
00:01:06,989 --> 00:01:19,429
plan also, in the forward direction, and this
one, constructs the plan in backward

7
00:01:19,429 --> 00:01:32,240
direction. So, in that sense, the two processes
of looking for actions and constructing a

8
00:01:32,239 --> 00:01:39,640
plan, happens very in a closely coupled fashion.
In forward state space search, we start

9
00:01:39,640 --> 00:01:44,810
looking for the first action and then, as
soon as we pick a first action, we say this

10
00:01:44,810 --> 00:01:47,670
is the
first action of our plan.

11
00:01:47,670 --> 00:01:51,689
In this manner, we construct the plan also,
in a forward direction. In backward state

12
00:01:51,689 --> 00:01:55,450
space search, in the likewise manner, we start
looking at the last action, looking for the

13
00:01:55,450 --> 00:01:59,740
last action; what could be my last action,
and then, also construct the plan in a backward

14
00:01:59,739 --> 00:02:06,419
.fashion, by saying that will be my last action
of the plan, essentially. Now, if you

15
00:02:06,420 --> 00:02:16,810
remember, we had this notion of relevant action
here, and the action was said to be

16
00:02:16,810 --> 00:02:32,310
relevant, if the effect of a; intersection
goal was not empty, and if it has no negative

17
00:02:32,310 --> 00:02:43,699
effects, which kind of, distracted the goal.
We had the notion of a relevant action and

18
00:02:43,699 --> 00:02:49,909
we
had a notion of regression. We could regress

19
00:02:49,909 --> 00:03:02,229
a goal over an action. So, we would get a
sub goal, g prime, if which is obtained as

20
00:03:02,229 --> 00:03:09,209
g minus the effects of a, because we expect
that

21
00:03:09,210 --> 00:03:16,629
the actions will; actionable, produce the
effects. The whole thing union p conditions

22
00:03:16,629 --> 00:03:27,030
of a.
In the similar manner, we had for forward

23
00:03:27,030 --> 00:03:31,120
state space search; the notion of an
applicability of an action and the notion

24
00:03:31,120 --> 00:03:58,120
of progress. So, a state could progress over
another state. So, you could progress over

25
00:03:58,120 --> 00:04:01,110
it.

26
00:04:01,110 --> 00:04:05,260
This regression progress and the notion of
applicability and relevance was used basically,

27
00:04:05,259 --> 00:04:11,139
to do both these stars, that looking for actions
and building the plan at the same time. So,

28
00:04:11,139 --> 00:04:14,579
the process of building the plan is that you
move from one state to the next, and then,

29
00:04:14,580 --> 00:04:20,319
look for an applicable action; then, move
to the next state, and look for an applicable

30
00:04:20,319 --> 00:04:24,740
action; move to the next state. Here, you
are looking at a relevant action. So, you

31
00:04:24,740 --> 00:04:27,789
look at
a goal, find a relevant action, regress to

32
00:04:27,790 --> 00:04:33,240
a goal g prime, and try to find a new action
at

33
00:04:33,240 --> 00:04:42,650
that point. So, what we had observed then,
was that this was a sound process that, when

34
00:04:42,649 --> 00:04:51,939
you progress from one state to another; what
you get is a legal state, essentially. So,

35
00:04:51,939 --> 00:05:01,709
this
was sound, but this was not sound.

36
00:05:01,709 --> 00:05:09,129
We had seen that you could regress to a set
of predicates, which could not have been part

37
00:05:09,129 --> 00:05:13,519
of a state. So, for example, you might have
something, like holding a and holding b, at

38
00:05:13,519 --> 00:05:17,250
the same time. That, of course, not possible
in a state in which, because we are

39
00:05:17,250 --> 00:05:21,610
considering one arm robot. So, you could;
this process of regression was not sound,

40
00:05:21,610 --> 00:05:24,460
in
the sense, it was not closed under the set

41
00:05:24,459 --> 00:05:28,000
of states. You could start with a possible
state

42
00:05:28,000 --> 00:05:33,310
and you could end up with something, which
is not a state, whereas, this was sound and

43
00:05:33,310 --> 00:05:37,470
you would always end up in states, which is
why, when we did backward state space

44
00:05:37,470 --> 00:05:42,360
planning, we said one of things to do is that
after you found a sequence of actions, check,

45
00:05:42,360 --> 00:05:49,919
whether it is a valid plan or not, before
accepting it. So, this was a plus point of

46
00:05:49,918 --> 00:05:51,870
forward
state space planning, and this was corresponding

47
00:05:51,870 --> 00:05:56,040
negative point of backward state space
planning. On the other hand, in forward state

48
00:05:56,040 --> 00:06:01,150
space planning, we had large branching
factor.

49
00:06:01,149 --> 00:06:08,859
.Because the state was a complete description;
it may have hundreds of facts. There may

50
00:06:08,860 --> 00:06:12,800
be hundreds of applicable actions. Forward
state space planning would consider all those

51
00:06:12,800 --> 00:06:18,610
hundreds actions, and choose one of them,
essentially. Backward direction search had

52
00:06:18,610 --> 00:06:28,230
low branching, and the reason for that was
that we were focusing on the goal; we are

53
00:06:28,230 --> 00:06:34,120
trying to see, what we need do to get the
goal, predicates into our state, essentially.

54
00:06:34,120 --> 00:06:38,720
So,
this was a plus point for backward state space

55
00:06:38,720 --> 00:06:43,250
search. Today, we want to look at an
algorithm, which combines both these features.

56
00:06:43,250 --> 00:06:48,829
So, what do we mean by this? We want
to look at an algorithm, which will consider

57
00:06:48,829 --> 00:06:52,959
actions from the goal point of view, in a
goal

58
00:06:52,959 --> 00:06:59,649
directed fashion, but it will construct plans
from the starting state to the goal state,

59
00:06:59,649 --> 00:07:05,138
essentially, which means that we will be benefiting
from the low branching factor of

60
00:07:05,139 --> 00:07:10,889
doing goal directed search, and also, the
soundness of constructing a plan in a forward

61
00:07:10,889 --> 00:07:11,889
manner, essentially.

62
00:07:11,889 --> 00:07:17,668
You should ponder by little bit over this,
as to why is the progress action sound, and

63
00:07:17,668 --> 00:07:20,409
the
regress action not sound, essentially. So,

64
00:07:20,410 --> 00:07:25,220
the actions are not symmetric in that sense,
essentially; you cannot prove both ways. These

65
00:07:25,220 --> 00:07:31,810
are sort of an arrow of time, which says
this is a precondition, and this is a post

66
00:07:31,810 --> 00:07:35,600
condition. So, you can only construct plans
by

67
00:07:35,600 --> 00:07:38,310
looking at pre conditions and making post
conditions.

68
00:07:38,310 --> 00:07:39,310
.

69
00:07:39,310 --> 00:07:47,329
.The algorithm that you want to look at today
is called goal stack planning. It is actually,

70
00:07:47,329 --> 00:07:54,560
one of the earliest planning algorithms devised,
and was in fact, used in the skips

71
00:07:54,560 --> 00:08:02,129
program, which was used to control the robot
in Stanford that we have spoken about,

72
00:08:02,129 --> 00:08:09,129
essentially. The general idea of goal stack
planning is the following. What I will do

73
00:08:09,129 --> 00:08:11,180
is I
will give a high level description of the

74
00:08:11,180 --> 00:08:18,660
planner, and then, we will look at an example
in

75
00:08:18,660 --> 00:08:25,230
a little bit more detailed, essentially. So,
as the name suggests, this uses a stack to

76
00:08:25,230 --> 00:08:31,580
do the
reasoning, and we do the following that; let

77
00:08:31,579 --> 00:08:38,389
us also consider an example, along the same,
at the same time. So, let us say that this

78
00:08:38,389 --> 00:08:43,578
is an example. Again, we have resorting to
the

79
00:08:43,578 --> 00:08:47,519
blocks while, because we are familiar with
it, but you must keep in mind that these are

80
00:08:47,519 --> 00:09:01,490
general domain independent algorithms that
we are considering. This is a starting state

81
00:09:01,490 --> 00:09:05,198
and I am not drawing anything, which is relevant.
You can imagine that there are 50

82
00:09:05,198 --> 00:09:08,990
blocks, which I have not drawn here, which
will not interfere with our plan. So, we just

83
00:09:08,990 --> 00:09:11,469
want to focus on the planning actions today.

84
00:09:11,469 --> 00:09:12,469
.

85
00:09:12,469 --> 00:09:21,589
The goal state is that; let us say is that
you want a on b, and you want b on d, essentially.

86
00:09:21,589 --> 00:09:36,360
You actually, do not care what else is true,
essentially. So, the goal is on a b, and on

87
00:09:36,360 --> 00:09:39,050
b d.
As long as these two predicate are there in

88
00:09:39,049 --> 00:09:42,958
my state description, I would call that a
goal

89
00:09:42,958 --> 00:09:47,338
state, essentially, which means, as long as
a is on b, and b is on d, that whichever state

90
00:09:47,339 --> 00:09:49,529
it
is, is a goal state. You can think of this

91
00:09:49,528 --> 00:09:52,578
as a set of states in which, this part is
common.

92
00:09:52,578 --> 00:10:13,928
.Everything else can be in some manner, essentially.
So, this is basically, a set, and the

93
00:10:13,928 --> 00:10:20,068
algorithm that we are looking at, will do
the following.

94
00:10:20,068 --> 00:10:21,068
.

95
00:10:21,068 --> 00:10:37,338
It pushes; you start of a pushing the goals
that you want to achieve on the stack. So,

96
00:10:37,339 --> 00:10:41,550
the
top of the stack will always, contain the

97
00:10:41,549 --> 00:10:49,238
goals that you want to achieve, essentially.
When I say goals, I basically, mean the predicates

98
00:10:49,239 --> 00:10:57,879
of the goal, essentially. Now, let me
do this here, and let me write the algorithm,

99
00:10:57,879 --> 00:11:06,438
here. So, goal stack planning; push goals
on

100
00:11:06,438 --> 00:11:24,860
to stack; then, you pop the stack. There are
various things that can come out of the stack.

101
00:11:24,860 --> 00:11:36,409
If it is a predicate; I will use very loose
language here. When I say, if predicate, I

102
00:11:36,409 --> 00:11:40,419
mean a
statement like; on a b, or on b c; or holding

103
00:11:40,419 --> 00:11:51,139
a; or some such things. Then, there are two
possibilities; one if true, which means, it

104
00:11:51,139 --> 00:12:09,829
already holds in the world; then do nothing.
Else, it is not true; push an action on to

105
00:12:09,828 --> 00:12:17,578
the stack. So, this is a basic process that
this

106
00:12:17,578 --> 00:12:22,169
algorithm follows. The stack has, you are
pushing these goal predicates on to the stack.

107
00:12:22,169 --> 00:12:28,698
In our example, we push these two things on
to the stack; then, you pop. So, it is the

108
00:12:28,698 --> 00:12:35,328
alternates between push and pop; you pop the
stack. If it is a predicate that comes out,

109
00:12:35,328 --> 00:12:38,838
then you check, whether the predicate is true.
If it is true, then you do not have to do

110
00:12:38,839 --> 00:12:44,749
anything. If it is not true, you push an action
on to the stack, essentially. What action?

111
00:12:44,749 --> 00:12:55,310
You should say the element action; here, define
the notion of relevant action.

112
00:12:55,309 --> 00:13:04,248
.If it is not a predicate, it must be an action
there. Only two kinds of objects in a domain,

113
00:13:04,249 --> 00:13:21,119
either predicates or actions; if it is an
action; I forgot one thing. You push the action

114
00:13:21,119 --> 00:13:24,639
on
to the stack and push. So, let us say this

115
00:13:24,639 --> 00:13:34,289
action is a; push pre conditions 
on to stack. You

116
00:13:34,289 --> 00:13:39,189
first, push the action. Then, you push the
pre conditions of the action, and you can

117
00:13:39,190 --> 00:13:41,119
get
some intuition here, that you are pushing

118
00:13:41,119 --> 00:13:44,290
an action. Then you are pushing the pre
conditions, and then, you will look at the

119
00:13:44,289 --> 00:13:49,259
top of the stack, and there will be the pre
conditions of the actions. If they are true,

120
00:13:49,259 --> 00:13:50,759
then this thing will happen; you will not
do

121
00:13:50,759 --> 00:13:55,789
anything; you just remove them. Eventually,
if the action comes to the top, then you will

122
00:13:55,789 --> 00:13:59,389
say, yes, I have found one action, essentially.

123
00:13:59,389 --> 00:14:16,948
There is an extra step, which is, push each
predicate 

124
00:14:16,948 --> 00:14:24,448
on to the stack, essentially. So, this
part is that, if then part, then for this

125
00:14:24,448 --> 00:14:34,878
if, we have these else, pop, action, or we
have

126
00:14:34,879 --> 00:14:50,188
already done the pop. So, add action to the
plan, and by this, we mean that a plan

127
00:14:50,188 --> 00:14:57,659
becomes plan followed by dot where, the dot
operator is a concordinate operator, which

128
00:14:57,659 --> 00:15:03,049
says that you take the plan and add the action
at the end of it. So, you found the next

129
00:15:03,049 --> 00:15:08,719
action, essentially. So, this part, that you
are talking about, it constructs plan in a

130
00:15:08,720 --> 00:15:11,749
forward
direction, is taken care of by this operator,

131
00:15:11,749 --> 00:15:17,220
essentially. The new plan is an old plan with
the action at the end. Initially, of course,

132
00:15:17,220 --> 00:15:22,519
old plan will be empty. The moment you find
the first action that will go into it, and

133
00:15:22,519 --> 00:15:24,869
then you find the next action that will go
into it,

134
00:15:24,869 --> 00:15:30,990
and so on and so forth. So, this is a high
level algorithm for goal stack planning. Let

135
00:15:30,990 --> 00:15:36,730
us
see how it actually, executes this. We will,

136
00:15:36,730 --> 00:15:46,649
sort of, try to simulate for this small problem;
what goal stack planning does? Before I do

137
00:15:46,649 --> 00:15:48,778
the simulation, let us make an observation
as

138
00:15:48,778 --> 00:15:57,039
to what this is really, doing. It is taking
a set of goals; the pre conditions. Every

139
00:15:57,039 --> 00:15:59,068
action
has a few pre conditions. So, it is a set

140
00:15:59,068 --> 00:16:01,659
of goals, or set of sub goals, you might want
to

141
00:16:01,659 --> 00:16:03,549
say, and push it on to the stack.

142
00:16:03,549 --> 00:16:14,289
Then, it pushes each predicate of the pre
conditions on to the stack. We should do the

143
00:16:14,289 --> 00:16:25,608
same thing here, essentially; push each predicate.
We will see the usefulness of this step

144
00:16:25,609 --> 00:16:32,689
in the example that we see, but the important
thing to note here, is that it is taking a

145
00:16:32,688 --> 00:16:35,909
set of
goals, or a set of sub goals; we use the term

146
00:16:35,909 --> 00:16:40,971
goals and sub goals, interchangeably. The
initial goal is the only final goal. Everything

147
00:16:40,971 --> 00:16:47,129
else is a sub goal, but we tend to use the
term goals, also for that, essentially. When

148
00:16:47,129 --> 00:16:52,839
we have a set of goals to solve, for example,
in the pre conditions of an action, we put

149
00:16:52,839 --> 00:16:56,529
them one by one into the stack, which means

150
00:16:56,528 --> 00:17:02,798
.we have serializing the goals, sub goals,
essentially. So, this is saying; serializing

151
00:17:02,798 --> 00:17:15,889
the sub
goals. In effect, we are saying, we will first

152
00:17:15,890 --> 00:17:19,079
achieve one sub goal. Then, we will achieve
the next sub goal. Then, we will achieve the

153
00:17:19,078 --> 00:17:25,889
next sub goal, and in that fashion,
essentially. So, we have, in some sense, if

154
00:17:25,890 --> 00:17:28,420
you look at what A star did, it also said,
I am

155
00:17:28,420 --> 00:17:33,440
breaking up a goal into sub goals, and I will
solve each of them independently. This is

156
00:17:33,440 --> 00:17:37,000
doing that, but it is also imposing an order
in which, you will solve them. So, that is

157
00:17:37,000 --> 00:17:39,660
why
we use a term; it is serializing the sub goals,

158
00:17:39,660 --> 00:17:40,660
essentially.

159
00:17:40,660 --> 00:17:41,660
.

160
00:17:41,660 --> 00:17:48,340
So, our initial sub goals are those two, on
a b. I will just use, I will not use brackets,

161
00:17:48,339 --> 00:17:56,759
just
to make it short; and on b d, and I will go

162
00:17:56,759 --> 00:18:02,779
by stack downwards, and I hope that you get
used to that idea. When we pop stack, the

163
00:18:02,779 --> 00:18:05,329
stack we will just put a line across, to say,
that

164
00:18:05,329 --> 00:18:11,240
element has been popped. So, you must visualize
this stack going down. Let us say that

165
00:18:11,240 --> 00:18:23,630
we put these in this order that we say, you
achieve on b d, and you achieve on a b. So,

166
00:18:23,630 --> 00:18:32,490
this is the bottom of my stack, and my stack
is going like this. So, whatever done, I have

167
00:18:32,490 --> 00:18:39,029
pushed the two, I have pushed the goal, which
is these two elements on to my stack, and

168
00:18:39,029 --> 00:18:43,920
then, I pushed each predicate in some order.
So, we are not saying in what order; we

169
00:18:43,920 --> 00:18:47,680
saying in some order; push them in to this
stack. This is a place where, you can, sort

170
00:18:47,680 --> 00:18:50,100
of,
try to think of heuristics; what is the good

171
00:18:50,099 --> 00:18:58,649
order of pushing things. So, this is a goal
given to us.

172
00:18:58,650 --> 00:19:05,900
.I want to emphasize again, that considering
of actions is done in a backward fashion.

173
00:19:05,900 --> 00:19:09,990
So,
we are now, only trying to see what actions

174
00:19:09,990 --> 00:19:16,480
will achieve these goals, which is exactly
like, what backward state space does; except

175
00:19:16,480 --> 00:19:22,019
for that backward state space says that
moment, for example, if you look at on a b,

176
00:19:22,019 --> 00:19:24,900
it will say the last action must be stack
a b;

177
00:19:24,900 --> 00:19:29,940
stack a on b. It starts constructing the plan
also, in a backward fashion. We will not do

178
00:19:29,940 --> 00:19:35,529
that here; we will wait a little bit more
patiently, till we are sure that whenever,

179
00:19:35,529 --> 00:19:39,940
we add
an action to a plan, its pre conditions are

180
00:19:39,940 --> 00:19:44,759
true. Backward state space planning does not
look at pre conditions at all. It only looks

181
00:19:44,759 --> 00:19:46,730
at the relevance of an action. It says if
an action

182
00:19:46,730 --> 00:19:50,610
is relevant, it could be the last action,
and we saw that this leads to the trouble

183
00:19:50,609 --> 00:19:55,719
that the
plan construction process is not sound. So,

184
00:19:55,720 --> 00:20:02,000
we have on a b, now, and we go to the pop
cycle.

185
00:20:02,000 --> 00:20:09,609
So, we push this out. This is gone and then,
we have this condition. It is a predicate

186
00:20:09,609 --> 00:20:15,000
and it
also, happens to be true, in my given state;

187
00:20:15,000 --> 00:20:21,170
you look at the value in a given state. It
is true

188
00:20:21,170 --> 00:20:33,560
so, you do not do anything. Then, you pop
the next thing out on b d. Remember, this

189
00:20:33,559 --> 00:20:35,079
was
popped out first, and now, we are talking

190
00:20:35,079 --> 00:20:39,569
about on b d. So, let me, sort of, use an
arrow

191
00:20:39,569 --> 00:20:45,679
to denote that we are considering this; just
for our sake. That is not true; on b d is

192
00:20:45,680 --> 00:20:53,680
not true
in my, this state, and therefore, I push and

193
00:20:53,680 --> 00:21:01,570
action, which will make this true. So, the
action that makes on b d true is stack BD.

194
00:21:01,569 --> 00:21:12,409
So, let us say we use this arrow to depict
the

195
00:21:12,410 --> 00:21:15,400
fact that we have pushing an action, essentially.

196
00:21:15,400 --> 00:21:21,759
So, you push an action and we push the pre
conditions of the action. What are the pre

197
00:21:21,759 --> 00:21:31,730
conditions of stack? I will you short forms;
h for holding; holding b, and clear d,

198
00:21:31,730 --> 00:21:41,660
anything else; you remember these preconditions
for stack. You must be holding b, and d

199
00:21:41,660 --> 00:21:48,330
must be clear, I think that is about it. Then,
I have pushed the individual actions. While,

200
00:21:48,329 --> 00:21:51,399
we are doing this example, we will use a simple
heuristic, we will assume that the

201
00:21:51,400 --> 00:21:55,940
holding action is the last action we want
to do; last goal we want to achieve. Remember,

202
00:21:55,940 --> 00:22:02,970
these are two goals. If you can, just to recall,
this is a, let me put brackets here; that

203
00:22:02,970 --> 00:22:05,140
we
want holding b to be true, and we want to

204
00:22:05,140 --> 00:22:10,270
check, whether d is clear to be true, and
we

205
00:22:10,269 --> 00:22:12,299
will push each individual action.

206
00:22:12,299 --> 00:22:18,789
So, the first action, the first predicate
we push, will be the last predicate we will

207
00:22:18,789 --> 00:22:22,509
check,
and let us use this heuristic between ourselves.

208
00:22:22,509 --> 00:22:24,960
In practice, of course, an algorithm may

209
00:22:24,960 --> 00:22:30,900
.have to back track and try the other option
or something like that. That we will check

210
00:22:30,900 --> 00:22:35,830
for
holding b later. First, worry about; let us

211
00:22:35,829 --> 00:22:40,409
worry about clear d, essentially. So, this
is a

212
00:22:40,410 --> 00:22:46,220
push space. In a push space, everything gets
pushed; the action and its pre conditions,

213
00:22:46,220 --> 00:22:51,529
and individual goals in the pre conditions.
We will refer to them also, as goals, because

214
00:22:51,529 --> 00:23:01,559
this is a goal stack now, essentially. So,
we know push, we know pop this c d out.

215
00:23:01,559 --> 00:23:11,349
That clear d is not true, but we must insert;
we must push an action, which will make

216
00:23:11,349 --> 00:23:20,839
clear d true. So, this is a situation; c is
on d. So, we can use an action unstack. So

217
00:23:20,839 --> 00:23:35,759
far, we
are doing backward search c d, and then, the

218
00:23:35,759 --> 00:23:48,779
preconditions of unstack c d, which are that;
on c d must be true; and arm empty must be

219
00:23:48,779 --> 00:24:09,720
true; and one more, clear c must be true.
Then, these individually, again, in some order,

220
00:24:09,720 --> 00:24:14,910
let me choose arm empty as the last
predicate. Intuitively, I just want to reduce

221
00:24:14,910 --> 00:24:24,170
some amount of extra work we want to do
here, but this is a matter of choosing heuristics.

222
00:24:24,170 --> 00:24:32,430
So, everything is pushed here, like this.
Basically, this is a cycle; I have not mentioned

223
00:24:32,430 --> 00:24:39,860
it here, but this whole thing is in to a
cycle here. Then, you go and pop this clear

224
00:24:39,859 --> 00:24:48,099
c; now, clear c happens to be true in our
world. So, we do not do anything. On c d also,

225
00:24:48,099 --> 00:24:55,019
happens to be true; on a also, happens
true, and it is not a surprise in particular

226
00:24:55,019 --> 00:24:59,799
case; that the conjunct of all three on CD,
an

227
00:24:59,799 --> 00:25:02,149
AE, an CC happens to be true.

228
00:25:02,150 --> 00:25:09,670
So, we remove this from the stack, and now,
in the next pop, an action comes out, which

229
00:25:09,670 --> 00:25:14,009
is this last part of the algorithm, which
says, if it is not predicate, it must be an

230
00:25:14,009 --> 00:25:18,940
action,
and add action to the plan. So, this becomes

231
00:25:18,940 --> 00:25:31,600
our first action; unstack c from d. The world
has changed now. The world is, I am holding

232
00:25:31,599 --> 00:25:43,769
d. Whenever, I look at a predicate, I must
look at this world. Now, you will notice that

233
00:25:43,769 --> 00:25:51,509
when I am talking about actions, I am going
in the forward direction. This was the given

234
00:25:51,509 --> 00:25:53,880
start state, and this is the first action
that will

235
00:25:53,880 --> 00:25:59,750
be there; part of my plan. The first action
will be unstack c from d, essentially. So,

236
00:25:59,750 --> 00:26:01,920
everything that we do here will be sound,
essentially.

237
00:26:01,920 --> 00:26:08,269
That also, does not lose sight of the fact,
that we are considering the actions in a goal

238
00:26:08,269 --> 00:26:13,389
directed fashion. We started off by saying
that what is necessary for making on a b,

239
00:26:13,390 --> 00:26:17,890
on a
b true, on b d true, and then, we said to

240
00:26:17,890 --> 00:26:23,310
make on b d true, you must do stack b d, and
then, we discovered that to do stack b d,

241
00:26:23,309 --> 00:26:26,909
we need to do clear d, and to do clear d,
we can

242
00:26:26,910 --> 00:26:32,900
do unstack c d, and we find that we are able
to unstack cd, and so, we put that as a first

243
00:26:32,900 --> 00:26:43,440
.action. So, this signifies the plan. So,
that is gone now, from the stack. Then, it

244
00:26:43,440 --> 00:26:49,480
has got
holding b as a next action. Holding b is not

245
00:26:49,480 --> 00:26:58,269
true in this world; you are holding c,
essentially. Let me grow the stack from here,

246
00:26:58,269 --> 00:27:08,470
that when I pop holding b out, I am forced
to insert an action. So, I have a choice here.

247
00:27:08,470 --> 00:27:11,460
Notice that to make holding b true, I can
use

248
00:27:11,460 --> 00:27:18,309
an action; unstack b from something, or I
can use the action; pick up b, essentially.

249
00:27:18,309 --> 00:27:19,929
We
will assume that we have some non determinism

250
00:27:19,930 --> 00:27:25,430
going on here, or you could look at the
state and try to decide, which of those two

251
00:27:25,430 --> 00:27:31,181
actions is a relevant action? So, we will
assume that somehow, we are used pick up b.

252
00:27:31,181 --> 00:27:41,440
So, the stack is now going like that, and
along with pick up b, the actions, which are

253
00:27:41,440 --> 00:27:53,701
arm
empty, and on table b, and clear b. So, let

254
00:27:53,701 --> 00:28:01,049
us say I look at them in this order or in
the

255
00:28:01,049 --> 00:28:09,700
same order; on table b and clear b. So, I
have pushed this action and it is preconditions.

256
00:28:09,700 --> 00:28:14,880
Then, I pop the top of the stack. Remember,
the top of the stack is actually, at the lower

257
00:28:14,880 --> 00:28:23,460
end of our list; I have popped this. Clear
b is not true in the world that I have here.

258
00:28:23,460 --> 00:28:29,400
So, I
must insert an action, which is unstack something

259
00:28:29,400 --> 00:28:34,360
from b, but we will assume that we
have figured out that it has got to be a from

260
00:28:34,359 --> 00:28:40,859
b, and the preconditions for that are on a
b,

261
00:28:40,859 --> 00:28:58,409
and arm empty and clear a. So, let us say
arm empty, on a b and clear a; clear a is

262
00:28:58,410 --> 00:29:03,779
true.
So, I can remove it from the, pop it from

263
00:29:03,779 --> 00:29:10,740
the stack. On a b is also true. So, I can
pop that

264
00:29:10,740 --> 00:29:14,250
from the stack, but arm empty is not true,
because this is the world that I am looking

265
00:29:14,250 --> 00:29:17,819
at. I
am moving forward from here. I am holding

266
00:29:17,819 --> 00:29:18,819
c.

267
00:29:18,819 --> 00:29:29,769
So, I must make arm empty to make arm empty,
I insert an action, put down c and the

268
00:29:29,769 --> 00:29:41,990
preconditions for that are holding c, and
that is all. So, you pop this and you pop

269
00:29:41,990 --> 00:29:46,390
this, and
this becomes a second action; that you have

270
00:29:46,390 --> 00:29:56,080
put down c. So, now, the world looks like
a,

271
00:29:56,079 --> 00:30:08,769
which is the world. I have done two actions.
One action I have done is unstack c from d,

272
00:30:08,769 --> 00:30:13,470
and then, I was in this state. Then, I have
put down c, then I am in this state; that

273
00:30:13,470 --> 00:30:20,480
is a
second action. Then comes this conjunct, on

274
00:30:20,480 --> 00:30:25,690
a b is true here, arm empty is true here,
clear

275
00:30:25,690 --> 00:30:33,970
a is true here. So, I can remove this, and
then, I can pop this; this becomes the third

276
00:30:33,970 --> 00:30:55,250
action. Now, the world looks like, you are
holding a. The rest is all on 

277
00:30:55,250 --> 00:30:57,960
the table. So, this
is that.

278
00:30:57,960 --> 00:31:04,130
Let me label these states. This is a state
after action one. This is a state after action

279
00:31:04,130 --> 00:31:06,550
two.
This is a state after action three, which

280
00:31:06,549 --> 00:31:11,428
is unstacked a b. Then, the next thing on
top of

281
00:31:11,429 --> 00:31:18,350
.stack is, on table b. I pop that and I see
that is true in this state. Then, arm empty

282
00:31:18,349 --> 00:31:25,620
is not
true. So, I have to achieve arm empty. Let

283
00:31:25,621 --> 00:31:30,059
me start here. I need, I remove arm empty
of

284
00:31:30,058 --> 00:31:36,369
course, and then, say put down. So, I am holding
a. I need put down a. Again, there is a

285
00:31:36,369 --> 00:31:42,689
choice, which I am, sort of, skinning over
here. The choice is really, that either, I

286
00:31:42,690 --> 00:31:45,029
put a
down, or I put it on b, or put it on c, or

287
00:31:45,029 --> 00:31:47,329
put it on d, essentially. May be, you can
do a little

288
00:31:47,329 --> 00:31:51,560
bit more sophisticated reasoning here, but
I am, sort of, just to illustrate this, I

289
00:31:51,560 --> 00:31:55,379
am just
saying that we have something, like a nondeterministic

290
00:31:55,380 --> 00:31:59,960
choice happening, which means
magically, we are making the correct choice;

291
00:31:59,960 --> 00:32:02,079
this is to put down.

292
00:32:02,079 --> 00:32:16,220
For which, you must be holding a. So, you
can do this, and this becomes the fourth

293
00:32:16,220 --> 00:32:27,910
action. After the fourth action, everything
is on the table 

294
00:32:27,910 --> 00:32:42,880
and the arm empty. So, I must
go back by a stack I have; I find this conjunct

295
00:32:42,880 --> 00:32:50,000
here; arm is empty, on table t b, and clear
b; everything is true. So, I pop that, then

296
00:32:50,000 --> 00:32:55,558
this becomes my fifth action; pickup b. So,
at

297
00:32:55,558 --> 00:33:12,440
the end of fifth action, I am holding b, and
a c d are on the table. So, this is gone from

298
00:33:12,440 --> 00:33:20,299
my stack, and this is where, we had taken
off. Now, you are holding b and clear d. You

299
00:33:20,299 --> 00:33:27,259
can see that in that fifth state, both are
true; you are holding b and clear d is true.

300
00:33:27,259 --> 00:33:31,089
This
goes off. Now, we have the sixth action coming

301
00:33:31,089 --> 00:33:35,579
out. The moment an action comes out of
the stack, we know that it is applicable.

302
00:33:35,579 --> 00:33:40,629
Why, because we have just popped their
preconditions; pre conditions must be true,

303
00:33:40,630 --> 00:33:43,110
essentially. So, it must be applicable. So,
this

304
00:33:43,109 --> 00:33:56,659
is the sixth action; stack b on d. So, this
is how it looks 

305
00:33:56,660 --> 00:34:05,529
and arm is empty.

306
00:34:05,529 --> 00:34:19,259
Now, observe that in a manner of speaking,
we started off with two sub goals; on b d

307
00:34:19,260 --> 00:34:24,149
and
on a b. We decided to do on a b first, and

308
00:34:24,148 --> 00:34:27,828
in this case, it was already true in this
state. So,

309
00:34:27,829 --> 00:34:32,818
we do not have to do anything, but as you
can see that was a right choice, essentially.

310
00:34:32,818 --> 00:34:34,469
If I
have to achieve, if we look at the goal state,

311
00:34:34,469 --> 00:34:38,128
which is that a must be on b, b must be on
d;

312
00:34:38,128 --> 00:34:43,248
you can see that the way to achieve the goal
is to first, achieve on b d, and then, put

313
00:34:43,248 --> 00:34:45,719
a on
top of the stack that you have, tower that

314
00:34:45,719 --> 00:34:51,568
have constructed, essentially. We choose an
opposite order, and we ended up finding a

315
00:34:51,568 --> 00:34:58,179
plan, which is the six step plan, which says
that you unstack c from d. So, this is the

316
00:34:58,179 --> 00:35:07,078
state. Then, you put down c. Then, you unstack
a from b. Then, put down a. Then, you pick

317
00:35:07,079 --> 00:35:13,539
up b, and stack it on to d, which is what,
this

318
00:35:13,539 --> 00:35:15,019
did, essentially.

319
00:35:15,018 --> 00:35:18,809
So, on the surface, it looks like we have
achieved both these goals, but if you look

320
00:35:18,809 --> 00:35:19,809
at this

321
00:35:19,809 --> 00:35:25,338
.state, when we achieved the second goal,
which is on b d, which is what we were doing

322
00:35:25,338 --> 00:35:30,078
all this while, and as a result of which,
on b d is true here. We have undone the first

323
00:35:30,079 --> 00:35:34,048
goal
that we had done, essentially. My first goal

324
00:35:34,048 --> 00:35:38,748
was that a should be on b. We started off
with a on b, but by the time, we finished

325
00:35:38,748 --> 00:35:42,159
on b d that, a now, lying on the table. So,
you

326
00:35:42,159 --> 00:35:49,690
can see this is the reason why, we have added
both the conjunct of the goals as well as

327
00:35:49,690 --> 00:35:55,079
individual goals. So, we are saying we want
achieve this conjunct, but we will do it

328
00:35:55,079 --> 00:35:59,548
individually, will serialize the sub goals;
we did this; then, we did this. Then, we found

329
00:35:59,548 --> 00:36:05,420
that in this sequence, we, somehow ended up,
undoing some of the goals. So, when I

330
00:36:05,420 --> 00:36:09,349
popped this out, I will find that this is
not true.

331
00:36:09,349 --> 00:36:16,088
So, I will insert both the goals again, into
the stack. So, let us say if we inserted in

332
00:36:16,088 --> 00:36:19,308
the
same order here; that I insert on b d and

333
00:36:19,309 --> 00:36:24,460
on a b first; first, on b d, then on a b,
which

334
00:36:24,460 --> 00:36:28,108
means I am first doing on a b and then, I
am doing on b d, as I did in the last time,

335
00:36:28,108 --> 00:36:32,369
essentially, but now my starting state has
changed. That is my starting state. So, I

336
00:36:32,369 --> 00:36:38,079
will
not go into the stack, because we do not have

337
00:36:38,079 --> 00:36:42,839
a space left on the board, but you can
imagine that to achieve on a b, we will do

338
00:36:42,838 --> 00:36:49,239
the same thing; stack a on b. To stack a on
b,

339
00:36:49,239 --> 00:36:56,951
you must be holding a. To be holding a, you
must pick up a. So, you pick up a and stack

340
00:36:56,951 --> 00:37:02,650
a on b; these two actions, you will end up
doing. So, you will achieve on a b.

341
00:37:02,650 --> 00:37:09,130
Once you achieved on b, you will go back to
on b d, but this time, on b d is already true,

342
00:37:09,130 --> 00:37:11,670
because in that state, as you can see, it
is already true. Only thing you are doing

343
00:37:11,670 --> 00:37:14,369
is in the
seventh and the eight step, you are picking

344
00:37:14,369 --> 00:37:19,829
up a from here, and stacking it on to b. So,
this is a final state that you are looking

345
00:37:19,829 --> 00:37:23,380
at; a is on b and b is on d, essentially.
So, both the

346
00:37:23,380 --> 00:37:32,380
sub goals are true, and then, I am finally,
able to pop the goal, and that is a terminating

347
00:37:32,380 --> 00:37:37,190
criteria. If I can pop the goal and come up
an empty stack; that means, I found a plan

348
00:37:37,190 --> 00:37:43,230
for
solving my problem, essentially. To emphasize

349
00:37:43,230 --> 00:37:50,369
what goal stack planning does, it does, it
considers plans in a backward fashion. It

350
00:37:50,369 --> 00:37:54,940
looks for actions in a backward fashion by
putting the goals that you want achieve, on

351
00:37:54,940 --> 00:37:59,289
to the top of stack, starting with an empty
stack of push, and it always, looks at the

352
00:37:59,289 --> 00:38:01,539
goals set on the top of the stack, which means,
it

353
00:38:01,539 --> 00:38:08,069
is doing backward reasoning, but when it comes
to constructing a plan, when it comes to

354
00:38:08,068 --> 00:38:13,509
saying that this is my first, these are my
actions; it starts off by choosing the first

355
00:38:13,509 --> 00:38:14,509
action
first.

356
00:38:14,509 --> 00:38:19,068
.So, if you look at this plan, this is a first
action. Even, when you want to actually,

357
00:38:19,068 --> 00:38:28,769
implement the plan, you want to first, unstack
a from b, sorry, unstack c from d; put it

358
00:38:28,769 --> 00:38:33,230
down on the table. So, it is doing, it is
constructing the plan like a forward state

359
00:38:33,230 --> 00:38:38,429
space
planner. It is looking for a plan like a backward

360
00:38:38,429 --> 00:38:42,000
state space planner. So, it is taking the
advantage of both the things. It is only focusing

361
00:38:42,000 --> 00:38:46,059
on the goal by looking for a plan, or it is
making sure that when it is construct a sequence

362
00:38:46,059 --> 00:38:48,309
of actions, it is a valid plan, because it
is

363
00:38:48,309 --> 00:38:56,349
doing it in the forward fashion. In the process,
it ends up serializing the goals, but we

364
00:38:56,349 --> 00:39:00,568
have to be extra sure that we do not disturb
the goal; so that, we add this whole thing

365
00:39:00,568 --> 00:39:04,518
or
doing this extra thing, all over again, essentially.

366
00:39:04,518 --> 00:39:10,469
Now, it turns out, and I will leave this as
a small excise for you, is that if I had

367
00:39:10,469 --> 00:39:16,328
considered them in the opposite order, which
says that first, do on b d, then, on a b,

368
00:39:16,329 --> 00:39:20,640
which inside inverted the order in which,
I push up in to the stack. First, I would

369
00:39:20,639 --> 00:39:23,230
have
done on b d, which amounts to everything that

370
00:39:23,230 --> 00:39:26,460
we have done here, and I would have
ended up in that state. Then, I would have

371
00:39:26,460 --> 00:39:28,960
done on a b, and I would have just picked
up

372
00:39:28,960 --> 00:39:38,588
the a; this a, and put it on to b. So, there
is an order I can choose in which, I am not

373
00:39:38,588 --> 00:39:45,498
undoing the work done for the solving the
previous goal. This particular order, I am

374
00:39:45,498 --> 00:39:48,848
undoing the work. Of course, I did not have
to do any work to achieve on ab, because it

375
00:39:48,849 --> 00:39:53,470
was already true, but imagine that, a was
on the table here, or something like this,

376
00:39:53,469 --> 00:39:55,889
and
then, I picked up a, and put on to b. Now,

377
00:39:55,889 --> 00:39:57,231
I would have undone the work that I have,
I

378
00:39:57,231 --> 00:40:07,009
am doing, essentially. So, there is an order
in some cases, essentially.

379
00:40:07,009 --> 00:40:08,009
..

380
00:40:08,009 --> 00:40:32,139
Now, interestingly, it was shown by a guy,
called Sussman, that it is not always possible

381
00:40:32,139 --> 00:40:36,349
that such an order may be found. What order
am I talking about? I am talking about an

382
00:40:36,349 --> 00:40:42,929
order of serializing sub goals; so that, there
is no disruption of previously achieved sub

383
00:40:42,929 --> 00:40:54,509
goals, essentially. So, this particular example
is known as Sussman’s anomaly. If you

384
00:40:54,509 --> 00:41:01,679
just search on web, you will find this example.

385
00:41:01,679 --> 00:41:09,009
The interesting thing about this is that he
shows that, this kind of planning will not

386
00:41:09,009 --> 00:41:14,429
always work; well, work in the sense, without
doing this extra work, essentially; because

387
00:41:14,429 --> 00:41:26,239
we are serializing the sub goals, we also
call this as linear planning. I will achieve

388
00:41:26,239 --> 00:41:30,858
one
goal, then I will achieve the second goal,

389
00:41:30,858 --> 00:41:33,210
then I will achieve the third goal, and so
on; I

390
00:41:33,210 --> 00:41:39,889
will solve goals in a linear fashion, essentially.
So, I serialize the goals, essentially. What

391
00:41:39,889 --> 00:41:45,190
Sussman showed was that there are examples
where, you just cannot serialize the sub

392
00:41:45,190 --> 00:42:08,452
goals. The example is quite a simple one.
This is a start state; c is on a and a is

393
00:42:08,452 --> 00:42:20,739
on b. The
goal state is a on b on c, which is very similar

394
00:42:20,739 --> 00:42:30,889
to that, essentially. Let me just, for the
sake of illustration, call this d, to make

395
00:42:30,889 --> 00:42:35,278
it identical to the goal state that we just
looked at,

396
00:42:35,278 --> 00:42:41,309
which means, this whole exercise that we did,
will also hold for this. Of course, except

397
00:42:41,309 --> 00:42:49,788
for the start state is different, but the
main point is that I cannot think of two goals,

398
00:42:49,789 --> 00:42:56,119
achieve on a b, and achieve on b d. Goal stack
planning is forcing me to serialize the sub

399
00:42:56,119 --> 00:43:02,749
goals in some order, and what sussmans showed
was that you cannot serialize the sub

400
00:43:02,748 --> 00:43:03,748
.goals.

401
00:43:03,748 --> 00:43:14,699
Let us see what happens. So, let us say you
first, achieved on a b. I am not going to

402
00:43:14,699 --> 00:43:18,018
the
process, but we are just. To achieve on a

403
00:43:18,018 --> 00:43:20,068
b, what will you have to do? You will have
to

404
00:43:20,068 --> 00:43:26,710
pick up unstack this d from a, put it down
somewhere, then we will have pick up a, and

405
00:43:26,710 --> 00:43:30,760
stack it on to b; these four actions will
achieve on a b, and goal stack planning will

406
00:43:30,760 --> 00:43:35,020
do
that. You should try it as an exercise. So,

407
00:43:35,019 --> 00:43:47,838
a will be on b, and d will be on the; and
arm is

408
00:43:47,838 --> 00:43:55,038
empty, and then; that means, you have first,
done on a b, then you have to do on b d.

409
00:43:55,039 --> 00:44:01,489
Now, if you do achieve on b d, you can see
something very similarly, happening. You

410
00:44:01,489 --> 00:44:06,599
will unstack a from a; unstack a from this
stack, put it down from the table, pickup

411
00:44:06,599 --> 00:44:07,640
b and
stack it on to d.

412
00:44:07,639 --> 00:44:18,949
So, what would you get is d. 

413
00:44:18,949 --> 00:44:24,108
What we have shown in this example? As an
exercise, you

414
00:44:24,108 --> 00:44:30,289
should fill in the details and show how block,
this goal stack planning will actually, do

415
00:44:30,289 --> 00:44:34,318
this? When you first, achieve this, then you
achieved this. So, when you achieved this,

416
00:44:34,318 --> 00:44:38,019
this is true. When you achieved this, this
is true, but this is a goal, and this is not

417
00:44:38,019 --> 00:44:40,661
a goal
state, which means, to achieve this goal on

418
00:44:40,661 --> 00:44:43,318
a b and on b d, I cannot, at least, this order
is

419
00:44:43,318 --> 00:44:48,608
not correct of doing things. Of course, I
can do extra work; pick up this a and put

420
00:44:48,608 --> 00:44:52,858
it on d,
but that means, I am somehow missing the correct

421
00:44:52,858 --> 00:44:57,548
order, if there is one. What Sussman
shows was that there is no correct order.

422
00:44:57,548 --> 00:44:59,960
So, let us try the other order.

423
00:44:59,960 --> 00:45:07,369
You can achieve on b d first, which is very
simple. You just pick up b and stack on to

424
00:45:07,369 --> 00:45:13,360
d.
So, you have achieved on b d. Then, you achieve

425
00:45:13,360 --> 00:45:22,440
on a b. 
What happens; you have to

426
00:45:22,440 --> 00:45:28,159
unstack b, put it down; unstack d, put it
down; pick up a, put it on to b. So, you would

427
00:45:28,159 --> 00:45:42,859
get a b d. Again, you can see the other order
also, does not do the task. None of these

428
00:45:42,860 --> 00:45:44,390
two
paths leads to the goal, essentially. Of course,

429
00:45:44,389 --> 00:45:51,568
you can do extra work; that is a different
matter, but we cannot take these two goals

430
00:45:51,568 --> 00:45:55,519
individually, and say, I will solve the first
one, then I will solve the second one, and

431
00:45:55,519 --> 00:45:58,798
my task is done. I could do it here, if I
change

432
00:45:58,798 --> 00:46:04,369
the order of this goal. If I have done on
b d first, and then, on a b, then I would

433
00:46:04,369 --> 00:46:08,430
have
solved the task in a serial order, essentially.

434
00:46:08,429 --> 00:46:15,578
What Sussman showed was that there are
these non-serializable sub goals, essentially.

435
00:46:15,579 --> 00:46:29,930
That in many problems, goals are not
serialized with.

436
00:46:29,929 --> 00:46:43,088
.So, that is a problem with this kind of planning,
which we will also, call linear planning,

437
00:46:43,088 --> 00:46:46,989
because we are serializing the goals and saying,
I will do this first; and I will do this first;

438
00:46:46,989 --> 00:46:51,659
and so on. Of course, this is something that
we have observed earlier, in other situations.

439
00:46:51,659 --> 00:46:57,960
For example, when we talk about solving the
rubrics cube, then if you say I will do the

440
00:46:57,960 --> 00:47:02,849
top surface first, and then, the middle layer
and then, the lower surface and then, by the

441
00:47:02,849 --> 00:47:06,200
time you finished the top surface and while,
you are doing the middle layer, in the

442
00:47:06,199 --> 00:47:08,569
middle, you upset the top layer.

443
00:47:08,570 --> 00:47:13,460
Of course, those who know the solution know,
how to get it back, but that is like doing

444
00:47:13,460 --> 00:47:18,228
an extra work, essentially. So, rubrics cube
is the typical example of a goal, which is

445
00:47:18,228 --> 00:47:23,409
fundamentally, not serializable, like this
problem, which means that there is no way

446
00:47:23,409 --> 00:47:26,710
that
you can achieve the first goal, and not have

447
00:47:26,710 --> 00:47:33,179
to achieve it later again, essentially. Such
problems are called non serializable sub goals,

448
00:47:33,179 --> 00:47:38,028
essentially. So, in the next class, we will
look at an approach, which some people call

449
00:47:38,028 --> 00:47:53,309
as non-linear planning, which allows us the
possibility of solving this kind of a problem,

450
00:47:53,309 --> 00:48:02,380
optimally. What do I mean by that? That, if
you just think about this problem, this Sussman’s

451
00:48:02,380 --> 00:48:05,650
anomaly; the best way to solve it
follows.

452
00:48:05,650 --> 00:48:12,259
You unstack d, put it on the table; that is
two actions. Then you pick up b, put it, stack

453
00:48:12,259 --> 00:48:15,829
it
on to d; that is two more actions. Then, you

454
00:48:15,829 --> 00:48:21,390
pick up a, stack it on to b; that is six actions,
but neither of these paths is going to give

455
00:48:21,389 --> 00:48:26,469
a plan with six actions. Of course, they will
even eventually, achieve the goal, but this

456
00:48:26,469 --> 00:48:28,588
will have to do two more actions here, and
this

457
00:48:28,588 --> 00:48:35,170
will have to do at least four more actions
here, essentially. So, I cannot find optimal

458
00:48:35,170 --> 00:48:39,130
plan,
essentially. In the next class, we will look

459
00:48:39,130 --> 00:48:52,430
at an approach where, the possibility of
finding a optimal plan is kept open, essentially.

460
00:48:52,429 --> 00:48:57,078
You can see that; to find an optimal plan,
you have switch between goals, in some sense,

461
00:48:57,079 --> 00:49:07,720
that when you start by putting d on top of
a b. For example, when you start to do this,

462
00:49:07,719 --> 00:49:11,909
then when you put d; what you do? You
unstack d, and put it on the table, and you

463
00:49:11,909 --> 00:49:16,629
want to achieve a on ab. Then, you want to
certainly, realize that if you stack a on

464
00:49:16,630 --> 00:49:20,019
to b, you would not be able stack b on to
d. So,

465
00:49:20,018 --> 00:49:25,459
you abandon that goal of achieving on a b,
and switched to the other goal of achieving

466
00:49:25,460 --> 00:49:28,199
on
b d, in which case, of course, you will find

467
00:49:28,199 --> 00:49:32,189
optimal plan, but goal stack planning, because
it serializes the sub goals. It says, I will

468
00:49:32,190 --> 00:49:34,479
completely solve my first goal and then, go
to the

469
00:49:34,478 --> 00:49:37,259
second goal, is not able to do that, essentially.

470
00:49:37,259 --> 00:49:43,168
.So, we will stop here, and in the next class,
we will take up this non-linear planning.

471
00:49:43,168 --> 00:49:53,168
.

