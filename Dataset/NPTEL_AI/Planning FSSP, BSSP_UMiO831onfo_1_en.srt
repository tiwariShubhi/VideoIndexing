1
00:00:10,599 --> 00:00:21,189
So, we are looking at planning and in the
last class, we had looked at this language

2
00:00:21,189 --> 00:00:27,868
call
PDDL very briefly we are talked about this

3
00:00:27,868 --> 00:00:33,130
planning domain description language. And
we are looking only at the simplest version

4
00:00:33,130 --> 00:00:37,899
which we can say version 1.0 which equals
to

5
00:00:37,899 --> 00:00:53,929
the strips domain. In this simplest version
of the language actions are instantaneous

6
00:00:53,929 --> 00:00:57,760
the
world is deterministic, the world is completely

7
00:00:57,759 --> 00:01:03,179
observable, the goals are simple in the
sense that only goal state is look that a

8
00:01:03,179 --> 00:01:11,789
nothing else. And the agent is only 1 whose
changing the world, but we took the first

9
00:01:11,790 --> 00:01:15,350
steps towards rejoining. A when we if starts
talking about the language like this planning

10
00:01:15,349 --> 00:01:18,949
domain description language. We are
talking about representation how to represent

11
00:01:18,950 --> 00:01:23,810
domains how to represent actions? So
typically if you will look at the periodical

12
00:01:23,810 --> 00:01:26,490
document you would say they who start of the
defining domain.

13
00:01:26,489 --> 00:01:29,920
So, the domain that we are looking at is the
blocks world domain so you would say

14
00:01:29,920 --> 00:01:37,968
domain name is blocks world the predicates
or on table holding. And all those predicates

15
00:01:37,968 --> 00:01:45,919
and some of the actions we saw. So, let me
the couple of the actions 

16
00:01:45,920 --> 00:01:54,789
stack 
x on y and the

17
00:01:54,789 --> 00:02:03,490
.pre conditions are thus set of predicates
which must hold further action to be applicable.

18
00:02:03,489 --> 00:02:16,699
And the p conditions first stack was on x
y then clear y and arm empty. So a is stands

19
00:02:16,699 --> 00:02:20,459
for
arm empty will use the short form. So, if

20
00:02:20,460 --> 00:02:23,189
x is on y so of x and y have variables here
in

21
00:02:23,189 --> 00:02:27,829
the operate us, but when we actually talk
about domain they will get bound to constance

22
00:02:27,830 --> 00:02:34,440
which stand for specific blocks like a and
b and c and so on. So, if x is on y and y

23
00:02:34,439 --> 00:02:47,120
is sorry
somebody should a point of this off. It should

24
00:02:47,120 --> 00:03:08,680
be holding x if a holding x and y clear then
you can stack x on y. And the effects 

25
00:03:08,680 --> 00:03:20,330
positive are on x y and arm empty and the
effects

26
00:03:20,330 --> 00:03:37,320
negative are holding x and clear y. There
were one more positive effect which is you

27
00:03:37,319 --> 00:03:47,680
can
add as clear x. This is not precisely that

28
00:03:47,680 --> 00:03:52,840
the syntax with periodical uses, periodical
uses

29
00:03:52,840 --> 00:03:57,270
less like’s intakes so everything is in
brackets.

30
00:03:57,270 --> 00:04:01,760
And you say if x then positive effects then
negative effects are actually a continuation

31
00:04:01,759 --> 00:04:04,620
of
positive effects with a not prefix, but will

32
00:04:04,620 --> 00:04:07,980
use this simpler notation here essentially.
So,

33
00:04:07,979 --> 00:04:16,129
basically operators or actions are represented
by these 3 kinds of things 1 is set of p

34
00:04:16,129 --> 00:04:22,319
conditions holding x clear y for example,
and then the effects so what the effects?

35
00:04:22,319 --> 00:04:27,279
Effects
are what are the changes that this operator

36
00:04:27,279 --> 00:04:32,379
makes in the world if that operators in the
world executed. So, what we a saying here

37
00:04:32,379 --> 00:04:40,370
is that stack x y is possible when you are
holding x and y is clear. And if you executes

38
00:04:40,370 --> 00:04:44,189
stack x y then x will be on y the arm will
be

39
00:04:44,189 --> 00:04:50,161
empty. Because you would have draft x some
sense and x would be clear and this will no

40
00:04:50,161 --> 00:04:57,750
long be true that you a holding x and clear
y essentially. Similarly, we have define

41
00:04:57,750 --> 00:05:17,479
unstack x y which is a inverse of this so
the pre conditions are on x y arm empty and

42
00:05:17,480 --> 00:05:25,009
clear x.
So, if you x is on y and arm is empty which

43
00:05:25,009 --> 00:05:28,670
means robot arm is not holding anything
remember we are talking about 1 arm robot

44
00:05:28,670 --> 00:05:37,060
which is moving blocks around. And clear x
which means nothing is on top of x essentially

45
00:05:37,060 --> 00:05:53,389
then the effects positive are holding. So,
you can see here there is a kind of a association

46
00:05:53,389 --> 00:06:11,889
will that clear y and the effects negative
all these things on x y arm empty and clear

47
00:06:11,889 --> 00:06:15,480
x. So, in this version I have add clear x
go to

48
00:06:15,480 --> 00:06:23,379
effects here and there so if you add it here
universe as it in this also yes in that earlier.

49
00:06:23,379 --> 00:06:33,449
So, as a say this is a simplest version of
period l or period l 1.0 on which actions

50
00:06:33,449 --> 00:06:38,819
in sent
an yes and the other effects let we talked

51
00:06:38,819 --> 00:06:45,620
about. So, just before you move on to the
planning of it us let me illustrate a couple

52
00:06:45,620 --> 00:06:50,810
of riches language construct essentially.

53
00:06:50,810 --> 00:06:55,589
.(Refer Slide Time: 07:00)

54
00:06:55,589 --> 00:07:08,429
So, one thing which a richer language you
to apply is called conditional effects. So,

55
00:07:08,430 --> 00:07:21,740
conditional effects are effects which are
which come in to force only if certain conditions

56
00:07:21,740 --> 00:07:26,918
are true essentially. So, as an example of
conditional effects let say that you have

57
00:07:26,918 --> 00:07:33,479
a
domain in which you are talking about moving

58
00:07:33,480 --> 00:07:38,680
objects around and so on and so forth and
you have trucks and you have this kind of

59
00:07:38,680 --> 00:07:52,050
thing. And you want to move let say 1 table
from location a to location b. And you define

60
00:07:52,050 --> 00:08:03,800
move truck action which says the truck
goes from location let us say x to location

61
00:08:03,800 --> 00:08:08,900
y. And the conditional affects of that a that
if

62
00:08:08,899 --> 00:08:13,620
there is any object in that truck then that
object also moves from location next to

63
00:08:13,620 --> 00:08:23,918
essentially. Or if you look of the something
like a briefcase domain, so if a briefcase

64
00:08:23,918 --> 00:08:35,110
goes from location x to location y.
So, let us say you have bag that you carry

65
00:08:35,110 --> 00:08:40,110
from department to hostel then if there is
a

66
00:08:40,110 --> 00:09:01,990
book a conditional effect will say if z is
in briefcase then z goes to location y. So,

67
00:09:01,990 --> 00:09:04,610
and
was writing it in sort of semi English, but

68
00:09:04,610 --> 00:09:13,039
the basic idea is that the act of moving a
briefcase from location x to y has conditional

69
00:09:13,039 --> 00:09:17,448
effect within the sense that whatever inside
the briefcase we will also get move to the

70
00:09:17,448 --> 00:09:20,778
target location essentially. Of course, in
this

71
00:09:20,778 --> 00:09:25,240
there is no sustain the effects are determines
stack an every action very clearly well

72
00:09:25,240 --> 00:09:32,709
defined effects essentially, but that said
is a language. Another feature which a richer

73
00:09:32,708 --> 00:09:45,458
language is have a durative actions which
are been explore quit a lot now a days. So,

74
00:09:45,458 --> 00:09:49,588
as
we said in the last class strips actions of

75
00:09:49,589 --> 00:09:52,360
periodical one action have no concept of time
in

76
00:09:52,360 --> 00:09:57,089
world at all and that is, because actions
a in sententious.

77
00:09:57,089 --> 00:10:01,759
.So, if you a taking up a object or putting
down a object was stacking in object and

78
00:10:01,759 --> 00:10:06,110
stacking in object we just assume that it
happens in sent essentially. And then once

79
00:10:06,110 --> 00:10:08,470
a
action happened it is the effects a seen immediately

80
00:10:08,470 --> 00:10:13,428
essentially. But in the real world of
course, actions are not in sententious. If

81
00:10:13,428 --> 00:10:15,799
you go from here to the hostel it will take
a

82
00:10:15,799 --> 00:10:19,819
certain amount of time from go from here to
the hostel so that must be a taken in to

83
00:10:19,820 --> 00:10:36,150
account. So, durative actions are represented
by durations or intervals so this is a start

84
00:10:36,149 --> 00:10:44,889
of
the action and this are the end of the action.

85
00:10:44,889 --> 00:10:51,490
So, for example, we consider this action of
going from here to the hostel then the actions

86
00:10:51,490 --> 00:10:56,509
start at a certain time t and it has a certain
duration so there is certain amount of time

87
00:10:56,509 --> 00:11:01,759
t
that is this action takes. Now, this time

88
00:11:01,759 --> 00:11:05,178
t could be constant or it could be a variable
for

89
00:11:05,178 --> 00:11:09,399
example, move action in the real world go
from the here to the hostel it will take you

90
00:11:09,399 --> 00:11:11,389
10
minutes. You go from here to the department

91
00:11:11,389 --> 00:11:15,419
it will take you 5 minutes you will go from
here to the gate it may take you 15 minutes.

92
00:11:15,419 --> 00:11:23,769
So duration could be dynamic in that sense
essentially and so this is a start of the

93
00:11:23,769 --> 00:11:25,259
action this is the end of the action. So,
the action is

94
00:11:25,259 --> 00:11:29,459
define over a duration and such search planning
domains a called durative such actions a

95
00:11:29,458 --> 00:11:38,719
called durative actions. And what you have
is that you have start conditions or lets

96
00:11:38,720 --> 00:11:41,949
use a
term p condition at of you is using and then

97
00:11:41,948 --> 00:11:51,698
starts effects.
And you have end conditions 

98
00:11:51,698 --> 00:12:00,299
and you have end effects so what will meaning
by this?

99
00:12:00,299 --> 00:12:11,448
That let say let you want to go from here
to a lab on the department and we have defined

100
00:12:11,448 --> 00:12:17,069
an action for that. So, the start 3 condition
as you should be here and may be you have

101
00:12:17,070 --> 00:12:19,449
a
bicycle or something what is, whatever is

102
00:12:19,448 --> 00:12:21,938
other 3 condition that we have here, what
are

103
00:12:21,938 --> 00:12:26,498
the start effects? Start effects are the effect
which comes into play as soon as actions

104
00:12:26,499 --> 00:12:30,449
begin. So, the moment is start going towards
the lab your are no long a here essentially.

105
00:12:30,448 --> 00:12:36,738
So, that is a starts negative effect essentially
what are the end effects? End 3 end may

106
00:12:36,739 --> 00:12:41,459
have 3 conditions so 3 conditional could be
the for example, this a lab is opened that

107
00:12:41,458 --> 00:12:45,159
is
the lab is open at this point of time then

108
00:12:45,159 --> 00:12:48,328
the action will execute correctly. And the
end

109
00:12:48,328 --> 00:12:53,539
effects could be you could be inside the lab
or something like that. And then we have

110
00:12:53,539 --> 00:13:13,919
overall conditions which have predicate which
was being true throughout the action.

111
00:13:13,919 --> 00:13:20,318
So, supposing you are cycling from here to
some place then the overall condition could

112
00:13:20,318 --> 00:13:25,169
be said that all points your cycle has enough
air. It is in so if the condition fails any

113
00:13:25,169 --> 00:13:28,328
time
then the action wills no longer work. Now,

114
00:13:28,328 --> 00:13:34,099
as you can imagine once you start working
about durative actions then things become

115
00:13:34,100 --> 00:13:35,778
much more complicated. You have to talk

116
00:13:35,778 --> 00:13:42,159
.about start effects start conditions end
effects end conditions overall effects, overall

117
00:13:42,159 --> 00:13:45,350
conditions and so and so for. So listening
becomes much more complicated and you can

118
00:13:45,350 --> 00:13:53,659
imagine that 1 action may be like this another
action may happen like this. And then

119
00:13:53,659 --> 00:13:58,509
there are different kinds of relations between
these intervals that you have to explore.

120
00:13:58,509 --> 00:14:09,339
And there is a well define study about it
Aliens interval algebra which basically looks

121
00:14:09,339 --> 00:14:13,589
at
all the relation between which 2 time intervals

122
00:14:13,589 --> 00:14:19,529
can have or 2 interval can have their does
not want to be time. So, this is for example,

123
00:14:19,528 --> 00:14:23,178
saying that a second interval begins before
the first interval. Hence and you can imagine

124
00:14:23,178 --> 00:14:27,558
that a there are many different possibilities.
They can happen simultaneously 1 can second

125
00:14:27,558 --> 00:14:31,600
one can start immediately after the first
one or the second one can be contain totally

126
00:14:31,600 --> 00:14:38,909
in the first one or second one can totally
contain the first one. So, in there are 13

127
00:14:38,909 --> 00:14:42,169
such intervals and then there is an talks
about

128
00:14:42,169 --> 00:14:50,628
these thing with a intervals we will not get
into to this here. The third that is often

129
00:14:50,629 --> 00:15:02,600
introduced is found is like metric values.
So, these are numerical values which can take

130
00:15:02,600 --> 00:15:13,589
different values and to take an ex to illustrate
an example here. It could be that inside of

131
00:15:13,589 --> 00:15:21,279
bicycle let us say you using a motor cycle.
Then one of the things that you will need

132
00:15:21,278 --> 00:15:23,558
one
of the condition that you will need is that

133
00:15:23,558 --> 00:15:29,578
at all points you must have certain amount
petrol essentially. So, this metric values

134
00:15:29,578 --> 00:15:34,399
would keep track of amount of the petrol that
you have in a your motor cycle. And it could

135
00:15:34,399 --> 00:15:39,548
say something like if you have ex amount
of petrol at the start then at the end of

136
00:15:39,548 --> 00:15:41,809
action you will have x minus some k amount
of

137
00:15:41,809 --> 00:15:47,599
petrol. So, that is a end effect that is they
were abreaction and that introduces a third

138
00:15:47,600 --> 00:15:52,459
dimension which is that of continues numerical
values essentially. But we will in this

139
00:15:52,458 --> 00:15:58,738
course not look at these richer domains and
focus more on the basic planning which is

140
00:15:58,739 --> 00:16:01,739
done using the strips periodical can of a
domain essentially.

141
00:16:01,739 --> 00:16:05,179
.(Refer Slide Time: 16:08)

142
00:16:05,178 --> 00:16:26,170
So, we had define something’s we at said
that an action A is applicable if thus anyone

143
00:16:26,171 --> 00:16:35,699
remember the pre conditions of A so will use
this as a predicate. This stands of a

144
00:16:35,698 --> 00:16:44,488
conditions of A so this basically stands this
set you is a subset of S. So we should say

145
00:16:44,489 --> 00:16:54,129
applicable in state s. So, with this planning
as you will notice we have set of making a

146
00:16:54,129 --> 00:17:00,201
gradual transaction into representation. So,
for we did things like search, but you do

147
00:17:00,201 --> 00:17:02,540
not
bother about representation. Now, we a talking

148
00:17:02,539 --> 00:17:06,949
about how to represent a domain, how to
represent actions and also we have keeping

149
00:17:06,949 --> 00:17:11,250
the reasoning part in mind. And the
reasoning part is at least to start with will

150
00:17:11,250 --> 00:17:17,329
be the same kind of reasoning which is
searching for solutions essentially. So, because

151
00:17:17,329 --> 00:17:21,629
we have this explicitly representations we
can talk about this kind of rule conditions.

152
00:17:21,630 --> 00:17:29,620
So, an action A is applicable in state s if
the p conditions of a all the subset of s

153
00:17:29,619 --> 00:17:44,439
essentially. Likewise we say a goal so when
we say goal g we essentially mean a set of

154
00:17:44,440 --> 00:17:48,990
predicates that we want to be true. So, for
example, today we look at an example may

155
00:17:48,990 --> 00:18:07,400
goal is the following 1 A B and on B B. Let
a say hich stands for the fact that A is on

156
00:18:07,400 --> 00:18:12,399
B
and B is on B in the blocks for domain. So

157
00:18:12,398 --> 00:18:18,419
this thing is the goal essentially and this
comma is to be in it is and which means at

158
00:18:18,420 --> 00:18:21,409
both the things must be true A must be on
B

159
00:18:21,409 --> 00:18:29,139
and B must be on D essentially. So, goal is
basically a partial description of a state

160
00:18:29,138 --> 00:18:33,009
that
you want to be in of the desire state essentially.

161
00:18:33,009 --> 00:18:52,038
So, we say that the goal g such so let say
a state S satisfies a goal g remember both

162
00:18:52,038 --> 00:18:57,250
of these are sets of predicates. A state is
for

163
00:18:57,250 --> 00:19:02,759
.example, what is true in the world on A on
B on C whatever likewise goal is what you

164
00:19:02,759 --> 00:19:09,240
want to be true in the world essentially.
So, use a word goal a satisfies a state satisfies

165
00:19:09,240 --> 00:19:22,099
a goal g. If in the representation that we
have use g is the subset of the S. So, you

166
00:19:22,099 --> 00:19:25,668
can see that this can be use to define the
goal

167
00:19:25,669 --> 00:19:29,399
test function that have be reach the goal
or not. We are working its simple goals here

168
00:19:29,398 --> 00:19:31,298
and
we want to see whether we have reach the state

169
00:19:31,298 --> 00:19:36,980
which is the goal or not. Then this can be
used to test for that essentially whether

170
00:19:36,980 --> 00:19:47,740
action a is applicable we can define a function
call progress 

171
00:19:47,740 --> 00:19:56,960
let say in a state S using an action A and
what this progress does is an a

172
00:19:56,960 --> 00:20:03,639
takes a state s and applies they action A.
And gives you a new state explain were explain

173
00:20:03,638 --> 00:20:17,008
as is on the last class this S minus the negative
effects of A union the positive effects of

174
00:20:17,009 --> 00:20:26,381
A. So, we have a progress function which allows
it a move from one states to next state

175
00:20:26,381 --> 00:20:31,139
essentially. So, we have basically the machinery
for doing state space search here we can

176
00:20:31,138 --> 00:20:35,079
test whether than action is applicable in
a state on a not by using this applicability

177
00:20:35,079 --> 00:20:38,859
test.
We can progress from the state to the next

178
00:20:38,859 --> 00:20:43,658
state so in the in effect we have done the
move gen function. By if we just select all

179
00:20:43,659 --> 00:20:45,320
the actions which applicable in the state
we

180
00:20:45,319 --> 00:20:51,558
have the move gen function and then we have
the goal test function here which says that

181
00:20:51,558 --> 00:20:58,569
you can test for the S on goal is not essentially.
So, forward state space search essentially

182
00:20:58,569 --> 00:21:04,349
does the kind of the search set we have in
talking about. So, let me give you a so a

183
00:21:04,349 --> 00:21:23,428
planning problem 
is define by a start is as before a goal so

184
00:21:23,429 --> 00:21:32,649
start s let us call it goal g and
a set of actions essentially. So, obviously

185
00:21:32,648 --> 00:21:36,079
we have define the domain using a language
an

186
00:21:36,079 --> 00:21:39,519
having define the domain in the define in
we have define the set of actions of the

187
00:21:39,519 --> 00:21:44,730
possible domain. And a specific problem is
when we have define the starts at s a goal

188
00:21:44,730 --> 00:21:47,450
say
g and the set of actions that a available

189
00:21:47,450 --> 00:21:50,230
to you defines which can be use to go from
start

190
00:21:50,230 --> 00:21:54,960
to goal; essentially. So, let us that is assume
that we have some simple domain.

191
00:21:54,960 --> 00:22:05,450
So, we want that A B and D so let a say a
given starts it is the following A is on B

192
00:22:05,450 --> 00:22:10,630
lets
say this is on the table. And let a say C

193
00:22:10,630 --> 00:22:29,639
is on D and then E is on the table Ff is on
the

194
00:22:29,638 --> 00:22:42,439
table. Some arbitrary starts seat I have given
so let us say this is a start and that is

195
00:22:42,440 --> 00:22:45,101
a goal
say that you want to achieve which is that

196
00:22:45,101 --> 00:22:58,420
A should be on B and B should be on D
essentially. So, again that we repeat that

197
00:22:58,420 --> 00:23:07,860
is a goal is a description and the description
may

198
00:23:07,859 --> 00:23:13,589
be true in many states as you can imagine.
If you just have this a on b on d then the

199
00:23:13,589 --> 00:23:17,459
rest
of blocks will be available in any way and

200
00:23:17,460 --> 00:23:22,288
as long as those 2 predicates on A B and on
B

201
00:23:22,288 --> 00:23:27,259
B or there in the state. That state is the
goal says that is what you have said here

202
00:23:27,259 --> 00:23:28,259
that a

203
00:23:28,259 --> 00:23:36,440
.state S satisfies the goal g if g is the
subset of S. Now, we want to do this planning

204
00:23:36,440 --> 00:23:39,769
and
we start with forward state space search.

205
00:23:39,769 --> 00:23:51,089
Because that is ((refer time 23:41)) familiar
with.

206
00:23:51,089 --> 00:23:56,789
So, how it forward state space search? To
gets is exactly like space search that we

207
00:23:56,789 --> 00:23:59,470
have
to been talk to about so far, that given a

208
00:23:59,470 --> 00:24:08,519
start state S. You can apply many actions
and so

209
00:24:08,519 --> 00:24:12,900
inside of writing the actions let me that
the action was saying by using this arrows.

210
00:24:12,900 --> 00:24:16,950
So,
this arrow says that I am unstack A from B

211
00:24:16,950 --> 00:24:20,940
that is one action I can apply I can unstack
C

212
00:24:20,940 --> 00:24:29,850
from D, I can unstack F from E, I can unstack
I from H is I can pick up. If you remember

213
00:24:29,849 --> 00:24:34,898
there a 4 actions we talked about stack unstack
and pick up and put down. The only

214
00:24:34,898 --> 00:24:40,459
different between pick up and unstack is it
unstack happens from another block and pick

215
00:24:40,460 --> 00:24:47,590
up happens from the table. So, just we will
a says how to use different action and this

216
00:24:47,589 --> 00:24:58,099
one? So, the move gen function in this particular
state would generate these actions 1 2 3

217
00:24:58,099 --> 00:25:03,129
4 5 6 7 actions. And your first algorithm
will have to take one of them essentially.

218
00:25:03,130 --> 00:25:08,190
Let
say it picks this action for some reason now,

219
00:25:08,190 --> 00:25:16,000
what is the situation? A situation is that
this

220
00:25:16,000 --> 00:25:21,778
rubato is holding this block K that say it
pick this action.

221
00:25:21,778 --> 00:25:27,798
It is the now, holding this block K everything
else it is the change so how do we define

222
00:25:27,798 --> 00:25:33,798
this new state? Define it by doing this progress
action which says that if I am doing this

223
00:25:33,798 --> 00:25:41,418
unstack K J action I must apply this I must
remove the negative effects of A. The

224
00:25:41,419 --> 00:25:48,070
negative effects of unstack that ex so on
by in this case x is K on y is J. So, K J

225
00:25:48,069 --> 00:25:50,700
is no
longer true, on K J is no longer true; arm

226
00:25:50,700 --> 00:25:57,870
empty is no longer true, because you are
holding K. And clear x which is K is no longer

227
00:25:57,869 --> 00:26:04,529
true and then I must add the positive
effects of this action. The positive effects

228
00:26:04,529 --> 00:26:06,869
of the action he has it has A holding it and
wise

229
00:26:06,869 --> 00:26:12,308
clear. So, this effect would be present at
fact you have holding K and. Because you have

230
00:26:12,308 --> 00:26:17,148
lifted it K away from this j will become clear
so clear j will be added to the state. So,

231
00:26:17,148 --> 00:26:20,079
that
is the progress action that you have to implement

232
00:26:20,079 --> 00:26:31,639
to get this new state K. Now, you can
see that having done this action these actions

233
00:26:31,640 --> 00:26:42,440
are still applicable sorry actually they are
not. But they would become applicable the

234
00:26:42,440 --> 00:26:47,210
moment arm becomes empty this moment is
arm is not empty arm is holding K.

235
00:26:47,210 --> 00:26:53,798
So, you do only action you can do with this
one arm robo unfortunately super case some

236
00:26:53,798 --> 00:26:57,950
were either put it on the table or put it
on the one of the block. From this we can

237
00:26:57,950 --> 00:27:02,890
illustrate
by saying that from here the actions are either

238
00:27:02,890 --> 00:27:06,580
put it on this are either put it either put
it

239
00:27:06,579 --> 00:27:12,418
on this and so on and so. So, I will have
a clause a state space here it 2 difficult

240
00:27:12,419 --> 00:27:13,419
to draw,

241
00:27:13,419 --> 00:27:18,490
.but you basic you gt the basic idea that
you move from state to state. And whichever

242
00:27:18,490 --> 00:27:22,589
state you looking at you affair the move gen
function which is looking for all the actions

243
00:27:22,589 --> 00:27:31,878
which are applicable pick one of them and
move forward essentially. So, this

244
00:27:31,878 --> 00:27:37,548
representation mechanism allows a rule of
overall search you have doing which was we

245
00:27:37,548 --> 00:27:41,359
listen even name to it. We are not is that
given a name to this we have only set forward

246
00:27:41,359 --> 00:27:44,609
stack space search, because we have not talked
about what does strategy is now you

247
00:27:44,609 --> 00:27:51,808
could do that first search or you could do
or you could even do did or some something

248
00:27:51,808 --> 00:27:57,819
like that. You could do anything that we were
doing here essentially so what is the

249
00:27:57,819 --> 00:28:06,769
difficulty with this? What is the drawback
of forward stack space search?

250
00:28:06,769 --> 00:28:16,710
If you look at this given start state and
that given goal state can you observe what

251
00:28:16,710 --> 00:28:19,690
this is
doing wrong? And when you make this observation

252
00:28:19,690 --> 00:28:23,080
you must keeping mind that you are
not solving the only the blocks whole problem.

253
00:28:23,079 --> 00:28:28,599
We are writing this as a generic
algorithm of a our stack space search in which

254
00:28:28,599 --> 00:28:33,829
we can plug in the domain with all it set
of action on a operators and all the predicate

255
00:28:33,829 --> 00:28:41,990
it is not goal riven essentially. And in fact,
you look at the I properly drawn this like

256
00:28:41,990 --> 00:28:44,940
this, because the 3 blocks A B and D that
you

257
00:28:44,940 --> 00:28:49,820
want in the goal to be true or here in the
left hand side. And this right hand side is

258
00:28:49,819 --> 00:28:53,750
actually will does not care not of course
the real world is like that if you are let

259
00:28:53,750 --> 00:28:58,138
us say
planning for yourself what to do next? Then

260
00:28:58,138 --> 00:29:02,199
if you what simply try to describe what is
true at this moment in IIT.

261
00:29:02,200 --> 00:29:10,440
You would have 100 in 1000 of statements in
something who is there in the office, who

262
00:29:10,440 --> 00:29:15,038
is there in the lab, who is there in the canteen
what is happening in this class is going on

263
00:29:15,038 --> 00:29:19,908
their this class is going on 100 in 1000 of
statements. You would have and then you 100

264
00:29:19,909 --> 00:29:26,570
of 1000 actions would be possible essentially
when we look at this particular problem we

265
00:29:26,569 --> 00:29:32,720
can see that is no point in picking up A or
I or K or L or M. Because they are all go

266
00:29:32,720 --> 00:29:34,470
on to
help us achieve the goal where as something

267
00:29:34,470 --> 00:29:44,999
should be done on this part essentially. So,
the problem is forward stack space search

268
00:29:44,999 --> 00:29:49,269
and this arises from the fact that state
description can be large, the number of applications

269
00:29:49,269 --> 00:30:02,620
can be large is that there is a large
branching factor. The number of actions which

270
00:30:02,619 --> 00:30:11,058
are applicable in any given state is thus
too many to we consider by a grout force approach

271
00:30:11,058 --> 00:30:14,288
and that is true in any real world
situations value essentially.

272
00:30:14,288 --> 00:30:16,408
.(Refer Slide Time: 30:22)

273
00:30:16,409 --> 00:30:30,778
How do we address this problem? One approach
is heuristic search and that is something

274
00:30:30,778 --> 00:30:35,869
you will again not explore in this course.
Because we do not have enough time and you

275
00:30:35,869 --> 00:30:41,959
have most welcome to come for the planning
course you entrance it. And when we talk

276
00:30:41,960 --> 00:30:48,269
of heuristic search here we are not talking
in a domain independent fashion. Earlier we

277
00:30:48,269 --> 00:30:53,359
said for this 8 puzzle this is a heuristic
you can use of a blocks world. This is a heuristic

278
00:30:53,359 --> 00:30:57,168
you can use you have number of blocks which
are in the correct place. And that kind of

279
00:30:57,169 --> 00:31:01,990
staff, but we are we do not want to define
you the 6 domain dependent fashion. We are

280
00:31:01,990 --> 00:31:07,519
interested in talking about domain independent
fashions. And the idea of domain

281
00:31:07,519 --> 00:31:13,909
independent heuristic is to solve simpler
problems essentially. And the approach that

282
00:31:13,909 --> 00:31:19,360
we
use in planning is to solve the, what we called

283
00:31:19,359 --> 00:31:37,089
is the relaxed?
So one approach is to solve the relax planning

284
00:31:37,089 --> 00:31:41,378
problem and what why mean by that? I
mean that if I am in a start stage S and I

285
00:31:41,378 --> 00:31:55,548
have all these possible moves from these stages
that is call them S 1 S 2 S 3 S 4 S 5. Then

286
00:31:55,548 --> 00:32:02,579
I solve a relax planning problem going from
this S 1 to goa1l and S 2 to goal and S 3

287
00:32:02,579 --> 00:32:06,428
to goal and S 4 to goal and S 5 to goal. Look
at

288
00:32:06,429 --> 00:32:12,821
the solution produce by this relaxed or as
the solution is call the relax plan. Look

289
00:32:12,820 --> 00:32:16,689
at the
relax plan and see which is the cheapest relax

290
00:32:16,690 --> 00:32:22,330
plan may be in terms of number of moves.
So, if S 2 is given in the cheap cheapest

291
00:32:22,329 --> 00:32:24,368
relaxed plan then I will say I am going to
make

292
00:32:24,368 --> 00:32:29,128
this move from S 1 to S 2 exactly like in
the heuristic search that we said earlier.

293
00:32:29,128 --> 00:32:31,269
We said
that we will apply the heuristic function

294
00:32:31,269 --> 00:32:34,278
to all these things and choose the 1 with
sees to

295
00:32:34,278 --> 00:32:42,230
be closes to the goal. Except that here we
are literally applying us problem solving

296
00:32:42,230 --> 00:32:47,319
.strategy to solve from each of this positions
to go to the goal. And the seeing which one

297
00:32:47,319 --> 00:32:50,648
seen which is which one seems to be close
to the goal.

298
00:32:50,648 --> 00:32:58,678
Now, the first question arises to that you
would ask is that computing the heuristic

299
00:32:58,679 --> 00:33:03,798
functions should not be as expensive as solving
the original grout force problem.

300
00:33:03,798 --> 00:33:08,269
Because that is the case and what is what
is advantages of grout basic function is giving

301
00:33:08,269 --> 00:33:13,220
you in the heuristic function that here seen
so for the domain dependent heuristic

302
00:33:13,220 --> 00:33:17,990
functions. We had said that it is a static
function you only look at a state and do a

303
00:33:17,990 --> 00:33:22,769
computation of a value. So for example, you
do it leaden distance or as we set the

304
00:33:22,769 --> 00:33:29,839
number of blocks and so on so they are they
were cheap. In this case, we same the relax

305
00:33:29,839 --> 00:33:33,970
problem in a such a way that it is a easy
problem to solve which means computationally

306
00:33:33,970 --> 00:33:39,919
easy to solve and when we say computationally
easy time. So if each of the, these states

307
00:33:39,919 --> 00:33:45,750
can be solve can be foes as a relax planning
problem and it can be solve in palynology

308
00:33:45,750 --> 00:33:50,849
time. Then we will just have now, K times
that time polynomial time will be able to

309
00:33:50,849 --> 00:33:56,209
decide on which 1 to use here.
So, remember we at said that the even in this

310
00:33:56,210 --> 00:34:04,038
simple domain planning is hard in fact its
p’s space complete which means it requires

311
00:34:04,038 --> 00:34:12,789
polynomial space and time. And here we us
trying to say that we will solve a simpler

312
00:34:12,789 --> 00:34:14,619
problem, but try to estimate which of them
is

313
00:34:14,619 --> 00:34:21,329
closer to the goal. And notice that this is
being done independent fashion how to be do

314
00:34:21,329 --> 00:34:36,069
this? The relax planning problem is basically
says ignore the negative effects of actions

315
00:34:36,070 --> 00:34:40,820
and those are called relax actions. So, I
just ignore this part essentially and then

316
00:34:40,820 --> 00:34:43,289
you can
see that if you that visualize this become

317
00:34:43,289 --> 00:34:50,230
monotonic situation. You keep adding new
predicates to the start set you are not deleting

318
00:34:50,230 --> 00:34:54,510
any predicates the complexity of planning
comes. Because you are deleting things that

319
00:34:54,510 --> 00:35:02,680
you pick up K from J K is no longer on J
essentially. But if I am living on K J relax

320
00:35:02,679 --> 00:35:05,069
plan then I monotonically increasing the set
of

321
00:35:05,070 --> 00:35:09,380
predicates. And at some point I will get those
to predicates in said my said. And then I

322
00:35:09,380 --> 00:35:10,670
will say have solve all the relax planning
problem.

323
00:35:10,670 --> 00:35:15,119
So, it terms out you should take my word for
it that solving relax planning problems

324
00:35:15,119 --> 00:35:20,480
when the effects negative effects are ignore
is polynomial time essentially. And heuristic

325
00:35:20,480 --> 00:35:28,159
search essentially uses that approach. There
are 1 or 2 other ways to compute heuristic,

326
00:35:28,159 --> 00:35:38,399
but we will not going that what you will do
instead is to focus on doing what we call

327
00:35:38,400 --> 00:35:50,130
is a
back word search. We are already works some

328
00:35:50,130 --> 00:35:54,480
exposure to backward reasoning we said
that ((refer time 35:53)) for example, (refer

329
00:35:54,480 --> 00:35:57,170
time 35:36)) and goal trees that you work

330
00:35:57,170 --> 00:36:03,000
.from goals back words. But they the representation
was tailor to backward reasoning that

331
00:36:03,000 --> 00:36:08,010
we said that this is how you decompose a given
goal into sub goals. And then that is a

332
00:36:08,010 --> 00:36:13,160
goals into more sub goals and eventually you
have trivially sub goals to solve. Here we

333
00:36:13,159 --> 00:36:20,069
are not changing the representation, but we
want to back ward reasoning. So, we need a

334
00:36:20,070 --> 00:36:25,700
few things know again we have to so this machinery
will no longer we have applicable.

335
00:36:25,699 --> 00:36:27,299
(Refer Slide Time: 36:30)

336
00:36:27,300 --> 00:36:45,630
We talk about something called relevant actions.
So we say an action A is relevant for a

337
00:36:45,630 --> 00:36:54,730
goal g this is an some sense applicable actions.
In forward stack space search actions are

338
00:36:54,730 --> 00:37:01,869
applicable in a given state in backwards search
back ward we use a terms stack space

339
00:37:01,869 --> 00:37:08,239
search here again. Actions are applicable
to goal descriptions and we say that in action

340
00:37:08,239 --> 00:37:12,779
A
is relevant for goal g if the following is

341
00:37:12,780 --> 00:37:26,111
true let me write. If you the effects plus
of A and

342
00:37:26,110 --> 00:37:37,509
g is not equal to 5 that an action has a effect
which is required in the goal to be true

343
00:37:37,510 --> 00:37:41,180
which mean so what you have simply saying
is that the inter section of the positive

344
00:37:41,179 --> 00:37:45,230
effects of the action and goal must not be
empty. It must produce something which is

345
00:37:45,230 --> 00:37:49,159
relevant for the goal then we say action A
is the relevant. But is another thing you

346
00:37:49,159 --> 00:37:56,899
want
which is that effects minus of A 1 must be

347
00:37:56,900 --> 00:38:02,420
equal to 5. There it not produces any negative
effects which you want in the goal to be true.

348
00:38:02,420 --> 00:38:10,519
Remember what does the goal is the set of
predicate set a want to be cube.

349
00:38:10,519 --> 00:38:14,739
And you are looking for actions which will
achieve the goal essentially. So, we say that

350
00:38:14,739 --> 00:38:25,500
an action A is relevant to A goal if the positive
effects of the a has something for the goal

351
00:38:25,500 --> 00:38:29,969
.which means intersection was goal is not
empty and the negative effects of the a is

352
00:38:29,969 --> 00:38:35,009
empty
essentially. So, we now, 2 predicates in a

353
00:38:35,010 --> 00:38:40,580
goal and you can see that we 2 actions are
relevant essentially. And you tell me what

354
00:38:40,579 --> 00:38:53,489
were the 2 actions? So I have moving from
goal to sub goal now, I am saying that if

355
00:38:53,489 --> 00:38:55,939
I want this to be achieved and if this is
my last

356
00:38:55,940 --> 00:39:01,010
action then I will achieve it. But only I
am use I am only using this definition of

357
00:39:01,010 --> 00:39:07,240
relevancy essentially I am not any deep reasoning
here and just applying this test to see

358
00:39:07,239 --> 00:39:14,189
what actions are relevant. Anyone wants to
venture against hazard against.

359
00:39:14,190 --> 00:39:25,050
Student: Stack A, B
Stack A on B and one more is stack B on D.

360
00:39:25,050 --> 00:39:33,289
Now, you can see the principle advantage
that backward stack space search gives us

361
00:39:33,289 --> 00:39:37,349
forward stack space search is in the branching
factor. Because backward stack space search

362
00:39:37,349 --> 00:39:41,739
is focus on the goal. It is only looking at
actions which will achieve the goal. And in

363
00:39:41,739 --> 00:39:45,189
this example you can see the branching
factor is small we have only 2 actions at

364
00:39:45,190 --> 00:39:50,349
we can consider and here they were many
actions at we were considered. That is a main

365
00:39:50,349 --> 00:39:55,029
advantage of doing backward reasoning
((refer time; 39:52)) reasoning then we have

366
00:39:55,030 --> 00:40:01,140
to talk about a regression. So, regress goal
g

367
00:40:01,139 --> 00:40:13,519
with action A it means how do you refine the
sub goal? So he get g plain h g minus

368
00:40:13,519 --> 00:40:20,519
effects of A, because action A is producing
those effects. We do not then to be clue in

369
00:40:20,519 --> 00:40:36,280
the in the previous state or the previous
goals description union any one p conditions

370
00:40:36,280 --> 00:40:43,230
of a
because that actions must be true in must

371
00:40:43,230 --> 00:40:46,760
be applicable in the previous goal state
essentially.

372
00:40:46,760 --> 00:40:56,750
So this is called regression and if you want
to now, over this you can see that I must

373
00:40:56,750 --> 00:41:04,670
remove the effects of stack A B which is on
A B, but I would be left with on B D. And

374
00:41:04,670 --> 00:41:18,840
now, I need the 3 conditions of those stack
action which is holding B. And clear D in

375
00:41:18,840 --> 00:41:24,480
the
similar fashion for this cycle regress to

376
00:41:24,480 --> 00:41:39,849
on A B is here 
holding B clear D. You can go in

377
00:41:39,849 --> 00:41:46,369
the stack B on D I am must B holding and D
must be clear. So that is why I added it to

378
00:41:46,369 --> 00:41:51,250
the so I have moving backward from the goal
to sub goals in some sense and this is the

379
00:41:51,250 --> 00:41:57,250
process I will search backward. The main advantage
that I am looking for is lower

380
00:41:57,250 --> 00:42:01,289
branching factor, because I am only looking
at actions which needed from a goal to be

381
00:42:01,289 --> 00:42:06,230
achieved. But there is a problem here every
one there is a problem like what is the

382
00:42:06,230 --> 00:42:14,990
problem here? So, look at these second action
so if you visualize what you are doing?

383
00:42:14,989 --> 00:42:21,879
You have this A on B, B on D and you are saying
that may last action would be to stack

384
00:42:21,880 --> 00:42:28,481
.B on D. To if you try to imagine that you
will see that it practically impossible, because

385
00:42:28,481 --> 00:42:42,030
he cannot be holding B when A is on B.
So, if you look at these 2 then they are inconsistent

386
00:42:42,030 --> 00:42:53,110
cannot be true at the same time.
Moreover if I want to regress from here I

387
00:42:53,110 --> 00:43:00,740
could say stack I could take any goal, I could
pick an action to achieve this goal which

388
00:43:00,739 --> 00:43:03,779
is to stack B on D. I could pick an action
to

389
00:43:03,780 --> 00:43:08,610
achieve this goal with which will be unstack
b from somewhere or pick up b from the

390
00:43:08,610 --> 00:43:13,380
table. And I could cube the action to achieve
this goal and that action would be

391
00:43:13,380 --> 00:43:21,599
unstacking something from D of course, unless
D is already true. But I can choose the

392
00:43:21,599 --> 00:43:30,500
first one for example, I can say stack b on
d and when I regress so this I get those holding

393
00:43:30,500 --> 00:43:44,940
B clear D and then the p conditions of this
which are holding 

394
00:43:44,940 --> 00:43:57,200
A clear it should be clear
B. So, I will have holding A and clear B and

395
00:43:57,199 --> 00:44:02,960
this holding B and clear D come, because of
the stack B D action. Again you can see that

396
00:44:02,960 --> 00:44:10,110
this is an impossible state which call a this
is not possibly a state whereas this is a

397
00:44:10,110 --> 00:44:14,930
state it you can agree.
Because B is on D an you a holding A and you

398
00:44:14,929 --> 00:44:20,279
about to stack A on to B that is perfectly
feasible. In fact it will be part of the plan

399
00:44:20,280 --> 00:44:24,460
that you will be a looking at. This is not
feasible this says you a holding B and you

400
00:44:24,460 --> 00:44:31,599
holding A at the same time and then you have
these 1 arm which is trying to do this essentially.

401
00:44:31,599 --> 00:44:38,920
So, backward stack space search has
this advantage that we branching we get a

402
00:44:38,920 --> 00:44:45,000
low branching factor. Because it is goal
directed, but it has a disadvantage that what

403
00:44:45,000 --> 00:44:48,460
we get are not states essentially may not
be

404
00:44:48,460 --> 00:45:02,619
states. Now, this progress action is sound
and by sound I mean it is close over the other

405
00:45:02,619 --> 00:45:11,920
state place. In some sense is that when you
apply a progress action to a state what you

406
00:45:11,920 --> 00:45:15,559
get is a state?
So, in that is sense its close a other state

407
00:45:15,559 --> 00:45:20,299
place the regress action is not sound when
you

408
00:45:20,300 --> 00:45:25,810
apply a regress action to a goal. You get
a goal description which may not necessarily

409
00:45:25,809 --> 00:45:28,650
be
state essentially which may not be possibly

410
00:45:28,650 --> 00:45:30,860
part of a state. So, for example, this is
cannot

411
00:45:30,860 --> 00:45:37,280
be part of the state how can we having on
A B an also holding B essentially that is

412
00:45:37,280 --> 00:45:39,750
not
allowed in the rules of the game you have

413
00:45:39,750 --> 00:45:44,429
defined you have a one arm robo which should
be holding B. And then so because is holding

414
00:45:44,429 --> 00:45:52,769
b nothing on B on top of B so this not
possible. So, how do we get around this problem?

415
00:45:52,769 --> 00:46:03,179
So this is not sound 
so there 2 things

416
00:46:03,179 --> 00:46:14,409
you can do basically is when the will stop
this backward stack space search, when we

417
00:46:14,409 --> 00:46:18,909
what you mean by that what is the test that
will you use.

418
00:46:18,909 --> 00:46:32,639
.Student: 3 condition of the actions applicable
You terminate this when that g whatever prime

419
00:46:32,639 --> 00:46:44,420
that we have is part of the start state.
Remember that you have regressing from 1 goal

420
00:46:44,420 --> 00:46:48,050
to another sub goal to another sub goal
to another sub. If at some points you have

421
00:46:48,050 --> 00:46:49,740
set of predicate which are true in a starts
set

422
00:46:49,739 --> 00:46:53,589
that you do not have to do any more actions.
You are already home is not to speak

423
00:46:53,590 --> 00:47:00,150
essentially so this is a condition that you
will use. So, you should verify there is possible

424
00:47:00,150 --> 00:47:07,240
for meet to construct a plan like this using
backward stack space search, but this is not

425
00:47:07,239 --> 00:47:10,369
a
valid plan. So, I can do a check for a valid

426
00:47:10,369 --> 00:47:24,949
plan how to a do that? So what is a check
for

427
00:47:24,949 --> 00:47:33,089
valid plan check for a valid plan takes an
as arguments a plan pie. Basically takes a

428
00:47:33,090 --> 00:47:42,110
problem description and a plan. And the problem
description is a starts states and a goal

429
00:47:42,110 --> 00:47:48,900
description and a set of actions.
So, which this input you can like a small

430
00:47:48,900 --> 00:47:53,099
routine which will begin with a start states
and I

431
00:47:53,099 --> 00:47:58,099
will not write the detail essential running
out of time. It will begin with a start set

432
00:47:58,099 --> 00:48:00,089
and
keep progressing with the actions what is

433
00:48:00,090 --> 00:48:07,731
the actions pies A 1 A 2 A k. So, the plan
is of

434
00:48:07,731 --> 00:48:13,540
k actions you begin with a start set apply
the force action. And we have seen that

435
00:48:13,539 --> 00:48:19,860
progress is a sound you will get a new state
apply the second action to that you apply

436
00:48:19,860 --> 00:48:21,880
the
third action. And till the end you keep applying

437
00:48:21,880 --> 00:48:26,289
the actions and then you see whether the
state that you reaches the goal set on not.

438
00:48:26,289 --> 00:48:28,099
And you will see that if you construct the
plan

439
00:48:28,099 --> 00:48:33,619
like this test will fail that it will say
the, this is not a plan why because. For example,

440
00:48:33,619 --> 00:48:38,069
this
action will not be applicable at all, because

441
00:48:38,070 --> 00:48:43,940
you will ever reach a state where you a
holding both these things together.

442
00:48:43,940 --> 00:48:58,400
So, you can do the check essentially another
thing we can do a check for consistency 

443
00:48:58,400 --> 00:49:11,170
and
proven, because start state may have 100 of

444
00:49:11,170 --> 00:49:16,070
facts. So, for example, here we have facts
about F and E and H and G and K there will

445
00:49:16,070 --> 00:49:22,500
never be generate it in the back ward face
from there we will never talk about K and

446
00:49:22,500 --> 00:49:26,900
J. So it will never figure in the goal
description see what will happen is that you

447
00:49:26,900 --> 00:49:29,079
will say I want to stack A on B and I want
to

448
00:49:29,079 --> 00:49:34,539
stack B on D. So, first I want to stack B
on D and then I want to A on B so stack B

449
00:49:34,539 --> 00:49:38,590
on B
add to first pick up B. To pick up B I have

450
00:49:38,590 --> 00:49:41,300
to remove A so it will remove A pick it on
the

451
00:49:41,300 --> 00:49:48,700
table then pick up B sorry pick up C and remove
it on A table so that D becomes clear.

452
00:49:48,699 --> 00:49:53,960
Then it will pick up A and stack on B then
it will pick up S and stack into A those will

453
00:49:53,960 --> 00:49:54,960
never come.

454
00:49:54,960 --> 00:50:01,449
.So, those in the starts it so that is why
this subset is necessary. This check for consistency

455
00:50:01,449 --> 00:50:07,230
is basically just a moment. This check for
consistency basically proving set saying move

456
00:50:07,230 --> 00:50:13,170
this state do not go back ward from here.
Or remove this state do not go backward from

457
00:50:13,170 --> 00:50:19,269
here inset go along this ration. No as you
can see in the actual plan this will be the

458
00:50:19,269 --> 00:50:22,449
last
section stacking A on B that will necessarily

459
00:50:22,449 --> 00:50:30,109
with a last section. The previous action
must be to make this clue or to make this

460
00:50:30,110 --> 00:50:33,510
the previous action must be or maybe it is
make

461
00:50:33,510 --> 00:50:41,300
clear B true. Once B is made clear and then
holding A for that the action will be pick

462
00:50:41,300 --> 00:50:44,269
up
A as you shall look at this carefully. You

463
00:50:44,269 --> 00:50:46,889
have to first put a on the table then you
will

464
00:50:46,889 --> 00:50:55,190
have to pick up a from the table. So thus
third last action would be picking up A so

465
00:50:55,190 --> 00:50:59,510
there
are parts which are which will yield the plan

466
00:50:59,510 --> 00:51:06,710
there are parts which are can be proven.
And then even if you do not have well you

467
00:51:06,710 --> 00:51:09,199
have this final check. That after you think
he

468
00:51:09,199 --> 00:51:13,299
of solve the problem just see whether what
you have produce is the valid plan or not.

469
00:51:13,300 --> 00:51:16,100
If it
is a valid plan then accept the solution otherwise

470
00:51:16,099 --> 00:51:20,789
continues searching essentially. And the
good thing about this consistency check is

471
00:51:20,789 --> 00:51:24,170
at it does not have to be perfect. If it is
perfect

472
00:51:24,170 --> 00:51:29,039
it will it will proven this state if it is
not perfect it own proved. It you may produce

473
00:51:29,039 --> 00:51:30,869
a
series of actions and you will find it not

474
00:51:30,869 --> 00:51:36,239
a plan and then you come back and try again
essentially. So, even if you have a in consist

475
00:51:36,239 --> 00:51:41,509
in perfect consistency check it will sell
work

476
00:51:41,510 --> 00:51:51,180
essentially. So, in the next class, we will
try as we keep doing all these time. To look

477
00:51:51,179 --> 00:51:54,429
at
an approach which will combine the good features

478
00:51:54,429 --> 00:51:59,539
of backward search and forward
search.

479
00:51:59,539 --> 00:52:04,469
The good feature of forward search is that
it is sound that whatever acts sequence of

480
00:52:04,469 --> 00:52:12,789
actions it produces are valid plans, because
the applicability test is the sound. The good

481
00:52:12,789 --> 00:52:17,119
feature about backward stack space search
is that branching factors is a low, but the

482
00:52:17,119 --> 00:52:19,400
bad
point is that it produces the poorest states.

483
00:52:19,400 --> 00:52:22,250
This is not state at all it is a poorer state
and

484
00:52:22,250 --> 00:52:28,880
we have to know do unnecessary extra work
to remove the states essentially. So, will

485
00:52:28,880 --> 00:52:33,740
try
and see an a algorithm which will search in

486
00:52:33,739 --> 00:52:37,979
a backward fashion like this and construct
a

487
00:52:37,980 --> 00:52:42,329
plan in a forward fashion like that essentially
for this is doing is searching in the

488
00:52:42,329 --> 00:52:46,940
backward fashion and constructing a plan also
from the last action backwards. This is the

489
00:52:46,940 --> 00:52:52,909
last action this is the second last section
will soon which as you are seen is a not a

490
00:52:52,909 --> 00:52:56,009
sound
process. This one is constructing sound plans,

491
00:52:56,010 --> 00:53:01,040
but it is doing too much searches you want
to combined the 2 and will do that next class.

492
00:53:01,039 --> 00:53:02,619
So, will stop here.

493
00:53:02,619 --> 00:53:12,619
.

