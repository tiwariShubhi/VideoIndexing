1
00:00:10,718 --> 00:00:24,609
So, let us begin we continue our study of
state space search and what we have just seen

2
00:00:24,609 --> 00:00:29,439
is
that the size of the state space can be significantly

3
00:00:29,439 --> 00:00:35,170
large even for a small toys that we talk
about. So, in Rubik’s cube we saw where

4
00:00:35,170 --> 00:00:39,500
the branching factor is eighteen if you want
to

5
00:00:39,500 --> 00:00:45,070
search up to depth 20, then you have to search
about 10 based to 25 node essentially

6
00:00:45,070 --> 00:00:51,920
even at smaller puzzle which is the 8 puzzle
and the 15 puzzle. If you look at the 15

7
00:00:51,920 --> 00:00:58,480
puzzle where the branching factor is capped
by 4, you can only move within one of four

8
00:00:58,479 --> 00:01:09,769
directions, it is about 10 raised to 13 states
and the 24 puzzle is about 10 raised to 24

9
00:01:09,769 --> 00:01:12,280
states.
So, even that small puzzles that you get can

10
00:01:12,280 --> 00:01:15,710
generate huge state space essentially and
we

11
00:01:15,709 --> 00:01:21,389
have seen the 10 based to 24 states is not
a number that you can slip that essentially

12
00:01:21,390 --> 00:01:24,689
it
will take you huge amounts of time. So, what

13
00:01:24,689 --> 00:01:29,929
is happening essentially is that the
algorithm that we have seen so far is blind.

14
00:01:29,930 --> 00:01:38,340
Essentially, that gives some state space given
some start state, what is what this algorithm

15
00:01:38,340 --> 00:01:44,260
is doing with the goal that you want to
achieve. It is using it only to test whether

16
00:01:44,260 --> 00:01:48,140
given state is goal state or not it is not
using it

17
00:01:48,140 --> 00:01:55,569
.to guide at search in any manner at all depth
first search as we said goes often some

18
00:01:55,569 --> 00:01:59,429
direction.
Then, it back tracks and tries other direction

19
00:01:59,430 --> 00:02:08,090
irrespective of where the goal state is
breadth first search always circles around

20
00:02:08,090 --> 00:02:10,890
the star states and it will gradually expand,
it

21
00:02:10,889 --> 00:02:17,339
search frontier to move away essentially.
The goal step no role to play here essentially

22
00:02:17,340 --> 00:02:23,370
the next step that we would like to do is
to somehow exploit what we know about the

23
00:02:23,370 --> 00:02:32,870
goal state to help guide the search. So, let
us assume that this was a city map essentially

24
00:02:32,870 --> 00:02:38,800
and let us say this s stands for IIT and you
have to go someplace essentially. So, let

25
00:02:38,800 --> 00:02:43,640
us
say this is a goal state somewhere, so if

26
00:02:43,639 --> 00:02:49,519
you are consistent with the geography of
Chennai, then this g could be may be Marina

27
00:02:49,520 --> 00:02:54,090
beach or something like that somewhere in
the north east.

28
00:02:54,090 --> 00:03:00,640
If you want to go of IIT to marina beach and
you of course have to follow the roads the

29
00:03:00,639 --> 00:03:09,769
every junction is a node and every road segment
is an edge essentially, so in some sense

30
00:03:09,770 --> 00:03:15,379
being at a junction is a state, so you are
you are at IIT. So, you are at this state

31
00:03:15,378 --> 00:03:18,348
you want
to be somewhere and here is the Gandhi statue

32
00:03:18,348 --> 00:03:22,509
in Marina beach that is a different state
and you can move across the road to move to

33
00:03:22,509 --> 00:03:29,509
a different junction which is a different
states and so on. Now, imagine what these

34
00:03:29,509 --> 00:03:35,399
two algorithms are doing they just go of in
the

35
00:03:35,400 --> 00:03:40,120
predetermine manner essentially and eventually
of course if somebody tells them we

36
00:03:40,120 --> 00:03:42,680
have reached Marina beach they will say I
am done.

37
00:03:42,680 --> 00:03:46,099
Essentially, what you really want what we
really want is an algorithm which would

38
00:03:46,098 --> 00:03:54,509
somehow head in this direction somehow you
know what do you mean by this? What we

39
00:03:54,509 --> 00:04:06,549
mean by this is that given a state given a
start state and given a set of successors

40
00:04:06,550 --> 00:04:09,170
instead
of choosing in a predetermine fashion, which

41
00:04:09,169 --> 00:04:18,279
successors to inspect or expand as a term
we use next. Let us try to get some exploit

42
00:04:18,279 --> 00:04:24,769
whatever knowledge we can of the domain to
help guide the search essentially.

43
00:04:24,769 --> 00:04:25,769
..

44
00:04:25,769 --> 00:04:43,439
So, that is called as heuristic search, so
the word heuristic comes from the word I mean

45
00:04:43,439 --> 00:04:56,060
with their various routes that I have read
about, so Eurisko or Heuriskein and so on.

46
00:04:56,060 --> 00:04:59,189
All
these are sort of Greek words of Greek origin

47
00:04:59,189 --> 00:05:08,689
and you might remember a word which is
also related to Eurisko which is called eureka

48
00:05:08,689 --> 00:05:16,430
you know this story of argument is running
naked through the streets saying eureka and

49
00:05:16,430 --> 00:05:24,009
so on essentially. So, what is eureka
meaning it means that I have found it, I have

50
00:05:24,009 --> 00:05:29,430
discovered it, essentially and this whole
idea of Eurisko heuristics is based on this

51
00:05:29,430 --> 00:05:35,810
knowing something essentially, so how can
we

52
00:05:35,810 --> 00:05:48,699
get heuristic?
So, let me first discus how this heuristic

53
00:05:48,699 --> 00:05:53,189
knowledge would be used essentially, so we
will

54
00:05:53,189 --> 00:06:02,569
assume that we have another function called
h of n which will take a node or a state and

55
00:06:02,569 --> 00:06:13,788
give a value which is a measure in some sense.
How easy is it to go from that state to the

56
00:06:13,788 --> 00:06:25,099
goal state, essentially so supposing we had
such a function. So, the theoretical

57
00:06:25,100 --> 00:06:30,210
community would say we have an oracle, it
tells you what is the complexity of going

58
00:06:30,209 --> 00:06:35,579
from this you know or it tells you which if
somebody could tell you that of these

59
00:06:35,579 --> 00:06:41,459
successors.
In general, given open list which one to pick

60
00:06:41,459 --> 00:06:48,489
next then it would help it would be helpful
essentially that because then they would just

61
00:06:48,490 --> 00:06:51,660
tell you if you go ahead if you go ahead if
you go ahead you will reach the goal state

62
00:06:51,660 --> 00:06:55,360
essentially. So, first let us get this out
of the

63
00:06:55,360 --> 00:06:58,919
way this mechanism of how we are going to
exploit the heuristic function.

64
00:06:58,918 --> 00:06:59,918
..

65
00:06:59,918 --> 00:07:05,049
So, if you look at this algorithm that we
have the same framework, we will follow open

66
00:07:05,050 --> 00:07:15,069
is initially made of this pair start. So,
it should really be list of list essentially

67
00:07:15,069 --> 00:07:17,470
and then
extract the first one extract the node all

68
00:07:17,470 --> 00:07:26,330
that is the same and we at some point generate
new the set that we have of new nodes that

69
00:07:26,329 --> 00:07:38,729
we want to add to open, what we will do now
at least conceptually is that. So, remember

70
00:07:38,730 --> 00:07:42,400
that so far we said that we can either add
new

71
00:07:42,399 --> 00:07:49,538
at the head of the tail of open or the remaining
part of open or at the end of the tail of

72
00:07:49,538 --> 00:07:54,589
open if it was at the head of open, it was
like stack if it was tail of open, it was

73
00:07:54,589 --> 00:07:56,310
like a
queue.

74
00:07:56,310 --> 00:08:29,129
Now, we are saying is that something like
this sort on happened new, so if I say append

75
00:08:29,129 --> 00:08:35,110
new tail of open that part is like depth first
search essentially that new is added at the

76
00:08:35,110 --> 00:08:41,759
assuming append. That is what append does
it sort of take this list and concatenate

77
00:08:41,759 --> 00:08:44,350
with
this list putting them at this towards the

78
00:08:44,350 --> 00:08:47,869
head it is like that this thing. Now, I am
saying

79
00:08:47,869 --> 00:08:53,430
after you are appended the two list sort them
on the h value what is h value h value is

80
00:08:53,429 --> 00:08:57,609
this
value of this heuristic function of the node

81
00:08:57,610 --> 00:09:02,428
essentially.
This means what simply that the best h value

82
00:09:02,428 --> 00:09:08,269
will come the head of the list we are still
talking about it is the list and this same

83
00:09:08,269 --> 00:09:09,869
algorithm will pick it from the head of the
list

84
00:09:09,869 --> 00:09:16,949
and then this thing. So, if we have such heuristic
knowledge we can exploit it by simply

85
00:09:16,948 --> 00:09:24,299
modifying our algorithm to keep open as a
sorted list. So, that when we remove the head

86
00:09:24,299 --> 00:09:29,049
element we always get the best element what
do we mean by best? By best we mean best

87
00:09:29,049 --> 00:09:32,578
.according to what the heuristic function
believes or what the heuristic function thinks

88
00:09:32,578 --> 00:09:40,528
essentially only as far as that essentially.
If we have a heuristic function then we can,

89
00:09:40,528 --> 00:09:51,568
this is called a heuristic function is should
write it right, it returns a number which

90
00:09:51,568 --> 00:09:54,998
is a measure of how easy or hard it is to
go solve

91
00:09:54,999 --> 00:10:02,120
the state from there essentially. So, this
is the only chain we would need to make in

92
00:10:02,120 --> 00:10:04,948
our
algorithm that we have to sort the open list

93
00:10:04,948 --> 00:10:14,240
every time we add new elements essentially.
Now, obviously the data structure person inside

94
00:10:14,240 --> 00:10:19,579
you must be rebelling against this idea
sorting this list again and again and again

95
00:10:19,578 --> 00:10:28,448
because sorting is expensive. So, you could
you could do a other thing you could do for

96
00:10:28,448 --> 00:10:47,808
example, merge then sort new this tail open
yeah that is a first thing one think.

97
00:10:47,808 --> 00:10:56,458
So, this is not needed that because the number
of new elements is going to be small and

98
00:10:56,458 --> 00:11:04,659
the rest of the tail is anyway sorted. So,
just sort the new elements again an h of course,

99
00:11:04,659 --> 00:11:10,528
and then merge it with the tail open of course,
which is a little bit better in terms of

100
00:11:10,528 --> 00:11:17,198
computational work, but that obviously is
not the last word on this. So, just like we

101
00:11:17,198 --> 00:11:23,188
said
that to make efficient use of close you must

102
00:11:23,188 --> 00:11:26,328
maintain it as table what about this open
now

103
00:11:26,328 --> 00:11:37,859
how do we efficiently implement open. So,
of course, that efficiency will only be from

104
00:11:37,860 --> 00:11:44,428
the computational point of view as far as
the task is concerned of choosing the next

105
00:11:44,428 --> 00:11:48,549
successor.
It does not matter in what manner we manage

106
00:11:48,549 --> 00:11:51,179
to sort it how much time is spend sorting
it

107
00:11:51,179 --> 00:11:59,488
essentially, but if you what if you were concern
about that how should you manage open

108
00:11:59,489 --> 00:12:05,300
at the risk of turning this into a data sectors
class we will spend one minute here.

109
00:12:05,299 --> 00:12:22,558
Student: Sir, we have to maintain it.
So, you must maintain open as a priority queue

110
00:12:22,558 --> 00:12:25,688
of course, there are many different
mechanisms to implement priority queues we

111
00:12:25,688 --> 00:12:30,078
will not go into that we will just make this
observation that you must somehow implement

112
00:12:30,078 --> 00:12:34,608
open efficiently. So, what is really
happening just imagine this that we have this

113
00:12:34,609 --> 00:12:40,680
tail of open this, tail of open is like a
big.

114
00:12:40,679 --> 00:12:46,659
Let us say it is sorted list or something
like that and then we have this new which

115
00:12:46,659 --> 00:12:49,838
is a
smaller list essentially. So, this is already

116
00:12:49,839 --> 00:12:53,579
sorted and we have get this we have got this
new elements and we have to sort of insert

117
00:12:53,578 --> 00:13:02,289
them into in the right place inside this sorted
list. The best way to do it is by a priority

118
00:13:02,289 --> 00:13:05,988
queue one way to implement the priority queue

119
00:13:05,989 --> 00:13:12,339
.is use heaps, but there are other ways of
doing it. So, you must if we are implementing

120
00:13:12,339 --> 00:13:18,139
heuristic search it is very important that
you pay attention to how you manage open

121
00:13:18,139 --> 00:13:24,369
because that is going to affect your running
time essentially things become a little bit

122
00:13:24,369 --> 00:13:28,199
more complicated.
When you remember that you also wanted to

123
00:13:28,198 --> 00:13:34,149
remove from the new list those things
which are already on open essentially which

124
00:13:34,149 --> 00:13:40,639
is not for which the priority queue is not
really the best we have doing things. So,

125
00:13:40,639 --> 00:13:45,519
I will leave this as a small exercise for
you to as

126
00:13:45,519 --> 00:13:49,448
the data structure exercise you might say
you want to do both these task you want to

127
00:13:49,448 --> 00:13:55,778
check for membership in open. That is a new
node already present in open, which is

128
00:13:55,778 --> 00:14:02,359
based on by a hash table you also want to
maintain open. So, always the best nodes will

129
00:14:02,359 --> 00:14:05,600
be at the head of open which is what a priority
queue does.

130
00:14:05,600 --> 00:14:10,558
How can you do both, can you do both in and
if yes how it will be, but it is not our

131
00:14:10,558 --> 00:14:15,358
primary concern here our primary concern is
to look at how heuristic search happens.

132
00:14:15,359 --> 00:14:23,589
This is basically what is happening essentially,
now let us pay attention to the heuristic

133
00:14:23,589 --> 00:14:30,459
function itself how we get this heuristic
function.

134
00:14:30,458 --> 00:14:31,458
.

135
00:14:31,458 --> 00:14:43,979
So, one thing that one can do is which part
of operational zing is this whole process

136
00:14:43,980 --> 00:14:53,209
is at
the search node which was originally a pair

137
00:14:53,208 --> 00:15:02,668
which has the current node the parent node.
Now, we want to convert it into a triple,

138
00:15:02,668 --> 00:15:10,739
so it will become current parent and that
is the

139
00:15:10,739 --> 00:15:15,418
call it h value for that node essentially.
So, we want to also store that h value out

140
00:15:15,418 --> 00:15:16,418
of node

141
00:15:16,418 --> 00:15:25,239
.which means what that every time we generate
a new node we will need to compute the

142
00:15:25,239 --> 00:15:46,699
h value. Let us say this is the n, n is some
node and you want every time we generate a

143
00:15:46,698 --> 00:15:49,058
node n we want to compute the h value for
that node.

144
00:15:49,058 --> 00:15:54,139
Now, of course, you must keep in mind that
this h value is not just the property of that

145
00:15:54,139 --> 00:16:03,229
node it is also dependent upon the goal node
essentially for different goal nodes. The

146
00:16:03,229 --> 00:16:08,669
same node may have a different h value, but
we are sort of losing over that here little

147
00:16:08,668 --> 00:16:17,448
bit
essentially, so how do we how do we generate

148
00:16:17,448 --> 00:16:19,808
these heuristic functions?
.

149
00:16:19,808 --> 00:16:37,328
So, there are two approaches to this one is
domain dependent 

150
00:16:37,328 --> 00:16:48,719
or static, so by static we
mean that it only look as this current node

151
00:16:48,720 --> 00:16:53,470
and may be it looks as a goal node in some
manner, obviously it will have to do that

152
00:16:53,470 --> 00:16:56,990
and gives us a value back essentially. So,
let us

153
00:16:56,990 --> 00:17:06,519
take an example or couple of examples let
us say this is a city map like we said that

154
00:17:06,519 --> 00:17:08,509
is
this is IIT and that is Marina beach and so

155
00:17:08,509 --> 00:17:16,099
on and so forth. How can we give heuristic
values to this node essentially, so the simplest

156
00:17:16,099 --> 00:17:24,379
thing is h of n, so city in a city map
problem route finding problems. So, now, a

157
00:17:24,380 --> 00:17:27,569
days of course, we have all these algorithms
which do route finding for you have to go

158
00:17:27,568 --> 00:17:37,369
from one place to another you must think
about how they do this we can say h of n.

159
00:17:37,369 --> 00:17:45,119
So, let us assume that the goal node is given
to us, so what can we expect in the city map

160
00:17:45,119 --> 00:17:55,109
we can expect to get coordinates essentially.
So, start state is from x start and y start

161
00:17:55,109 --> 00:17:58,339
in
the two dimensional map and goal state is

162
00:17:58,339 --> 00:18:03,109
some x goal and y goal if the coordinates
are

163
00:18:03,109 --> 00:18:07,168
.given to you and that you can that is reasonable
to expect that the coordinates may be

164
00:18:07,169 --> 00:18:14,540
available in such a situation. How can we
exploit this? How can we sort of get this?

165
00:18:14,539 --> 00:18:19,759
So
we say for each node or each location in the

166
00:18:19,759 --> 00:18:25,298
map we compute the distance to the goal
node and that is the estimate of heuristic

167
00:18:25,298 --> 00:18:55,619
that we will use.
So, one is Euclidean distance 

168
00:18:55,619 --> 00:18:59,878
and that is a good estimate of, so how are
you going to use

169
00:18:59,878 --> 00:19:07,278
this Euclidean distance we are going to say
these are the different places that we can

170
00:19:07,278 --> 00:19:10,579
go
to. So, remember that in a city map situation

171
00:19:10,579 --> 00:19:14,569
we are moving from one generation to the
next that once you on a road you have to go

172
00:19:14,569 --> 00:19:18,710
to the next you have to go to next junction
which has these nodes here. So, essentially

173
00:19:18,710 --> 00:19:25,038
you compute this distance for each of these
n

174
00:19:25,038 --> 00:19:30,529
nodes each of this successor and in general
for every node in open. To start with, this

175
00:19:30,529 --> 00:19:33,759
is
only open that we have and then choose the

176
00:19:33,759 --> 00:19:39,640
one which has which seems to be closes to
the goal essentially now this is the heuristic.

177
00:19:39,640 --> 00:19:52,419
So, when we say heuristic we also use a term
rule of thumb and if you go to the

178
00:19:52,419 --> 00:19:58,350
psychology today website they will say that
it is a mental shortcut heuristic is a mental

179
00:19:58,349 --> 00:20:03,509
shortcut which we use to solve problems quickly.
So, the emphasis the word quickly we

180
00:20:03,509 --> 00:20:10,490
are trying to fight this common neutral explosion
and trying to use some knowledge in

181
00:20:10,490 --> 00:20:17,819
this case from the domain to guide our search.
So, when you are using a domain

182
00:20:17,819 --> 00:20:21,470
dependent heuristic function we have now three
domain function one is the move gen

183
00:20:21,470 --> 00:20:26,028
function that we already talked about and
one is the goal test function.

184
00:20:26,028 --> 00:20:33,169
The third is now the heuristic function which
means that if you are going to now create

185
00:20:33,169 --> 00:20:36,389
a
new domain you must write the program which

186
00:20:36,388 --> 00:20:41,569
will compute h of n. So, that is the search
algorithm can exploit that is why the search

187
00:20:41,569 --> 00:20:46,839
algorithm goes it only uses that h value to
sort or maintain a sorted list or maintain

188
00:20:46,839 --> 00:20:52,819
a priority queue of the candidates essentially.
The domain must now tell us what the h value

189
00:20:52,819 --> 00:20:57,639
is we will in the moment we will try to see
whether is this can be done in a domain independent

190
00:20:57,640 --> 00:21:03,140
fashion at all because you see this
whole idea that we are trying to pursue is

191
00:21:03,140 --> 00:21:05,809
to write this algorithms in a domain
independent fashion.

192
00:21:05,808 --> 00:21:09,918
We want to write these search algorithms without
saying that I want to solve the city

193
00:21:09,919 --> 00:21:16,360
route finding problem or a Rubik’s cube
or a Robert movement problem or a factory

194
00:21:16,359 --> 00:21:25,408
scheduling problem. It does not care you have
to find some general purpose algorithm

195
00:21:25,409 --> 00:21:29,070
and we would like to plug-in domains and just
use those algorithms essentially.

196
00:21:29,069 --> 00:21:40,689
.Yesterday there was a talk about this mars
Robert yes anybody attend, so this NASA,

197
00:21:40,690 --> 00:21:46,200
you know they had this mars Roberts. They
used a lot of this kind of planning algorithms

198
00:21:46,200 --> 00:21:52,220
for finding paths for this and move because
it is not just the path for the Robert to

199
00:21:52,220 --> 00:21:54,569
follow
also what are the movements that.

200
00:21:54,569 --> 00:21:58,778
For example, a robot arm must do if you have
to pick up something from the ground, let

201
00:21:58,778 --> 00:22:03,230
us say piece of rock from the ground or something
every move have to be has to be

202
00:22:03,230 --> 00:22:15,870
planned carefully and there we use the lot
of these techniques. So, heuristic function

203
00:22:15,869 --> 00:22:18,459
of
course, if the heuristic function is perfect

204
00:22:18,460 --> 00:22:22,360
which means it is like an oracle what the
theoretical computer scientist would say.

205
00:22:22,359 --> 00:22:27,889
Then, it will just tell you which is the correct
thing and then of course, you would find the

206
00:22:27,890 --> 00:22:32,440
solution in linear time essentially, you just
go from along the path essentially, but in

207
00:22:32,440 --> 00:22:37,470
practice of course, it is not, so easy to
find

208
00:22:37,470 --> 00:22:47,210
heuristic function.
.

209
00:22:47,210 --> 00:22:50,659
What is the other function that one can talk
about, so another function that we use

210
00:22:50,659 --> 00:23:15,850
sometime is simply this x s minus x g, so
what is this doing instead of measuring. So,

211
00:23:15,849 --> 00:23:18,109
the
Euclidean distance is telling you the distance

212
00:23:18,109 --> 00:23:23,788
as we say as this is telling you a difference
between the x coordinates and the difference

213
00:23:23,788 --> 00:23:31,509
between the y coordinates. What is the
name of this distance function Manhattan function

214
00:23:31,509 --> 00:23:41,339
Manhattan distance 
also called a city

215
00:23:41,339 --> 00:23:48,470
block distance essentially if you have a nicely
laid out city like Manhattan, then you

216
00:23:48,470 --> 00:23:52,620
know it is like on a grid then you can only
go along the roads on the grid.

217
00:23:52,619 --> 00:23:57,928
.That distance that you cover would be basically
this that if you know if you had if a grid

218
00:23:57,929 --> 00:24:04,298
on a grid you can only move along the x direction
or on the y direction and then other

219
00:24:04,298 --> 00:24:09,749
distance measures that one can think of.
For example, one could take the max of this

220
00:24:09,749 --> 00:24:16,610
or max of this or max of this and this only
and choose that or there are other something

221
00:24:16,609 --> 00:24:22,678
called Murkowski norm which we will not
get into here. So, essentially what are we

222
00:24:22,679 --> 00:24:28,210
trying to do we are trying to devise a domain
function which takes two inputs one is the

223
00:24:28,210 --> 00:24:31,778
node given node and the other is the goal
node

224
00:24:31,778 --> 00:24:34,499
which we assume the during the ten year of
the search is constant. So, we are not

225
00:24:34,499 --> 00:24:39,860
mentioning it here, but it is there somewhere
in the background and it returns a value to

226
00:24:39,859 --> 00:24:47,000
us which gives some idea of how close one
is to the goal node essentially.

227
00:24:47,000 --> 00:24:54,220
So, in this context we can say a heuristic
function is an estimate of the distance to

228
00:24:54,220 --> 00:24:58,110
the
goal essentially. So, we are using the term

229
00:24:58,109 --> 00:25:02,939
distance explicitly here in this case essentially
in general it is an estimate of how hard it

230
00:25:02,940 --> 00:25:05,710
is to solve a problem from the given state.
By

231
00:25:05,710 --> 00:25:09,850
hard, we mean typically the number of moves
that you want to make and later on when

232
00:25:09,849 --> 00:25:17,128
we see when we add cost to each move. So,
for example, in the road we might add the

233
00:25:17,128 --> 00:25:21,319
length of a road all the conjunction on the
road as a cost or something that we will come

234
00:25:21,319 --> 00:25:27,658
to that later. So far, our idea of optimal
solution is simply to have a smallest number

235
00:25:27,659 --> 00:25:32,210
of
moves essentially.

236
00:25:32,210 --> 00:25:33,210
.

237
00:25:33,210 --> 00:25:45,690
.Let us look at another example which is this
eight or fifteen puzzle, so let us say this

238
00:25:45,690 --> 00:26:00,830
is
my given state 

239
00:26:00,829 --> 00:26:09,259
and I have or let me choose one with three
successors, so I have three

240
00:26:09,259 --> 00:26:18,329
successors from here one is that I can move
this two down. So, I will get 4, 8, 2, 6,

241
00:26:18,329 --> 00:26:25,470
7, 3,
1, 5 or I can get, I can move 6 this side,

242
00:26:25,470 --> 00:26:46,879
so 2, 4, 8, 6, 7, 3, 1, 5 or I can move 3
up. So, I

243
00:26:46,878 --> 00:26:52,428
have these three successors which i can make
from here and I have to decide which one

244
00:26:52,429 --> 00:27:06,019
of them to choose so obviously I need a goal
state. So, let me 

245
00:27:06,019 --> 00:27:19,509
say that we have some goal
state which looks like this and so let us

246
00:27:19,509 --> 00:27:22,599
say any state can be a goal state. So, let
us say

247
00:27:22,599 --> 00:27:28,808
this is a goal state and we want to somehow
arrange the tail, so we reach that state

248
00:27:28,808 --> 00:27:37,859
essentially how can we talk about heuristic
functions can you think of heuristic function.

249
00:27:37,859 --> 00:27:41,528
Now, what is the heuristic function or static
heuristic function, so let us say we are

250
00:27:41,528 --> 00:27:45,359
talking about this state this middle state
where we have moved 6 to the left hand side

251
00:27:45,359 --> 00:27:47,089
is
this move that we should make? So, that is

252
00:27:47,089 --> 00:27:52,538
the question we are asking should we make
this move or this move or this move essentially.

253
00:27:52,538 --> 00:27:59,169
So, we want to four each of this we want
to compute the h value as it is called are

254
00:27:59,169 --> 00:28:02,028
the heuristic value which basically should
look

255
00:28:02,028 --> 00:28:12,740
at this only. That gives us a number and let
us say we were adopt the convention that the

256
00:28:12,740 --> 00:28:16,679
smaller the number the better for us essentially
we going with the sense of distance or

257
00:28:16,679 --> 00:28:21,389
notion of distance the smaller the distance
the better can you think of a heuristic

258
00:28:21,388 --> 00:28:43,089
function.
So, one function is let us calling it h 1

259
00:28:43,089 --> 00:28:52,220
of n is equal to sum of the distance for each
tile

260
00:28:52,220 --> 00:29:01,860
distance to goal. So, when I say distance
to goal I mean the distance to the goal position

261
00:29:01,859 --> 00:29:09,248
no suggest keep in mind and what do we mean
by distance here. Let us assume that we

262
00:29:09,249 --> 00:29:13,798
mean the Manhattan distance because this is
the problem where actually distance is has

263
00:29:13,798 --> 00:29:18,308
to be it makes sense use manhattans because
you can only move horizontally or

264
00:29:18,308 --> 00:29:26,898
vertically. So, what would be the heuristic
value of this state for this state we look

265
00:29:26,898 --> 00:29:29,849
at two
is here and two is there.

266
00:29:29,849 --> 00:29:36,308
So, I will add one for two then four is here
and four is there, so I need two steps to

267
00:29:36,308 --> 00:29:43,079
get to
that. So, 2 plus for 8, I need 1, 2, 3 steps

268
00:29:43,079 --> 00:29:55,398
for 6, I need 1, 2, 2 steps for 7, I need
1, 2, 3

269
00:29:55,398 --> 00:30:06,719
steps for 3, I need to move 1, 2, 3, 4 steps
or one I need to move 1, 2, 3 steps and plus

270
00:30:06,720 --> 00:30:12,829
for
5 I need to move 0 steps. So, basically the

271
00:30:12,829 --> 00:30:18,759
sum of all these numbers, so let me remove
them, it is confusing here, so I have all

272
00:30:18,759 --> 00:30:21,009
these numbers and basically the sum of all
these

273
00:30:21,009 --> 00:30:27,509
numbers is the heuristic value for this state
essentially. So, if we added up you will get

274
00:30:27,509 --> 00:30:33,429
a
heuristic value likewise, you do for this

275
00:30:33,429 --> 00:30:38,159
and likewise you do for that and you would
have

276
00:30:38,159 --> 00:30:59,470
.some way of making a guess which one is better.
Can you think of any other heuristic

277
00:30:59,470 --> 00:31:17,169
function? It can be simpler than this, number
of misplaced tiles.

278
00:31:17,169 --> 00:31:43,620
That is another, so in this case h 2 of n,
you simply count how many tiles are out of

279
00:31:43,619 --> 00:31:48,689
place
essentially. So, you can say in this situation

280
00:31:48,690 --> 00:31:57,538
five is in place and nothing else is in place
or

281
00:31:57,538 --> 00:32:02,509
if you want to count the blank tile as well
then you can says the blank tile is in its

282
00:32:02,509 --> 00:32:04,690
place,
but that will anyway add up to something essentially.

283
00:32:04,690 --> 00:32:17,820
So, it is a simpler measure
essentially it is easier to compute, but is

284
00:32:17,819 --> 00:32:27,259
in a notion of better here is one heuristic
function better than another 

285
00:32:27,259 --> 00:32:29,499
supposing I want to tell you that these are
the two heuristic

286
00:32:29,499 --> 00:32:34,519
functions to use.
What does your intuition say see there are

287
00:32:34,519 --> 00:32:40,579
two aspects to making this choice one is the
cost of computing the function and second

288
00:32:40,579 --> 00:32:47,918
is the benefits that it gives us what is the
benefit the benefit that we are looking for

289
00:32:47,919 --> 00:32:52,971
is that we should guide our search better.
In

290
00:32:52,971 --> 00:33:01,509
other words, one way of counting this is that
that if you let us say run 10,000

291
00:33:01,509 --> 00:33:10,659
experiments on this 8 puzzle then you could
compute something like this a measure its

292
00:33:10,659 --> 00:33:29,350
we call as effective branching factor equal
to number of nodes seen divided.

293
00:33:29,349 --> 00:33:46,308
So, there is a effective branching factor
it is the property of the heuristic function

294
00:33:46,308 --> 00:33:51,859
and the
way it is computed is that you run an experiment

295
00:33:51,859 --> 00:33:56,139
what is it mean you give some start
state some goal state. Let the heuristic function

296
00:33:56,140 --> 00:34:00,440
guide search according to this algorithm
that we have just written and then count how

297
00:34:00,440 --> 00:34:06,220
many nodes that the algorithms see and
divided by the total length of the solution

298
00:34:06,220 --> 00:34:14,240
what is the ideal value here. Ideal value
is 1,

299
00:34:14,239 --> 00:34:18,849
essentially even to heuristic function is
perfect you will only see the nodes which

300
00:34:18,849 --> 00:34:21,539
take
you to this goal station, so you will not

301
00:34:21,539 --> 00:34:25,460
see any other new terms.
So, the ideal value for this effective branch

302
00:34:25,460 --> 00:34:37,980
effective is one the branching factor of the
problem itself is known to you which is 4.

303
00:34:37,980 --> 00:34:41,769
Essentially, let us say is bounded by four
or it

304
00:34:41,769 --> 00:34:44,929
has Rubik’s cube its I mean concentrating,
but in this case it is not concern, but let

305
00:34:44,929 --> 00:34:47,199
us say
it is. So, the effective branching factor

306
00:34:47,199 --> 00:34:49,428
will be some value between 1 and 4, the better
the

307
00:34:49,429 --> 00:34:53,409
heuristic function. Of course, you will not
do it for one experiment, you will run

308
00:34:53,409 --> 00:34:59,930
thousands of experiments just to even out
all statistical variations that you come by

309
00:34:59,929 --> 00:35:03,379
choosing difference start states and that
kind of a thing essentially.

310
00:35:03,380 --> 00:35:09,180
So, then you have a notion of one being better
than the other, but at the same time you

311
00:35:09,179 --> 00:35:18,159
have the cost difference between the two in
this case these two functions. In general,

312
00:35:18,159 --> 00:35:19,159
they

313
00:35:19,159 --> 00:35:22,199
.may be a choice of more than two functions,
so one has to choose the heuristic function

314
00:35:22,199 --> 00:35:27,139
essentially.
Now, if you just go back to this algorithm

315
00:35:27,139 --> 00:35:37,460
again 
it makes sense to use a heuristic function

316
00:35:37,460 --> 00:35:42,420
if now remember that the heuristic function
you have to compute for every node that you

317
00:35:42,420 --> 00:35:48,450
generate every time you call the move gen
function and generate the children. After

318
00:35:48,449 --> 00:35:53,629
removing the duplicates ones, you have to
compute the heuristic function for that node

319
00:35:53,630 --> 00:36:03,820
essentially. So, the extra cost of computing
the heuristic function must be much less than

320
00:36:03,820 --> 00:36:08,710
the total time save for this algorithm which
means that how do you save time by seeing

321
00:36:08,710 --> 00:36:10,059
a
fewer number of nodes.

322
00:36:10,059 --> 00:36:13,290
Essentially, if the heuristic function is
good then you will not go down some paths

323
00:36:13,289 --> 00:36:16,389
which
are meaningless you would only go down the

324
00:36:16,389 --> 00:36:22,328
solution path essentially, so obviously it
make sense to choose a versatile use a term

325
00:36:22,329 --> 00:36:27,940
inexpensive heuristic function. The simplest
or the most inexpensive ones are the static

326
00:36:27,940 --> 00:36:32,480
functions which only look at given state and
tell you a value essentially it shows a state.

327
00:36:32,480 --> 00:36:35,550
It will say this is a good state or a bad
state in

328
00:36:35,550 --> 00:36:45,200
terms of some number which it will compute
using one of those things why do we say

329
00:36:45,199 --> 00:36:58,019
that, so let us go back to this city map example
for a moment.

330
00:36:58,019 --> 00:37:05,739
What can happen which the heuristic function
cannot foresee essentially, so if you know

331
00:37:05,739 --> 00:37:18,939
the topology of Chennai and if you know that
you will go to the gate, you have no other

332
00:37:18,940 --> 00:37:25,869
option you go to the main gate and from there
you have to decide where to go. So, this is

333
00:37:25,869 --> 00:37:36,750
the starting place that is the goal location
what happens when there is a river running

334
00:37:36,750 --> 00:37:46,159
across this, we have this Adyar River and
it even has water sometimes. A heuristic

335
00:37:46,159 --> 00:37:52,549
function which is only looking at the start
state and the goal state will be oblivious

336
00:37:52,550 --> 00:37:54,730
of the
fact that there is a river on the way.

337
00:37:54,730 --> 00:38:02,240
So, in the mountainous situation it could
be a paths for example, you need a paths to

338
00:38:02,239 --> 00:38:06,909
cross some mountain ridge here you need a
bridge. So, let us say the bridge is one bridge

339
00:38:06,909 --> 00:38:18,480
is here and another bridge is here, but there
is no bridge along the blowflies direction

340
00:38:18,480 --> 00:38:24,070
close the river. What will the heuristic function
do it will drive the search in this

341
00:38:24,070 --> 00:38:28,180
direction because it will tell you this node
is better than this node and this node is

342
00:38:28,179 --> 00:38:31,980
better
than this node. In actual practice these two

343
00:38:31,980 --> 00:38:35,960
one of these two nodes is likely to be better
why because this might take you to this bridge

344
00:38:35,960 --> 00:38:37,420
and this might take you to this bridge,

345
00:38:37,420 --> 00:38:40,680
.whereas this will take you to dead end and
then you will have to go down this path and

346
00:38:40,679 --> 00:38:46,449
then go like this.
We will not be able to see in the future a

347
00:38:46,449 --> 00:38:50,639
heuristic function will make judgment only
based on what information it has in this case

348
00:38:50,639 --> 00:38:55,269
it is a static function which means the
current location and the destination location

349
00:38:55,269 --> 00:38:59,949
and based on that this appears to be the best.
So, in that sense heuristic functions are

350
00:38:59,949 --> 00:39:02,849
fallible that is not necessary that they will
give

351
00:39:02,849 --> 00:39:08,730
you the best thing. We will in the next class
look at another example to see how a

352
00:39:08,730 --> 00:39:13,719
heuristic function can take, you can be misguided
in some sense essentially and we will

353
00:39:13,719 --> 00:39:24,770
discuss that in the little bit more detail.
So, you have to devise some heuristic function

354
00:39:24,771 --> 00:39:32,550
which will give you a number for every
node that you add to the open list and we

355
00:39:32,550 --> 00:39:34,068
are assuming here that the smaller is the
better

356
00:39:34,068 --> 00:39:39,920
because we are talking about notion of a distance.
Then, we will sort the open list

357
00:39:39,920 --> 00:39:44,450
according to the heuristic function and always
choose the best node and the search will

358
00:39:44,449 --> 00:39:51,500
progress essentially. So, what is the hope
the hope is that the search will go towards

359
00:39:51,500 --> 00:39:54,639
the
direction of the goal, but sometimes it may

360
00:39:54,639 --> 00:40:01,920
go in one direction then it may have to back
trap and try something else essentially. So,

361
00:40:01,920 --> 00:40:13,769
which one might say that you start with the
search this thing go down some path and you

362
00:40:13,769 --> 00:40:19,358
can fill in some values so that we will go
down this path here.

363
00:40:19,358 --> 00:40:25,210
So, for example, this could be 40 this could
be 60 and this could be 50 or something like

364
00:40:25,210 --> 00:40:33,210
that. So, which choose 40 and then likewise
remember that all these are closed according

365
00:40:33,210 --> 00:40:37,960
to the algorithm and everything else is opened
essentially. So, it is possible that the

366
00:40:37,960 --> 00:40:41,220
heuristic function will take it down this
path and suddenly it will discover that the

367
00:40:41,219 --> 00:40:46,649
heuristic value has short of at this stage.
So, this becomes the next directly, so the

368
00:40:46,650 --> 00:40:54,309
heuristic function is guided since its guided
by the heuristic function it does not always

369
00:40:54,309 --> 00:40:58,760
explore the space in the same predetermined
pattern, but it will depend on what is the

370
00:40:58,760 --> 00:41:03,170
goal that you have given to us.
If the goal of was instead of here is the

371
00:41:03,170 --> 00:41:07,700
goal was here, let us say station or something
then the certain algorithm would have try

372
00:41:07,699 --> 00:41:12,808
to go in this direction essentially. So, its
behavior changes with every goal that is a

373
00:41:12,809 --> 00:41:16,160
basic idea that it is trying to go in the
direction

374
00:41:16,159 --> 00:41:22,159
where the goal will be achieved essentially.
Likewise, for the other problem essentially

375
00:41:22,159 --> 00:41:23,649
I

376
00:41:23,650 --> 00:41:33,510
.will come to the dynamic functions in the
moment lets discus the properties of this

377
00:41:33,510 --> 00:41:38,880
algorithm I have gotten the four criteria
that we have talked about.

378
00:41:38,880 --> 00:42:04,019
Let us start with completeness, so where should
I write this I think let me here, so let us

379
00:42:04,019 --> 00:42:07,730
give this algorithm and name by the way we
haven’t given it a name and this algorithm

380
00:42:07,731 --> 00:42:21,289
is
called best first 

381
00:42:21,289 --> 00:42:25,619
best first in the sense that of all the nodes
in the open. It will pick the best

382
00:42:25,619 --> 00:42:30,809
one first and what do you mean by best the
one with the lowest heuristic value, so best

383
00:42:30,809 --> 00:42:47,460
first what are the properties 
completeness let us assume that it is a finite

384
00:42:47,460 --> 00:42:55,338
space for
simplicity, which is complete. It is complete,

385
00:42:55,338 --> 00:43:06,940
but how would justify your argument
actually we did not actually give a very a

386
00:43:06,940 --> 00:43:12,088
little bit more formal argument even for the
earlier search is, but you can give it now

387
00:43:12,088 --> 00:43:15,159
looking at this algorithm how can you say
that it

388
00:43:15,159 --> 00:43:25,129
is complete essentially.
In every cycle, it picks one node from open

389
00:43:25,130 --> 00:43:33,150
inspects it and either put into close or
succeeds or whatever the state space is finite

390
00:43:33,150 --> 00:43:38,450
which means open can have only all the
entire state space in the worst case it will

391
00:43:38,449 --> 00:43:44,719
explore the entire state space. In every cycle,
it

392
00:43:44,719 --> 00:43:48,838
will inspect one node from open, so it will
terminate either when open is empty or when

393
00:43:48,838 --> 00:43:54,750
it found the goal state it will always find
the goal state if it exist because it will

394
00:43:54,750 --> 00:43:57,989
at some
point enter the open. It will always pick

395
00:43:57,989 --> 00:44:03,659
node some open and open is the finite list
specially given the fact that we are prove

396
00:44:03,659 --> 00:44:06,809
we are moving the duplicates we are never
adding the same nodes again.

397
00:44:06,809 --> 00:44:12,190
So, the open have only the finite set to start
with and in the worst case it will pick them

398
00:44:12,190 --> 00:44:16,420
one by one and in a recycle and remove it
and say I cannot find the solution. When the

399
00:44:16,420 --> 00:44:24,570
solution exists at some point, it will be
picked by open pick by this step here and

400
00:44:24,570 --> 00:44:26,720
it will
say succeed what is the difference between

401
00:44:26,719 --> 00:44:33,118
depth first and best first. The only difference
is that best first is sorting at least conceptually

402
00:44:33,119 --> 00:44:38,150
it is sorting the open list every time
essentially though that is the only change,

403
00:44:38,150 --> 00:44:47,480
but it is going to pick every node once before
it terminate, so completeness follows.

404
00:44:47,480 --> 00:44:48,480
..

405
00:44:48,480 --> 00:44:58,108
Let us talk about time and space in one breadth
here very quickly what would you say

406
00:44:58,108 --> 00:45:13,088
time complexity, let us worry let us not worry
about space. So, much in this moment, let

407
00:45:13,088 --> 00:45:22,710
us talk about time it really depends on how
good the heuristic function is. Now, you can

408
00:45:22,710 --> 00:45:29,400
see that if the heuristic function is perfect,
then the time complexity will be linear you

409
00:45:29,400 --> 00:45:35,150
will always go to the correct node linear
in what linear in depth right. So, the depth

410
00:45:35,150 --> 00:45:38,000
is
this search tree, you will always choose make

411
00:45:38,000 --> 00:45:43,050
the correct choice at every level and in
linear time you will reach the goals.

412
00:45:43,050 --> 00:45:47,970
In the worst case, it will exponential essentially
if the heuristic function is bad the

413
00:45:47,969 --> 00:45:51,608
heuristic function could be actually malicious
essentially like you know in some cities

414
00:45:51,608 --> 00:45:56,558
you find ask somebody how do I go there and
then tell you the opposite direction. So,

415
00:45:56,559 --> 00:46:02,809
even in the worst case you will only do an
exponential amount of search essentially,

416
00:46:02,809 --> 00:46:08,950
so it
really depends upon the heuristic function

417
00:46:08,949 --> 00:46:14,568
likewise for space it really depends upon
the

418
00:46:14,568 --> 00:46:23,230
heuristic function. Now, in the search tree
that we were drawing like this solves the

419
00:46:23,230 --> 00:46:27,789
open
list for breadth first search and the open

420
00:46:27,789 --> 00:46:34,750
list for depth first was like this. Now, it
is really

421
00:46:34,750 --> 00:46:43,338
difficult to give you a feel of this exponentially
going pen list of breadth first search, but

422
00:46:43,338 --> 00:46:47,750
you must keep in mind that every time when
I go from one level to the next.

423
00:46:47,750 --> 00:46:51,960
I am multiplying the length if you want to
call it by b essentially where b is the bunching

424
00:46:51,960 --> 00:46:58,119
factor which is not really depicted in the
diagram this is just kind of a schematic diagram,

425
00:46:58,119 --> 00:47:04,869
but every time it is going becoming longer
by b. So, therefore, it is going exponentially,

426
00:47:04,869 --> 00:47:11,900
.whereas the for breadth depth first search
the open is basically kind of proportional

427
00:47:11,900 --> 00:47:16,400
to
length and its linear that we have argued

428
00:47:16,400 --> 00:47:24,019
it turns out that for best first search. Typically,
the search frontier looks like this, now this

429
00:47:24,019 --> 00:47:31,579
is typical of course, which means it is not
really linear and it generally tends to be

430
00:47:31,579 --> 00:47:37,500
more towards exponentially in nature in practice
essentially.

431
00:47:37,500 --> 00:47:48,309
There is one thing that you should consider
if you have solved this kind of problems or

432
00:47:48,309 --> 00:47:50,130
if
you have solved Rubik’s kind of problems

433
00:47:50,130 --> 00:47:55,450
just try to imagine that sometimes you have
to

434
00:47:55,449 --> 00:47:59,750
go against the heuristic function. We will
come to this point later in the sense that

435
00:47:59,750 --> 00:48:01,829
if you
are counting for example, the number of tiles

436
00:48:01,829 --> 00:48:07,369
and place or something like that then at
some point you have to disrupt something that

437
00:48:07,369 --> 00:48:09,970
you have already done. So, for example,
in the Rubik’s cube you have done the top

438
00:48:09,969 --> 00:48:15,689
phase and then do to do the second layer you
have to temporarily disrupt the top phase

439
00:48:15,690 --> 00:48:18,298
now heuristic function would be very upset
about such things.

440
00:48:18,298 --> 00:48:22,588
Now, you have made the top phase and then
you are disrupting it will not reflect nicely

441
00:48:22,588 --> 00:48:29,038
in your search essentially. So, we will come
to those issues later completeness time space

442
00:48:29,039 --> 00:48:43,011
and what else quality I will differ this discussion
quality later just think about is do you

443
00:48:43,010 --> 00:48:48,460
think that this will give you an optimal solution
or not and we will come to this later. I

444
00:48:48,460 --> 00:48:52,199
just want to spend the couple of minute on
the other side which is the domain

445
00:48:52,199 --> 00:49:06,750
independent 
and without going into details I will just

446
00:49:06,750 --> 00:49:19,630
say this that domain independent
heuristic function solves what we call a relaxed

447
00:49:19,630 --> 00:49:34,160
problem. So, it solves a relaxed problem
and. So, what is the key difference the static

448
00:49:34,159 --> 00:49:38,588
function only looks at the given state and
the goal state and gives you a value.

449
00:49:38,588 --> 00:49:47,570
So, relaxed problem and when we look at planning
we will see if we get time we will

450
00:49:47,570 --> 00:49:52,219
look at this in a little bit more detail,
but the relaxed problem is modifying the original

451
00:49:52,219 --> 00:50:00,889
problem, so that it can be solve more easily
essentially. So, to give you an example when

452
00:50:00,889 --> 00:50:13,750
you look at the eight puzzle like this, now
if I have to go from two to if I if two has

453
00:50:13,750 --> 00:50:17,298
to go
here or if two has to let us say seven has

454
00:50:17,298 --> 00:50:25,420
to go here in place of one. We want to move
seven to one now in the real eight puzzle

455
00:50:25,420 --> 00:50:29,440
you have to first move eight out of the way,
then you have to push seven up.

456
00:50:29,440 --> 00:50:35,528
Then, you have to you know somehow create
the gap by pushing, so we have pushed

457
00:50:35,528 --> 00:50:41,170
eight here, then you push 6 and then 5 and
then 4 and then 3 then 2 and then 1 and then

458
00:50:41,170 --> 00:50:47,220
.you push seven up essentially you have to
do a lot of moves in the real world.

459
00:50:47,219 --> 00:50:57,189
Essentially, imagine an eight puzzle in which
you can slide on top of other slides or sit

460
00:50:57,190 --> 00:51:05,539
on top of other slides other tiles essentially
which means I have modified my problem

461
00:51:05,539 --> 00:51:11,750
that I can make a move a seven can come here.
Then, it can come here essentially, it does

462
00:51:11,750 --> 00:51:16,530
not have to be a blank tile to move into which
is the real problem essentially the relaxed

463
00:51:16,530 --> 00:51:19,780
problem, you can move over on the tile and
sit on top of another tile.

464
00:51:19,780 --> 00:51:26,349
Now, you can see that if I am working with
this relaxed problem I can easily find how

465
00:51:26,349 --> 00:51:35,599
many steps it take for me to go from seven
to one this is two steps now which where we

466
00:51:35,599 --> 00:51:40,260
devise the static function. Also, we gave
the same value remember that distance to the

467
00:51:40,260 --> 00:51:47,528
goal step he said the difference between the
static. This dynamic domain independent

468
00:51:47,528 --> 00:51:53,710
function is that the static domain function
was devise specifically for the eight puzzle

469
00:51:53,710 --> 00:52:00,309
whereas, when we learn how to sort of pose
problems in the uniform manner. We can see

470
00:52:00,309 --> 00:52:05,349
that we can pose problems and then we can
pose relaxed problems in a domain

471
00:52:05,349 --> 00:52:17,390
independent fashion and they can be solved
typically in polynomial time that is a key

472
00:52:17,389 --> 00:52:19,250
thing.
So, what is a difference between a static

473
00:52:19,250 --> 00:52:24,679
function and a dynamic function or domain
independent static function we assume is solved

474
00:52:24,679 --> 00:52:30,848
in constant time because it only looks at
the given state. The goal state and gives

475
00:52:30,849 --> 00:52:37,818
you a value whereas, this domain independent
function actually expose the space, but under

476
00:52:37,818 --> 00:52:42,480
different constraints which are relaxed
from the original problem. So, it still may

477
00:52:42,480 --> 00:52:45,559
search up to the certain depth essentially,
but

478
00:52:45,559 --> 00:52:50,778
problem has been relaxed to such an extent
that to solve the relaxed problem it needs

479
00:52:50,778 --> 00:52:57,409
only polynomial time u that is a general idea.
We will try and come back to that later, but

480
00:52:57,409 --> 00:53:01,299
it is done in a domain independent fashion
I just illustrated it with the eight puzzle

481
00:53:01,300 --> 00:53:02,390
here
essentially.

482
00:53:02,389 --> 00:53:08,838
So, what happens now you have a heuristic
function which is computed whenever n is

483
00:53:08,838 --> 00:53:14,239
generated with a static function this is computed
in constant time. So, obviously, it likely

484
00:53:14,239 --> 00:53:22,679
to be helpful the question is if I have a
polynomial time function sitting here is it

485
00:53:22,679 --> 00:53:26,009
going to
help which is attractive. Then, I can do this

486
00:53:26,010 --> 00:53:30,030
in a domain independent fashion I do not
have to say oh this is the city map. I can

487
00:53:30,030 --> 00:53:32,700
use a Euclidean distance or that is a eight
puzzle

488
00:53:32,699 --> 00:53:35,939
I can or that is a Rubik’s cube or I can
count the red tiles and the blue tiles.

489
00:53:35,940 --> 00:53:41,579
.I do not have to do any of that reasoning
I will say in some well defined manner, I

490
00:53:41,579 --> 00:53:44,519
will
change the problem definition to such in such

491
00:53:44,519 --> 00:53:48,769
a manner that it can be solved in
polynomial time and then the length of that

492
00:53:48,769 --> 00:53:54,960
solution I will use as a heuristic value here.
So, you have plugged in a polynomial function

493
00:53:54,960 --> 00:53:59,369
here and the question is does it help you
have plugged in this polynomial function inside

494
00:53:59,369 --> 00:54:05,088
this thing which is basically exponential
in nature and the answer is that yes in practice.

495
00:54:05,088 --> 00:54:12,880
It helps and we will see that little bit later,
but to generalize the idea of using a heuristic

496
00:54:12,880 --> 00:54:18,160
function is to use a function which will
given the choices you have given the open

497
00:54:18,159 --> 00:54:24,699
list that you have.
It will tell you which node to inspect next

498
00:54:24,699 --> 00:54:27,009
rather than do it in a blind fashion like
depth

499
00:54:27,010 --> 00:54:33,619
first or breadth first or for that method
d f I d was using it is using some it is doing

500
00:54:33,619 --> 00:54:36,800
search
in a more informed fashion and that is why

501
00:54:36,800 --> 00:54:43,910
it is called best first search essentially.
So, we

502
00:54:43,909 --> 00:54:48,759
will take a best first search again and then
we will try to improve upon this a little

503
00:54:48,760 --> 00:54:52,309
bit we
will come back to this notion of quality and

504
00:54:52,309 --> 00:54:57,710
completeness and revisit them. Essentially,
keep in mind that time and space complexity

505
00:54:57,710 --> 00:55:01,880
on the average are still exponential in
nature they may be better exponential functions

506
00:55:01,880 --> 00:55:04,510
than the original, but that they still tend
to be exponential.

507
00:55:04,510 --> 00:55:09,410
Of course, in some domains, where the heuristic
function is very nice easy to build in

508
00:55:09,409 --> 00:55:16,250
which case you will get lot of improvement.
For example, if you are in Manhattan, then

509
00:55:16,250 --> 00:55:21,579
you can find the path quite easily I think,
so we will come back to this in the next class.

510
00:55:21,579 --> 00:55:31,579
.

