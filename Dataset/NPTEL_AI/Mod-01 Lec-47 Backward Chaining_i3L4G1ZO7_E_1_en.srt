1
00:00:10,839 --> 00:00:24,189
So, we are looking at FOL and in particularly
we are looking at reasoning aspect. We

2
00:00:24,189 --> 00:00:29,490
shall not have the time to look in to the
knowledge representation aspect too much here.

3
00:00:29,489 --> 00:00:34,659
So, we will assume some simple representation
schema which means the choice of the

4
00:00:34,659 --> 00:00:39,299
functions at we are talking about a set of
predicates a set of functions and the set

5
00:00:39,299 --> 00:00:40,609
up
business.

6
00:00:40,609 --> 00:00:52,939
Now, we saw 2 rules of infants; 1 was a universal
in sensation we said that a from for all

7
00:00:52,939 --> 00:01:09,349
x and this is an instance of that. You can
p of a and then we saw generalization it says

8
00:01:09,349 --> 00:01:20,189
that from p of a you can reduce the x p x.
So, in case you have a query of this kind

9
00:01:20,189 --> 00:01:25,149
we
saw an example of that earlier. Now, in addition

10
00:01:25,150 --> 00:01:38,280
to this there are also some rules of
substitution. So, for example, you can replace

11
00:01:38,280 --> 00:01:53,218
for all x p x with there exist x naught p
x

12
00:01:53,218 --> 00:02:11,239
and likewise it exist naught exist x p x equivalent
to for all x naught p x. So, these are

13
00:02:11,239 --> 00:02:15,629
kind of commonsense rules. So, if you see
what we are saying here we are saying that

14
00:02:15,629 --> 00:02:16,629
if

15
00:02:16,629 --> 00:02:22,169
.it is naught the case that for every x from
property p or some predicate p is to it means

16
00:02:22,169 --> 00:02:27,128
there must be some x for which p x is naught
true essentially.

17
00:02:27,128 --> 00:02:32,920
So, if you move the naught across a quantifier
it changes the nature of the quantifier. If

18
00:02:32,920 --> 00:02:37,128
you move a naught a across a universal quantifier
it becomes an existential quantifier.

19
00:02:37,128 --> 00:02:41,060
The rest of the expression does naught change
it is like you are moving a naught inside,

20
00:02:41,060 --> 00:02:45,170
but changing this likewise if you change the
move are naught across the existential

21
00:02:45,169 --> 00:02:53,199
quantifier it becomes a universal quantifier.
So, again if you look at this; this is like

22
00:02:53,199 --> 00:03:00,548
saying that for example, if p x stood for
something which is both even and odd. So,

23
00:03:00,549 --> 00:03:02,290
this
left side is saying that there does naught

24
00:03:02,289 --> 00:03:05,530
exist an x which is both even and odd which
is

25
00:03:05,530 --> 00:03:10,759
equivalent to saying that for all x which
the case at they are naught even and odd.

26
00:03:10,759 --> 00:03:13,358
So,
you can move them across on both sides. So,

27
00:03:13,359 --> 00:03:16,930
these are rules of substitutions which I
quite useful in some situations we will see

28
00:03:16,930 --> 00:03:31,890
some of them. And you might be familiar with
them they are known as de Morgan’s laws.

29
00:03:31,889 --> 00:03:42,449
Also something which are use some times
that is that for example, if you have for

30
00:03:42,449 --> 00:03:47,250
all x for all by p x y there p some predicate
this is

31
00:03:47,250 --> 00:03:52,759
equivalent to for all y for all x p x y.

32
00:03:52,759 --> 00:04:01,370
So, the quantifier of the same kind you can
change without changing the meaning of the

33
00:04:01,370 --> 00:04:11,430
sentence. Likewise for there exist there exists
y there exist y; there exist x they would

34
00:04:11,430 --> 00:04:14,319
be
similar, but if the quantifier of different

35
00:04:14,318 --> 00:04:17,089
kind then you cannot do that. So, if you say
for

36
00:04:17,089 --> 00:04:29,888
all x there exists the y p x y this is not
equivalent to saying that there exist a y

37
00:04:29,889 --> 00:04:41,199
thus that
for all x p x y. So, you can try and think

38
00:04:41,199 --> 00:04:43,199
of a counter example to show that this is
not the

39
00:04:43,199 --> 00:04:54,680
case. So, for example, for every number x
there exist a number y which is bigger than

40
00:04:54,680 --> 00:04:58,639
x.
So, p stands for bigger than or greater than

41
00:04:58,639 --> 00:05:03,460
then this statement is true whereas this
statement say that there exist a y which is

42
00:05:03,459 --> 00:05:09,649
greater than every number. So, which is
obviously not true essentially So, you cannot

43
00:05:09,649 --> 00:05:15,269
switch 2 quantifies of different kind if you
do switched and the meaning change as the

44
00:05:15,269 --> 00:05:18,649
truth value also will change. And you are
talking about something totally different

45
00:05:18,649 --> 00:05:22,829
here and something totally different here.
Whereas, here there is no difference if they

46
00:05:22,829 --> 00:05:26,609
have the same kind then you can switch the
quantifiers and it does not change the meaning.

47
00:05:26,610 --> 00:05:32,229
Here we are saying that if you if you have
a negation sign you can move it inside

48
00:05:32,228 --> 00:05:37,399
inwards towards the expression and what it
does? It changes the sign of the quantifier

49
00:05:37,399 --> 00:05:41,629
.changes the nature of the quantifier. Universal
quantifier becomes existential and

50
00:05:41,629 --> 00:05:53,389
existential becomes universal, which is why
I had mention in the last class at it is not

51
00:05:53,389 --> 00:06:00,090
very easy to identify what is really the nature
of the quantifier. So, for example, if I make

52
00:06:00,089 --> 00:06:17,750
a statement a it does not 

53
00:06:17,750 --> 00:06:26,089
let say we are talking about people and this
statement is saying

54
00:06:26,089 --> 00:06:34,538
that they does not exist a x who is divine.
What is the nature of this variable x? Is

55
00:06:34,538 --> 00:06:41,839
it a
existential variable or is it a universal

56
00:06:41,839 --> 00:06:46,038
variable? And this becomes important, because
if

57
00:06:46,038 --> 00:06:50,959
you remember the implicit quantifier for that
we discussed in the last class you can

58
00:06:50,959 --> 00:06:56,138
replace a universally quantified variable
with a question mark and then it become

59
00:06:56,139 --> 00:06:57,139
simplistic.

60
00:06:57,139 --> 00:07:06,098
So, is this a universally quantified variable
or existentially quantified variable? So,

61
00:07:06,098 --> 00:07:10,889
the
way to look your answer is right your way

62
00:07:10,889 --> 00:07:17,220
the way to understand that is to push the
negation sign as much is possible. And then

63
00:07:17,220 --> 00:07:21,780
look at what is outer most quantifier
essentially if you push a negation sign inside

64
00:07:21,779 --> 00:07:31,109
it would become equivalent to saying that
for all x naught divine x. So, we are saying

65
00:07:31,110 --> 00:07:42,030
that everyone is naught divine which is like
saying that no 1 is divine essentially. So,

66
00:07:42,029 --> 00:07:44,008
this is the universally quantified variable.
So,

67
00:07:44,009 --> 00:07:53,520
we can replace at he want to put at in implicit
quantifier form by saying naught divine x

68
00:07:53,519 --> 00:07:56,149
I
putting a question mark that is a cementation

69
00:07:56,149 --> 00:08:00,019
we are adopting between our sense. So, that
we do not have to write the quantifier we

70
00:08:00,019 --> 00:08:01,620
do not have to process the quantifier when
we

71
00:08:01,620 --> 00:08:06,110
are liking a program to do that we can just
keep those kind of variables as universal

72
00:08:06,110 --> 00:08:11,169
variables. So, just a word about what you
do with existentially quantified variables

73
00:08:11,168 --> 00:08:12,938
when
you are talking about implicit quantifier

74
00:08:12,939 --> 00:08:16,289
from.

75
00:08:16,288 --> 00:08:17,288
..

76
00:08:17,288 --> 00:08:31,310
Let us forget a sentence like this there exist
x even x. So, it is saying that there exit

77
00:08:31,310 --> 00:08:35,059
some
number which is an even number essentially.

78
00:08:35,059 --> 00:08:42,239
The way to convert is into implicit
quantifier form and the process is called

79
00:08:42,240 --> 00:08:54,299
skolemization after legation called skolem.
So,

80
00:08:54,299 --> 00:09:07,229
well solemn who for us introduce these ideas
by replacing it with a constant even s k 12.

81
00:09:07,230 --> 00:09:19,700
So, conventionally we may say we use a name
s k this is us again between us it does

82
00:09:19,700 --> 00:09:26,750
naught impact the meaning of what we are writing
it is a constant. So, we so what are we

83
00:09:26,750 --> 00:09:31,179
done? We have remove the quantifier and replace
it we replace x by something called s k

84
00:09:31,179 --> 00:09:37,139
12. So, s k again is the sin honors or skolem
you could have use any constant as you as

85
00:09:37,139 --> 00:09:42,159
far as you remember that it is a constant
which is been introduce in this process and

86
00:09:42,159 --> 00:09:44,959
it
must naught be a constant which is being use

87
00:09:44,960 --> 00:09:51,660
anywhere else. So, you cannot say a for
example, 0 if it is a constant or something

88
00:09:51,659 --> 00:10:00,149
like that you must use some unnamed some
new name and treated as a constant after that.

89
00:10:00,149 --> 00:10:05,860
Because if you look at the meaning of the
there is some number which is even and all

90
00:10:05,860 --> 00:10:10,580
you have do saying is here that there some
numbers which I am calling s k 12. And that

91
00:10:10,580 --> 00:10:15,259
is even essentially, because you may naught
really know what that number is, but you

92
00:10:15,259 --> 00:10:25,090
can do that. If you have something like this
or statement like this for all x there exists

93
00:10:25,090 --> 00:10:33,639
y p
x y they if you look at the what is the sentences

94
00:10:33,639 --> 00:10:38,819
saying the sentences saying you should
always read the quantifier from left to right

95
00:10:38,820 --> 00:10:43,020
that for every x there exist a y. So that
p x y

96
00:10:43,019 --> 00:10:49,120
.is true essentially. So, for example, for
every x there exist search y which is greater

97
00:10:49,120 --> 00:10:51,100
than
x essentially. So, that is an example that

98
00:10:51,100 --> 00:10:57,009
we mentioned in the last class we can this
into

99
00:10:57,009 --> 00:11:13,870
an implicit quantifier form by writing it
as p x s k eleven x. So, what are we saying

100
00:11:13,870 --> 00:11:21,289
here
when we have a existentially quantified variable

101
00:11:21,289 --> 00:11:30,860
inside scope of a universally quantified
variable then we are replacing that variable

102
00:11:30,860 --> 00:11:36,029
with the function of the other variable and
the function is the skolem function.

103
00:11:36,029 --> 00:11:52,069
So, this is the this is the skolem constant
of x So, what is this function we do not know

104
00:11:52,070 --> 00:11:59,810
what that function is it is some function
and what we intent by the usage of the word

105
00:11:59,809 --> 00:12:05,629
function here is that the value that the variable
can take is dependent upon the value that

106
00:12:05,629 --> 00:12:15,309
x can take. So, again if p stands for greater
than 

107
00:12:15,309 --> 00:12:19,399
and the implication and the meaning of
this is at y is greater than x because the

108
00:12:19,399 --> 00:12:22,559
meaning is always determine by us. It depends
upon the relation that you are talking about

109
00:12:22,559 --> 00:12:27,979
essentially then what we are saying is that
for

110
00:12:27,980 --> 00:12:34,039
every x you can choose a y. So, is that y
is greater than x so that y that it choose

111
00:12:34,039 --> 00:12:37,759
depends
upon x and therefore, we can think of it as

112
00:12:37,759 --> 00:12:42,909
a function of x. We do not know what that
function is, but it some function as for as

113
00:12:42,909 --> 00:12:52,139
reasoning in concerned will treated as a
function and translate this into this statement.

114
00:12:52,139 --> 00:13:04,629
So, this so in general off course if you have
for all x 1 for all x 2 for all x n p x 1

115
00:13:04,629 --> 00:13:15,409
x 2 y
then you will translated to p of x 1. So,

116
00:13:15,409 --> 00:13:20,139
I should put a question mark here because
x is the

117
00:13:20,139 --> 00:13:47,000
universally quantified variable x 1 so this
y which is in the scope. So, there exist the

118
00:13:47,000 --> 00:13:52,080
y
here is in the scope of all these universal

119
00:13:52,080 --> 00:13:55,160
quantifier for x 1 to x n. So, this y become
to

120
00:13:55,159 --> 00:14:02,719
skolem function of x 1 to x n. So, in general
you just look at what are the quantifiers

121
00:14:02,720 --> 00:14:05,769
on
the on this side universal quantifiers on

122
00:14:05,769 --> 00:14:07,600
this side and make that variable of function
of

123
00:14:07,600 --> 00:14:20,680
that. If I had something like this there exists
x for all for all y p y p x y then I would

124
00:14:20,679 --> 00:14:42,559
replace it with p s k 5 y. So, this entire
process of converting a sentence into implicit

125
00:14:42,559 --> 00:14:47,859
quantifier from now it is we call it as skolemization
after this suggestions skolem

126
00:14:47,860 --> 00:14:49,000
essentially.

127
00:14:49,000 --> 00:14:50,000
..

128
00:14:50,000 --> 00:14:54,240
So, in the last class, we had started looking
at forward chaining we had looked at the role

129
00:14:54,240 --> 00:15:10,279
of modified modus ponens mindset that if you
have alpha prime and alpha implies beta

130
00:15:10,279 --> 00:15:19,259
then you can produce beta prime from there.
And if you move from alpha prime to beta

131
00:15:19,259 --> 00:15:31,669
prime the process is called forward chaining.
So, in forward chaining you have alpha

132
00:15:31,669 --> 00:15:46,849
prime and then you can add beta prime in backward
chaining 

133
00:15:46,850 --> 00:15:57,759
you would not to show beta
prime. So, we use it is connection show beta

134
00:15:57,759 --> 00:16:12,289
prime so we have sub goal now show alpha
prime. So, backward chaining we just started

135
00:16:12,289 --> 00:16:16,860
looking at in the last class it works with
goals by goals. We mean something that we

136
00:16:16,860 --> 00:16:23,730
want to show to be true a formula that we
want to show to be through. And looks for

137
00:16:23,730 --> 00:16:26,250
implications of this kind alpha implies beta
so

138
00:16:26,250 --> 00:16:29,980
basically it is using mod modus ponens in
a slightly different form. Or if you think

139
00:16:29,980 --> 00:16:32,220
a
little bit about this you can see that what

140
00:16:32,220 --> 00:16:35,180
backward chaining is the doing is this kind
of

141
00:16:35,179 --> 00:16:40,659
modus may be that will become clearer as we
move forward that is a different rule of

142
00:16:40,659 --> 00:16:43,419
infonants.

143
00:16:43,419 --> 00:17:06,269
So, if we have our original Socratic argument
which said that man x implies mortal x and

144
00:17:06,269 --> 00:17:11,529
in our database. So, this is there in the
database and this is there in the database

145
00:17:11,529 --> 00:17:23,480
which is
man Socrates. And off course, you may have

146
00:17:23,480 --> 00:17:29,389
as a date of birth less ignores that for the
movement and you want it to show that mortal

147
00:17:29,388 --> 00:17:33,269
Socrates is true. Then forward chaining
would apply this modus modified modus ponens

148
00:17:33,269 --> 00:17:36,000
rules and in this form and this form this

149
00:17:36,000 --> 00:17:44,519
.thing. Whereas, backward chaining we are
not written the it in this form, but it says

150
00:17:44,519 --> 00:17:48,288
that
which show beta prime man with alpha implies

151
00:17:48,288 --> 00:18:02,500
beta you can reduce it to show alpha
prime essentially. So, show mortal Socrates

152
00:18:02,500 --> 00:18:23,019
how does it is works if you recall we match
this with this with a unifier x is equal to

153
00:18:23,019 --> 00:18:35,370
Socrates we will look at unification a little
later.

154
00:18:35,369 --> 00:18:50,489
So, we apply this unifier to this and according
to this backward chaining process we

155
00:18:50,490 --> 00:19:06,380
reduce this to show 
man Socrates. So, let us put wholes inside

156
00:19:06,380 --> 00:19:13,080
boxes so that we can
distinguish between goels and fact. So, this

157
00:19:13,079 --> 00:19:15,379
is a fact this is a fact this is a goel; this
is a

158
00:19:15,380 --> 00:19:19,970
goel and so on. So, what this off course,
it severe way to simplify to solve the goal

159
00:19:19,970 --> 00:19:22,220
and
so see with that is present in the data base.

160
00:19:22,220 --> 00:19:29,750
So, in this example, when you have this goal
of show that that man Socrates is true then

161
00:19:29,750 --> 00:19:30,750
you simply look up the database.

162
00:19:30,750 --> 00:19:37,898
And you will find that it true essentially
will in the movement we will look at how the

163
00:19:37,898 --> 00:19:46,258
language prolog is basically doing this which
is it is doing backward chaining. And if it

164
00:19:46,259 --> 00:19:53,048
if a fact is present in the database or in
your program prolog program it is really true

165
00:19:53,048 --> 00:20:00,720
essentially. But the nice thing about reasoning
with logic is that we can ask a question

166
00:20:00,720 --> 00:20:23,069
like is this formula true that it does there
exist the y such that mortal y is true this

167
00:20:23,069 --> 00:20:31,119
is what
is given to us this is a database. And this

168
00:20:31,119 --> 00:20:35,689
is a database even this database is that satement
true that there exist the y so that mortal

169
00:20:35,690 --> 00:20:44,058
y is true. So, I intentionally use a different
variable here y and here an x here it is naught

170
00:20:44,058 --> 00:20:49,460
really necessary forming to do that.
Because when you look at this statement then

171
00:20:49,460 --> 00:20:57,058
it is saying that for there exist some y such
that pus that y is mortal. I could have Jolivel

172
00:20:57,058 --> 00:21:02,928
said there exist some x such that x is mortal,
but because we want to set off keep above

173
00:21:02,929 --> 00:21:08,288
formally spleen and a part and is a practice
that is necessary as we will see.

174
00:21:08,288 --> 00:21:16,069
We use a different variable name which is
a is a goal noise know if I if this is my

175
00:21:16,069 --> 00:21:24,888
goel
that show that this is a case. Then we invert

176
00:21:24,888 --> 00:21:34,678
that is skolemization convention when you
are doing forward chaining a formula like

177
00:21:34,679 --> 00:21:43,899
this a a universally a formula which has a
universally quantify variable is put with

178
00:21:43,898 --> 00:21:52,939
a question mark here. Whereas, in backward
chaining an existential variable is denoted

179
00:21:52,940 --> 00:21:57,659
by a question mark that is specifically in
backward chaining when you are talking about

180
00:21:57,659 --> 00:22:03,559
show when you are talking about goels
sorry for goels the convention is reverse.

181
00:22:03,558 --> 00:22:13,599
So, I will this as mortal y so again let be
that

182
00:22:13,599 --> 00:22:28,339
when I write show mortal y in this form this
notation denotes and existentially contified

183
00:22:28,339 --> 00:22:33,399
variable that is true only for variables which
occur inside goels. So, inside goels a

184
00:22:33,400 --> 00:22:39,450
.convention is reverse essentially and the
next class we will see why that makes sense

185
00:22:39,450 --> 00:22:45,410
but
you can try and guess.

186
00:22:45,410 --> 00:22:51,509
So, I can ask a query existentially query
so this is now becoming like little bit like

187
00:22:51,509 --> 00:22:53,609
a
database essentially activity. So, you have

188
00:22:53,609 --> 00:22:56,339
some set of acts available to you and you
are

189
00:22:56,339 --> 00:23:02,990
asking a query is there some entity with satisfy
certain properties. So, if you are saying

190
00:23:02,990 --> 00:23:08,179
somebody like something like is there in employee
he wants more than 10000 rupees and

191
00:23:08,179 --> 00:23:15,379
something and you get some results out of
that essentially. The difference between

192
00:23:15,378 --> 00:23:25,289
something like RDBA BMS and using login is
that logic can make inferences on the way

193
00:23:25,289 --> 00:23:30,168
essentially to retrieve answers for you. So,
when you asking a question that is there

194
00:23:30,169 --> 00:23:35,830
somebody whose mortal in the knowledge base
or data base whatever you want to call it.

195
00:23:35,829 --> 00:23:40,778
The knowledge base has only 2 statements in
our small knowledge base that Socrates is

196
00:23:40,778 --> 00:23:47,388
the man and that all women are mortal a knowledge
base does not say that any one is

197
00:23:47,388 --> 00:23:51,319
mortal any specific individual is mortal.

198
00:23:51,319 --> 00:23:57,409
But backward chaining in particular and reasoning
in login in general allow you to ask

199
00:23:57,410 --> 00:24:03,119
existential queries like this. And answer
those queries after a process of doing some

200
00:24:03,118 --> 00:24:09,028
inferences making some direction. So, what
do we do? We match this show mortal x

201
00:24:09,028 --> 00:24:14,859
with the right hand side of our statement
implication mortal x. So, we say x equal to

202
00:24:14,859 --> 00:24:18,539
y is
the substitution you want so this becomes

203
00:24:18,539 --> 00:24:25,999
mortal y. So, this case translated to show
man

204
00:24:25,999 --> 00:24:34,480
y so our query is about. So, it is still an
existential query it is a easier someone whose

205
00:24:34,480 --> 00:24:39,538
mortal gets translated into a sub query or
a subgoel which is easier some whose the man

206
00:24:39,538 --> 00:24:45,539
essentially now that can be answer by the
database yes Socrates is the man. So, we can

207
00:24:45,539 --> 00:24:51,168
communicate the query written the answer to
this query by saying yes y equal to Socrates

208
00:24:51,169 --> 00:24:56,179
is the answer to your question. So, in the
last class, we had briefly mentioned that

209
00:24:56,179 --> 00:24:58,298
you
could define. So, let say you want to define

210
00:24:58,298 --> 00:25:05,048
grandfather or let say you want to define
grand pa grandparent.

211
00:25:05,048 --> 00:25:06,048
..

212
00:25:06,048 --> 00:25:19,700
So, you might want a statement like this a
for all x for all y grand. So, let say g m

213
00:25:19,700 --> 00:25:27,058
stands
for grand ma x y and let say this means that

214
00:25:27,058 --> 00:25:32,940
x is the grandmother of y implies. Let say
g

215
00:25:32,940 --> 00:25:38,990
p stands for grandparent let say for some
reason we want to we want to this put this

216
00:25:38,990 --> 00:25:40,950
rule
into our knowledge base or database, what

217
00:25:40,950 --> 00:25:46,319
you want to call it? So, what you are saying
here is a grandmothers are grandparents then

218
00:25:46,319 --> 00:25:53,519
you could have a role like for all x for all
y

219
00:25:53,519 --> 00:26:10,210
g f and the same thing. Then you could have
a role which says a for all x for all y and

220
00:26:10,210 --> 00:26:47,700
for
all z mother x y and father z x implies grandfather

221
00:26:47,700 --> 00:26:58,179
z y. I could have a role of this kind
which says that for all x for all y for all

222
00:26:58,179 --> 00:27:02,129
z if x is the mother of y and z is the father
of x

223
00:27:02,128 --> 00:27:09,689
then z is the grandfather of y. So, you could
imagine that you have billing a database of

224
00:27:09,690 --> 00:27:14,759
relationships where you are defining how what
is relationship means what is grandfather

225
00:27:14,759 --> 00:27:18,849
abouts a grandmother abouts a grandparent
and so on and so forth. And then you should

226
00:27:18,849 --> 00:27:24,109
be able to ask a query you should give us
database of acts. So, let say the basic database

227
00:27:24,109 --> 00:27:37,849
only contents a mother child or let say parent
child and the gender of each person. So, I

228
00:27:37,849 --> 00:27:44,009
could say a Jane is a parent of tom and Jane
is female and Tom is male.

229
00:27:44,009 --> 00:27:48,240
So, I could have this kind of database. So,
there is only 1 relation parent child

230
00:27:48,240 --> 00:27:53,319
relationship and general relationship then
you can define a mother at saying that x is

231
00:27:53,319 --> 00:27:57,278
the
mother of y if x is the parent of y and x

232
00:27:57,278 --> 00:28:00,898
is female. So, you could do all that kind
of staff

233
00:28:00,898 --> 00:28:04,638
we will naught get into the details, but you
could have a knowledge base of this kind.

234
00:28:04,638 --> 00:28:10,138
.And then you could ask a question how is
Peter related to Jane? For example, you know

235
00:28:10,138 --> 00:28:14,349
then the system should find whether what is
the relation between them? Off course, you

236
00:28:14,349 --> 00:28:19,819
cannot ask this very generic question is to
how it is related you can ask something like

237
00:28:19,819 --> 00:28:26,059
whose Janes paternal uncle. For example, you
could ask such questions essentially let

238
00:28:26,059 --> 00:28:31,628
say we in talking about grandparents whose
grandparent. And that is about to basic query

239
00:28:31,628 --> 00:28:48,418
about then you can see that grandparent x
y can be solve in 2 is that either you are

240
00:28:48,419 --> 00:28:56,320
a
grand pa x is the grandfather of y how x is

241
00:28:56,319 --> 00:29:18,308
the grandmother of y? Then you could say x
is the grandfather of y if you could use this

242
00:29:18,308 --> 00:29:24,558
as 1 rule which says that now you have to
a

243
00:29:24,558 --> 00:29:35,009
bit careful here a father x z. So, I am just
using different name such to be consistent

244
00:29:35,009 --> 00:29:45,380
here
and mother z y. And you can imagine that there

245
00:29:45,380 --> 00:29:51,869
is a another rule which uses father and
father in both the places so that 2 possibilities

246
00:29:51,868 --> 00:29:55,829
here.

247
00:29:55,829 --> 00:30:04,149
So, you can see what is happening here that
is the space in which backward chaining

248
00:30:04,150 --> 00:30:12,840
operates if you ask a query about something
is Jane the grandfather of Peter then this

249
00:30:12,839 --> 00:30:19,199
system will apply. So, in backward chaining
you match with right hand side of an

250
00:30:19,200 --> 00:30:23,950
implication and c is the left hand side can
become a subgoel or you can match either with

251
00:30:23,950 --> 00:30:29,330
grandparent So, you can match either with
this rule or with this rule in both cases

252
00:30:29,329 --> 00:30:34,720
grandparent will match. So, you could either
use r 1 or 2 if you called 1 rule will take

253
00:30:34,720 --> 00:30:40,139
you here another rule will take you to grandmother.
So, either x is a grandfather of y or x

254
00:30:40,138 --> 00:30:48,979
is a grandmother of y then grandfather if
x is a grandfather of y. It could be that

255
00:30:48,980 --> 00:30:52,069
x is the
father of z who is the mother of y or it could

256
00:30:52,069 --> 00:30:58,839
be that x is the father of z who is the father
of y both are possible. So, you have all these

257
00:30:58,839 --> 00:31:05,509
question possibilities and the space that
backward chaining we have to search is that

258
00:31:05,509 --> 00:31:15,038
is an ando trees essentially and what prolog
dose is backward it does depth first search

259
00:31:15,038 --> 00:31:39,999
on that tree. So, let we rewrite this you
know I

260
00:31:39,999 --> 00:31:53,089
am skipping in the step of skolemization which
in this cases simple because we are only

261
00:31:53,089 --> 00:31:57,628
universally quantified variables. So, you
can just replace everything with a question

262
00:31:57,628 --> 00:32:07,509
mark before that if you were to write this
in prolog you would write it as something

263
00:32:07,509 --> 00:32:09,528
like
this g p.

264
00:32:09,528 --> 00:32:10,528
..

265
00:32:10,528 --> 00:32:16,640
So, prolog is this the different convention
pro see we are using a convention that

266
00:32:16,640 --> 00:32:21,489
question mark stands for the variable and
something without a question mark stands for

267
00:32:21,489 --> 00:32:24,319
a
constant. It should be a constant or existentially

268
00:32:24,319 --> 00:32:28,058
quantified variable which is the skolem
constant or something like that it does not

269
00:32:28,058 --> 00:32:32,319
matter. But that is a convention way using
prolog is this the different convention prolog

270
00:32:32,319 --> 00:32:39,950
uses the case that when you have x and y
uppercase letters then it is a variable. So,

271
00:32:39,950 --> 00:32:49,009
those of you why use prolog would know this
so let us stick to our convention which is

272
00:32:49,009 --> 00:33:01,878
to use a question mark. So, we write the
consequent first and then we write the antecedent.

273
00:33:01,878 --> 00:33:15,189
So, this same rule let us write it like
this 

274
00:33:15,190 --> 00:33:20,190
so what is happened I have taken this rule
and rewritten it like this are you I have

275
00:33:20,190 --> 00:33:29,490
away the quantifiers I have convert it to
an implicit quantifier form. And I have the

276
00:33:29,490 --> 00:33:31,798
order
in which you are writing in the normal rule

277
00:33:31,798 --> 00:33:34,819
you write there antecedents on the left hand
side and the consequent on the right hand

278
00:33:34,819 --> 00:33:40,298
side in this notation. I am write in the
consequent on the left hand side and the antecedent

279
00:33:40,298 --> 00:33:43,440
on the right hand side and I have
change the direction of that.

280
00:33:43,440 --> 00:33:49,019
So, have use an arrow instead of that sign
here. So, again those of you use prolog would

281
00:33:49,019 --> 00:33:53,419
know that prolog this is something like this
instead of the arrow sign, but it means a

282
00:33:53,419 --> 00:33:58,269
same thing that is only a matter of convention.
This is the easier for us to understand that

283
00:33:58,269 --> 00:34:06,308
ther direction of implication is from right
to left. Then I would write the second

284
00:34:06,308 --> 00:34:26,630
.statement as g p x y g m x y then g f x y
then somewhere I would write a statement for

285
00:34:26,630 --> 00:34:36,130
g
m then g f which is what I have written here

286
00:34:36,130 --> 00:34:50,539
which is that g m x y if a mother x y prolog
is it is a coma instead of. And so we will

287
00:34:50,539 --> 00:35:05,840
also use a comma here the keep in mind that
this coma basically stands for in and so the

288
00:35:05,840 --> 00:35:07,870
same set of statement to either writing in
a

289
00:35:07,869 --> 00:35:12,900
different. We are not changing anything we
have into implicit quantifier from and we

290
00:35:12,900 --> 00:35:15,639
are
writing it consequent on the left hand side

291
00:35:15,639 --> 00:35:18,000
and antecedent on the right hand side.

292
00:35:18,000 --> 00:35:21,630
And we are replacing ands by comas and this
kind of staff, but the statements are still

293
00:35:21,630 --> 00:35:24,269
the
same they are still the same universally quantified

294
00:35:24,269 --> 00:35:35,400
statements in logic. Somewhere down
there I would have let us say a mother Jane

295
00:35:35,400 --> 00:35:54,910
Peter sorry oh ya a 
x is the grandfather of y.

296
00:35:54,909 --> 00:36:06,859
So, y is the mother of no sorry z is the mother
of y and x is the grandfather of x is the

297
00:36:06,860 --> 00:36:19,329
father of z thanks. Somewhere I would have
a statement saying a mother Jane Peter for

298
00:36:19,329 --> 00:36:31,599
example, and father Peter Jane and may be
other fact also, you recognize this as a prolog

299
00:36:31,599 --> 00:36:37,099
programme. I hope prolog programme a statement
of these kinds now this is a restricted

300
00:36:37,099 --> 00:36:41,279
form of logic, but we do not go into that
the restriction here is that the consequent

301
00:36:41,280 --> 00:36:43,891
can
only be one predicate. You cannot have more

302
00:36:43,891 --> 00:36:50,730
than you cannot have alls inside here and
so and so forth, but you can recognizes as

303
00:36:50,730 --> 00:36:53,010
the prolog programme what does prolog do?

304
00:36:53,010 --> 00:36:54,010
.

305
00:36:54,010 --> 00:37:15,500
If I ask a query like is there or show grandparent
x. So, a let us say Peter z or something

306
00:37:15,500 --> 00:37:30,780
.like that. The reason for writing things
in this invited form is, because it makes

307
00:37:30,780 --> 00:37:33,130
a task of
matching simpler you always match with what

308
00:37:33,130 --> 00:37:37,789
is on the left hand side in you have a
programme and the right hand side is the step

309
00:37:37,789 --> 00:37:47,230
of making that inference. So, if I ask a
query like that is there someone whose peters

310
00:37:47,230 --> 00:37:55,070
grandson or is there someone to be more
precise whose grandfather is Peter. Then prolog

311
00:37:55,070 --> 00:38:02,320
starts looking from top to down trying to
match this with the things on the left hand

312
00:38:02,320 --> 00:38:06,860
side in this example very conveniently. It
matches the first element it is in so when

313
00:38:06,860 --> 00:38:10,160
it matches this it poses this as the goel.

314
00:38:10,159 --> 00:38:17,549
So, at last whether Peter is a grandmother
of some z essentially So, it will translate

315
00:38:17,550 --> 00:38:20,870
that
gole into the subgoel. So, backward chaining

316
00:38:20,869 --> 00:38:24,659
we said was moving from right to left in
this notation. So, in this notation it is

317
00:38:24,659 --> 00:38:27,299
moving from left to right. So, it basically
goes from

318
00:38:27,300 --> 00:38:33,000
goels to subgoel ask that as a new query and
as you can imagine I should have something

319
00:38:33,000 --> 00:38:48,280
like I have a I could use parent here parent
here. And then a female Jane and so on and

320
00:38:48,280 --> 00:38:52,560
so
both I mean that is a data that I originally

321
00:38:52,559 --> 00:38:58,269
said we have the Jane is female Peter is male
and Jane is male and that kind of staff. This

322
00:38:58,269 --> 00:39:07,920
will get translated to g m grandmother Peter
z which intern will so essentially here going

323
00:39:07,920 --> 00:39:13,780
down. So, because I written this rule first
this grandmother rule first it is like having

324
00:39:13,780 --> 00:39:16,740
this rule on this side. So, it is going down
that

325
00:39:16,739 --> 00:39:22,659
path so you can visualize what prolog is doing
as backward chaining and with a

326
00:39:22,659 --> 00:39:27,089
particular strategy which is depth first.
And the way it is implemented here is that

327
00:39:27,090 --> 00:39:29,050
the
first rule matches the that.

328
00:39:29,050 --> 00:39:34,560
So, it will it is it tried this so just imagine
that that tree was lift from left to right.

329
00:39:34,559 --> 00:39:37,250
So, it
would be going down the left side first. And

330
00:39:37,250 --> 00:39:42,920
then it would eventually with naught be able
to show that Peter is a grandmother of z it

331
00:39:42,920 --> 00:39:48,930
would back track. And then try this second
rule essentially which saying we go all the

332
00:39:48,929 --> 00:39:54,869
way down and then try the other branch.
Exactly as we had when we looked at goel trees

333
00:39:54,869 --> 00:40:02,659
with that first search first essentially.
So,

334
00:40:02,659 --> 00:40:14,170
let us look at another a example that we have
considered earlier which is that of planning

335
00:40:14,170 --> 00:40:27,480
and outing. So, if you recall when you are
looking at a goel trees the we had this task

336
00:40:27,480 --> 00:40:31,119
of
planning and outing with a friend and outing

337
00:40:31,119 --> 00:40:41,329
consisted of some 3 things that 1 evening
out 1 a entertainment and followed by dinner.

338
00:40:41,329 --> 00:40:47,989
So, eventually you know you have to finds
values for these which your friend would be

339
00:40:47,989 --> 00:40:49,039
happy with.

340
00:40:49,039 --> 00:40:50,039
..

341
00:40:50,039 --> 00:40:59,619
So, if you are remember it was something like
this that let say a let say let us call with

342
00:40:59,619 --> 00:41:07,859
a
birthday plan I do not remember what we had

343
00:41:07,860 --> 00:41:38,630
said that time. So, you have a birthday
plan made up of x y and z if you have an outing

344
00:41:38,630 --> 00:41:46,579
plane of called x and entertainment plan
called y in a dinner plan for z. And then

345
00:41:46,579 --> 00:42:01,119
you could say an outing plan is a valid plan
if it

346
00:42:01,119 --> 00:42:24,239
is an outing and likes that is a f stands
for friend x likewise a other 2 plans entertainment

347
00:42:24,239 --> 00:42:28,379
plan and a dinner pans. So, you could write
it as a prolog programme you could say that

348
00:42:28,380 --> 00:42:38,480
this is how. So, you could add f as a parameters
so x comma f here comma f here comma

349
00:42:38,480 --> 00:42:45,769
f here. So, let say f is f if stands for your
friend and let say your query is a essentially

350
00:42:45,769 --> 00:43:03,679
that. So, let me write the query here a what
is the good birthday plan x y z and let say

351
00:43:03,679 --> 00:43:09,419
your friends name is Peter and this is my
query.

352
00:43:09,420 --> 00:43:16,030
So, that question mark after this what backward
chaining will do is exactly the same

353
00:43:16,030 --> 00:43:26,910
thing that we did here earlier it would. So,
this is birthday plan then it tries to find

354
00:43:26,909 --> 00:43:36,539
an
outing and entertainment and dinner or may

355
00:43:36,539 --> 00:43:50,579
be this is have entertainment. We are said
movie in the last class it does naught matter

356
00:43:50,579 --> 00:44:04,519
and below this would be ando tree outing let
say beach or moll and things like that. And

357
00:44:04,519 --> 00:44:12,719
entertainment could be some in movie a or
movie b or movie c and restaurant could be

358
00:44:12,719 --> 00:44:20,529
some restaurant d or e or f and below that.
off course, you have the facts like whether

359
00:44:20,530 --> 00:44:31,360
your friend f likes going to the beach some
statement like 

360
00:44:31,360 --> 00:44:34,559
beach Peter it must be present in your in
your knowledge base. Because

361
00:44:34,559 --> 00:44:38,489
.that is how will instead of asking in a friend
you are saying that is there a statement like

362
00:44:38,489 --> 00:44:41,439
that in my database already.

363
00:44:41,440 --> 00:44:49,539
So, that attention that I want to draw to
you here is to the same problem that we

364
00:44:49,539 --> 00:44:56,710
encounter. Now, you must recall what does
happening there you are searching this ando

365
00:44:56,710 --> 00:45:04,909
tree and well initially we had pouse it as
a simple odd tree. But what were saying is

366
00:45:04,909 --> 00:45:09,989
that
let say that you decide that you want to go

367
00:45:09,989 --> 00:45:17,659
to a go to the beach you ask your friend shell
we go to the beach and then you are doing

368
00:45:17,659 --> 00:45:22,690
a depth first search. So, you try all these
options 1 by 1 you say shell we go to this

369
00:45:22,690 --> 00:45:25,780
movie a or shell we go to this movie b or
shell

370
00:45:25,780 --> 00:45:34,150
we go to this movie c and then try all combinations
of this. So, for example, a beach and

371
00:45:34,150 --> 00:45:44,300
a and b then beach and a and e then beach
and a and f and let say all fail. So, what

372
00:45:44,300 --> 00:45:51,950
is
happening here in backward chaining is that

373
00:45:51,949 --> 00:46:02,339
you are doing this subgoel promulgation.
And 

374
00:46:02,340 --> 00:46:08,640
so the way prolog does is there it goes from
top to down and left to right so given

375
00:46:08,639 --> 00:46:14,290
trees of goel outing and entertainment and
dinner. It will first try outing try to find

376
00:46:14,291 --> 00:46:19,460
a
value for that that say beach then entertainment.

377
00:46:19,460 --> 00:46:24,630
And then try to find a value for that let
say a and then dinner and try to find a value

378
00:46:24,630 --> 00:46:27,579
for
that d and at that point let us say it fails

379
00:46:27,579 --> 00:46:33,059
and say that no this is naught a good birthday
plan. So, it will back track and try e here

380
00:46:33,059 --> 00:46:35,369
so it is still be in this goal, but it would
try a

381
00:46:35,369 --> 00:46:39,299
different value. So, whenever back tracking
happens it happens in these same directions.

382
00:46:39,300 --> 00:46:43,130
So, when it is back tracking here it goes
up 1 step when it is back tracking here it

383
00:46:43,130 --> 00:46:46,789
goes
up. Well, where is back tracking here goes

384
00:46:46,789 --> 00:46:53,210
down 1 step and it is back tracking here it
comes f 1 step. So, it tries the first option

385
00:46:53,210 --> 00:46:54,659
for dinner and the second option for dinner
and

386
00:46:54,659 --> 00:46:59,009
the third option for dinner. And everything
fails you do naught want to do repeat this

387
00:46:59,010 --> 00:47:09,030
same search again for a different option of
b if you can figure out somehow that beach

388
00:47:09,030 --> 00:47:12,810
is
the. So, we had mention the term dependency

389
00:47:12,809 --> 00:47:20,070
directed back tracking there. So, in some
systems like in satisfaction system that is

390
00:47:20,070 --> 00:47:24,620
kind of done automatically the system keeps
track of what is the dependency? But in a

391
00:47:24,619 --> 00:47:34,929
system like this in logic or the implementation
of logic call prolog the language gives the

392
00:47:34,929 --> 00:47:42,049
user ability to control back tracking.

393
00:47:42,050 --> 00:47:51,920
So, instead of writing a statement like this
what you can do in prolog is to instead of

394
00:47:51,920 --> 00:47:54,920
this
you write the statement as follows that a

395
00:47:54,920 --> 00:48:01,840
birthday plan. So, let me just use this b
x y z f if

396
00:48:01,840 --> 00:48:14,139
outing plan then you use a special symbol
cut then and entertainment plan any user

397
00:48:14,139 --> 00:48:28,009
.special symbol and then a dinner plan. So,
instead of 3 subgoels you have added 2 extra

398
00:48:28,010 --> 00:48:34,751
subgoels these are which special subgoels
is prolog allows you. And so those you have

399
00:48:34,751 --> 00:48:41,180
use it could know the this is the cut operator
as it is called. And what it does is there

400
00:48:41,179 --> 00:48:44,699
is
basically a device given to the user or the

401
00:48:44,699 --> 00:48:47,049
programmer. If you want to say to control
back

402
00:48:47,050 --> 00:48:52,130
tracking and what it basically saying is that
if you are going to back track from this to

403
00:48:52,130 --> 00:48:58,559
this side. Then do not try a new value for
this really jump back to the original goel.

404
00:48:58,559 --> 00:49:03,239
And
you have without going to the details I just

405
00:49:03,239 --> 00:49:10,629
want to point out that the cut feature of
prolog is basically use to control this huge

406
00:49:10,630 --> 00:49:15,800
amount of back tracking that one doing in
an

407
00:49:15,800 --> 00:49:18,320
unconstraint search.

408
00:49:18,320 --> 00:49:24,960
So, what prolog does forward backward chaining
is allows you to do is to allows it to ask

409
00:49:24,960 --> 00:49:29,630
existential queries you can ask some query
about is Peter the grandfather of somebody

410
00:49:29,630 --> 00:49:33,030
or
who is Janes grandfather or you could defined.

411
00:49:33,030 --> 00:49:37,640
And maybe that is a good exercise for
you to define the ancestor of so when is an

412
00:49:37,639 --> 00:49:42,509
x in ancestor of y. Then you could ask a
query whether you know Jane is an ancestor

413
00:49:42,510 --> 00:49:51,580
of someone or things like that and the
system will search in your database. It may

414
00:49:51,579 --> 00:49:56,650
it will make inferences by jumping across
such implication signs and eventually dig

415
00:49:56,650 --> 00:50:12,539
out an answer for you. This process is often
called as which is more than what a database

416
00:50:12,539 --> 00:50:17,170
system give you database system gives you
retrieval in an efficient faction. But it

417
00:50:17,170 --> 00:50:21,539
does not do deductions on the way prolog allows
it

418
00:50:21,539 --> 00:50:28,989
you deductive retrieval and in that sense
it is more powerful than the RDBMS system.

419
00:50:28,989 --> 00:50:37,189
And in fact prolog is the complete programming
language anything you can do in java.

420
00:50:37,190 --> 00:50:41,630
For example, you can do in prolog essentially
and logic programming in general is also a

421
00:50:41,630 --> 00:50:52,590
complete programming paradigm essentially
it had it is limitations. So, I had hinted

422
00:50:52,590 --> 00:50:57,640
about that when I said that there is only
a limitation in the format in which you can

423
00:50:57,639 --> 00:51:01,599
write
prolog program it works with only a subset

424
00:51:01,599 --> 00:51:08,190
of logical statements which are known as a
which a which basically say that there can

425
00:51:08,190 --> 00:51:17,869
be only 1 consequent in any implication
statement. So, it is not complete I refer

426
00:51:17,869 --> 00:51:20,619
you back to this problem of 3 blocks that
we had

427
00:51:20,619 --> 00:51:28,079
mentioned in the last class, we are said that
a is on b and b is on c and a is green and

428
00:51:28,079 --> 00:51:32,210
c is
naught green. And we are said that is it true

429
00:51:32,210 --> 00:51:36,079
or does there exist 2 blocks x and y such
that

430
00:51:36,079 --> 00:51:44,289
x is on y and x is green and y is not green
in we cannot solve that problem using in the

431
00:51:44,289 --> 00:51:45,369
forward chaining or backward chaining.

432
00:51:45,369 --> 00:51:48,920
.So, in that sense forward and backward chaining
are naught complete and remember that

433
00:51:48,920 --> 00:51:52,700
when you talk about logical systems we are
interested in sound and complete system. So,

434
00:51:52,699 --> 00:51:55,750
everything that we are doing here is sound,
because it is based on sound rules of

435
00:51:55,750 --> 00:52:01,460
inference it is only the queue completeness
which is the question. So, in the next class

436
00:52:01,460 --> 00:52:09,849
which is the last class of our course, we
will look at this use of resolution method

437
00:52:09,849 --> 00:52:13,319
which
we saw for proportional logic and apply to

438
00:52:13,320 --> 00:52:18,110
in ((Refer Time.) logic. And see that
that particular problem which I will discuss

439
00:52:18,110 --> 00:52:22,910
again in the next class can be solved using
resolution method essentially. So, on the

440
00:52:22,909 --> 00:52:24,599
way we will need to just have a quick look
at

441
00:52:24,599 --> 00:52:30,769
the unification algorithm which is this algorithm
which is used for matching a to terms

442
00:52:30,769 --> 00:52:37,469
like this which is necessary in the implicit
quantifier form that we are using here. So,

443
00:52:37,469 --> 00:52:40,579
I
will stop here and will meet in the next class

444
00:52:40,579 --> 00:52:47,119
for the last time in this course.

445
00:52:47,119 --> 00:52:57,119
.

