1
00:00:10,619 --> 00:00:27,460
So, we meet for the last time semester and
we want to look at the resolution method 

2
00:00:27,460 --> 00:00:30,410
for F
O L essentially. So, as my might have mentioned

3
00:00:30,410 --> 00:00:42,299
earlier it was the method which was
introduced by Alan Robinson in 1965 and since

4
00:00:42,299 --> 00:00:51,890
then it has been used extensively in
theorem proving. So, things like for example,

5
00:00:51,890 --> 00:01:00,088
the proof for last theorem had extensive
support from programs which would based on

6
00:01:00,088 --> 00:01:11,228
resolution method eventually. And it is a
complete method for a proving the theorem

7
00:01:11,228 --> 00:01:16,480
or proving something which uses only one
rule of inference which is the resolution

8
00:01:16,480 --> 00:01:22,930
rule and it does not mean any other essentially.
Now, talking about generally about logic as

9
00:01:22,930 --> 00:01:28,750
we said that logic is basically a system in
which you define a language. And then define

10
00:01:28,750 --> 00:01:32,920
some rules of inference in that language
define a meaning of sentence in that language

11
00:01:32,920 --> 00:01:37,980
and then talk about soundness and
completeness and as you define more and more

12
00:01:37,980 --> 00:01:42,060
expressive languages. So, we have seen
only one step we have moved from professional

13
00:01:42,060 --> 00:01:51,879
logic to personal logic in which we said
that we can talk about variables and quantifies.

14
00:01:51,879 --> 00:01:58,099
Our variables it was shown by godel in

15
00:01:58,099 --> 00:02:02,879
.his theorem which was called Godel’s completeness
theorem that first of the logic is

16
00:02:02,879 --> 00:02:07,769
sound and complete essentially which means
you can always device of a certain logic

17
00:02:07,769 --> 00:02:10,389
system which is sound and which is complete.

18
00:02:10,389 --> 00:02:16,128
And by complete we mean anything which is
entailed by a set of statements can be

19
00:02:16,128 --> 00:02:22,389
derived using that machinery that we have
building essentially. It terms out that that

20
00:02:22,389 --> 00:02:36,498
F O
L is sound complete, but it is only semi decidable.

21
00:02:36,498 --> 00:02:41,400
And what this means is that in
particular it the way it applies to F O L

22
00:02:41,400 --> 00:02:45,180
is as follows that if you gave a true statement
or

23
00:02:45,180 --> 00:02:53,930
statement which is entailed to the system.
And ask the system to prove it then there

24
00:02:53,930 --> 00:02:56,670
exists
a proof for that statement in that system

25
00:02:56,669 --> 00:03:00,199
essentially. And you can always devise a
strategy and you can imagine the strategy

26
00:03:00,199 --> 00:03:05,509
something like breath first search that always
you know find the nearest inference first

27
00:03:05,509 --> 00:03:08,768
and eventually. You will go further and further
away and eventually you will find the proof.

28
00:03:08,769 --> 00:03:14,319
So, you can always devise a strategy to for
finding a proof, but if you give a statement

29
00:03:14,318 --> 00:03:20,938
which is not true then the system in your
halt.

30
00:03:20,938 --> 00:03:28,269
Because there is no proof and the system my
never come out saying that there is no proof

31
00:03:28,269 --> 00:03:33,189
now in the case of proportional logic, because
we have only dealing with a countably,

32
00:03:33,189 --> 00:03:35,739
countable set of propositions when usually
it is finite.

33
00:03:35,739 --> 00:03:41,599
We can always say that at least for finites
set of propositions we can always say that

34
00:03:41,598 --> 00:03:45,679
there is no proof, because we try all combinations
and eventually say that there is no way

35
00:03:45,680 --> 00:03:50,028
that this can this statement can be true.
So, even if it is false you can come out and

36
00:03:50,028 --> 00:03:52,968
say
false in the case of first of logic we cannot

37
00:03:52,968 --> 00:04:00,400
come out and say that yes statement is false.
You can only keep trying essentially which

38
00:04:00,400 --> 00:04:04,968
falls down to saying that you are program
can get in to an infinite loop essentially.

39
00:04:04,968 --> 00:04:07,789
And which is not of course, surprising that
we

40
00:04:07,789 --> 00:04:13,769
have written all of us have written programs
which get into infinite loop. Of course, most

41
00:04:13,769 --> 00:04:19,030
of our programs get it be infinite loop imperative
languages, because we have written it a

42
00:04:19,029 --> 00:04:30,369
long a long loop or long exist criteria in
logic programming or prolog. We do not control

43
00:04:30,370 --> 00:04:36,329
the flow of execution we simply stay it what
is to be done. Of course, we do control it

44
00:04:36,329 --> 00:04:38,859
in
the order in which we write statements, because

45
00:04:38,860 --> 00:04:44,120
there we observed prolog does depth
first search essentially. Top to down and

46
00:04:44,120 --> 00:04:48,680
and left to right which means if you write
statements in a wrong order it is possible

47
00:04:48,680 --> 00:04:55,829
we could get it into a infinite loop. But
even if

48
00:04:55,829 --> 00:05:00,288
you write statements in the correct order
if the statement that you trying to prove

49
00:05:00,288 --> 00:05:03,568
is not
true it can still get into an infinite loop

50
00:05:03,569 --> 00:05:04,569
essentially.

51
00:05:04,569 --> 00:05:05,569
..

52
00:05:05,569 --> 00:05:23,650
So, today, we will we will go back to this
example that we saw and so on a b 

53
00:05:23,649 --> 00:05:39,679
on b c. And
let us on table c and being a supposing given

54
00:05:39,680 --> 00:05:44,978
to you this is a set of facts given to you.
And you want to show that there exists an

55
00:05:44,978 --> 00:06:02,038
x there exists a y such that on x y and being
x

56
00:06:02,038 --> 00:06:12,079
and not green y. This is a goal that you want
to show to be true and that is the facts given

57
00:06:12,079 --> 00:06:21,300
to you now you can see that forward chaining
backward chaining does not make sense

58
00:06:21,300 --> 00:06:26,910
here. Because in your in your data base or
knowledge base there are no implication

59
00:06:26,910 --> 00:06:33,110
statements both forward chaining and backward
chaining move set of allow you to move

60
00:06:33,110 --> 00:06:36,919
across simplification statement. So, if you
have alpha implies beta then if you have alpha

61
00:06:36,918 --> 00:06:42,250
then you can say yes beta is there. Or if
you have the goal beta you can say the goal

62
00:06:42,250 --> 00:06:46,879
alpha can be a goal, but they are no implication
statements here given the set of facts and

63
00:06:46,879 --> 00:06:50,719
we are also show this here. So, you can imagine
that forward chaining and backward

64
00:06:50,720 --> 00:06:53,180
chaining does not work at all essentially.

65
00:06:53,180 --> 00:06:59,810
So, you was of course, convenience your self
is that this statement is true and as human

66
00:06:59,810 --> 00:07:05,250
beings. We might use one technique which is
call looking at different cases of proof by

67
00:07:05,250 --> 00:07:21,408
cases we could say take the case when x is
a and y is b 

68
00:07:21,408 --> 00:07:27,938
or look at b. So, there are 2 cases
that either b is green or b is not green if

69
00:07:27,939 --> 00:07:34,360
b is green then x is equal to b and y is equal
to c

70
00:07:34,360 --> 00:07:40,170
and b is on c and b is green and y is not
b. If b is not green then you can say x is

71
00:07:40,170 --> 00:07:43,840
equal to
a and y is equal to b and a is green and b

72
00:07:43,839 --> 00:07:46,119
is not green. So, whether b is green whether
b is

73
00:07:46,120 --> 00:07:52,090
.not green you can show that in either or
the 2 cases this statement is true. And if

74
00:07:52,089 --> 00:07:56,318
you
further say that this is the only possibility

75
00:07:56,319 --> 00:08:02,439
that one of them is true then you can argue
that

76
00:08:02,439 --> 00:08:08,810
yes this statement must be true essentially.
So, this sequence which has slipped in

77
00:08:08,810 --> 00:08:16,860
between if you argue that one only one of
them is true is essentially a part of classical

78
00:08:16,860 --> 00:08:22,169
logic in classical logic every statement is
either true or false and there is nothing

79
00:08:22,168 --> 00:08:23,168
in
between.

80
00:08:23,168 --> 00:08:32,978
So, it is called law of excluded middle essentially
which some people object to, because

81
00:08:32,979 --> 00:08:42,690
of statements like this, but I can say that
p or not p is true or q or not q is true.

82
00:08:42,690 --> 00:08:48,500
So, this is
a true statement why because of the law of

83
00:08:48,500 --> 00:08:50,490
excluded middle either p must true or not
p

84
00:08:50,490 --> 00:08:56,409
must be true. So, in which case this this
and this true and true and both are true

85
00:08:56,409 --> 00:09:05,809
essentially I can shuffle this and write it
as not p or q or not q or p. And then which

86
00:09:05,809 --> 00:09:12,819
I can
write as p implies q or q implies p. So, this

87
00:09:12,820 --> 00:09:19,170
is true for any 2 statements p and q whether
had any language personal or professional

88
00:09:19,169 --> 00:09:24,789
or high order language. It does not matter
and

89
00:09:24,789 --> 00:09:31,899
if you treat implication as implies in the
causal sense then people have difficulty with

90
00:09:31,899 --> 00:09:37,370
such statement. Because just imagine that
p stands for the earth is flat and q stands

91
00:09:37,370 --> 00:09:45,629
for
the moon green then you are saying that there

92
00:09:45,629 --> 00:09:49,149
is casual connection between these 2
things that the earth is flat. And the moon

93
00:09:49,149 --> 00:09:51,649
is green that either the earth is flat implies
that

94
00:09:51,649 --> 00:09:55,750
the moon is green or the fact that moon is
green implies that the earth is flat essentially.

95
00:09:55,750 --> 00:10:00,070
Now, obviously there is no casual connection
between these 2 statements you take any 2

96
00:10:00,070 --> 00:10:04,740
statements p and q. And this statements is
always true essentially so which is I

97
00:10:04,740 --> 00:10:12,810
sometimes logicians tend to distinguish between
logics with capture cause and

98
00:10:12,809 --> 00:10:16,888
relationship. And we will not go in to that
but rather they would see that instead reading

99
00:10:16,889 --> 00:10:22,789
an implication here. You must read it like
this when you say p implies q it is easier

100
00:10:22,789 --> 00:10:25,698
to
read it as this without getting worked up

101
00:10:25,698 --> 00:10:29,179
about it says that either p is false or q
is true.

102
00:10:29,179 --> 00:10:33,579
That is all you are saying essentially, but
when we read this an implication we have the

103
00:10:33,580 --> 00:10:41,269
sense of being a causal relationship, which
is not really the case essentially. Now, let

104
00:10:41,269 --> 00:10:44,839
us
get back to the resolution method.

105
00:10:44,839 --> 00:10:45,839
..

106
00:10:45,839 --> 00:10:50,899
And before we do that we want to look at this
algorithm called unification algorithm

107
00:10:50,899 --> 00:11:06,448
which is a very famous algorithm. What unification
algorithm does is that it takes 2

108
00:11:06,448 --> 00:11:13,799
patterns while use a more generic term then
formulas and tries to unify them which

109
00:11:13,799 --> 00:11:18,778
means tries to find the substitution which
should make them same essentially. This

110
00:11:18,778 --> 00:11:23,280
patterns are made up of 2 kinds things; one
are one is constant and one is variable. And

111
00:11:23,280 --> 00:11:27,909
variable is something that you can substitute
something for the other and constants are

112
00:11:27,909 --> 00:11:31,339
or
atoms as some people call it cannot be substituted

113
00:11:31,340 --> 00:11:42,660
cannot be changed they have. So, for
the sake of simplicity we will adopt slightly

114
00:11:42,659 --> 00:11:43,938
different notation.

115
00:11:43,938 --> 00:11:44,938
..

116
00:11:44,938 --> 00:12:10,439
Supposing I have this statement man x or,
so let us say not man x or mortal x. Now,

117
00:12:10,440 --> 00:12:12,520
this
statement which is in the mathematical language

118
00:12:12,519 --> 00:12:17,899
of logic has this particular notation that
you have the predicate name. Or it could be

119
00:12:17,899 --> 00:12:25,289
the function name in some situations
followed by brackets followed by the arguments

120
00:12:25,289 --> 00:12:35,490
and then predicates connected using
logical connectives essentially. So, you have

121
00:12:35,490 --> 00:12:39,600
to distinguish between different kinds of
things for the sake this unification algorithm

122
00:12:39,600 --> 00:12:44,259
that is assume that we have a uniform
notation. And the in that notation what this

123
00:12:44,259 --> 00:12:51,860
will look like is a that I will use or here
and

124
00:12:51,860 --> 00:13:14,149
the notation uses the question mark as a thing
for variable. This just for the sake of

125
00:13:14,149 --> 00:13:19,269
understanding this algorithm easily you can
always adopt the algorithm to this notation,

126
00:13:19,269 --> 00:13:25,139
but this is simply easier to use. Because
it is a very uniform list like notation which

127
00:13:25,139 --> 00:13:28,669
those
of you who are use list put be happier to

128
00:13:28,669 --> 00:13:32,139
look at essentially. So, I have moved a or
sign

129
00:13:32,139 --> 00:13:37,169
outside. So, the outer most connective is
first and then the inner connective which

130
00:13:37,169 --> 00:13:41,259
is not
here so not man is written like this so not.

131
00:13:41,259 --> 00:13:45,140
So, this whole thing from this bracket to
this bracket is one expression or term if

132
00:13:45,140 --> 00:13:51,649
you we
just call it a term or a list. So, from here

133
00:13:51,649 --> 00:13:55,450
to here is a list which is so the first one
is always

134
00:13:55,450 --> 00:14:01,480
a connective the first element in the list
is always a connective or a predicate name.

135
00:14:01,480 --> 00:14:04,459
In
this case so here predicate name is differentiated

136
00:14:04,458 --> 00:14:11,289
and you know connective. So, the first
thing is in the case it is a predicate name

137
00:14:11,289 --> 00:14:14,099
man here it is a connective here it is a

138
00:14:14,100 --> 00:14:18,920
.connective. So, this has got this 2 arguments
this whole thing is one thing and this whole

139
00:14:18,919 --> 00:14:27,229
thing. So, it is a list of 3 elements so everything
is a list of some number of elements and

140
00:14:27,230 --> 00:14:33,850
the only thing we need worry about is let
either something is a constant or an atom

141
00:14:33,850 --> 00:14:38,290
as the
list people say or it is a variable essentially

142
00:14:38,289 --> 00:14:40,750
So, and the only the point up out that is
an

143
00:14:40,750 --> 00:14:53,339
atom can only match an atom. So, if I am this
with a if I want to match this with man, so

144
00:14:53,339 --> 00:15:02,920
what I am trying to do I am trying to do something
like resolution. If you recall I have

145
00:15:02,919 --> 00:15:11,370
this clause and I have this clause. And I
have something here I have and I have the

146
00:15:11,370 --> 00:15:17,350
negation of that thing here resolution's rule
if you remember always first of all it works

147
00:15:17,350 --> 00:15:24,209
in the clause form that that you must express
things in c n f like form. And then you have

148
00:15:24,208 --> 00:15:30,129
to look for something verses and it is negation
of a positive literal and negation negative

149
00:15:30,129 --> 00:15:35,208
literal. And in some sense cancel it out essentially
and from there you can derive mortal

150
00:15:35,208 --> 00:15:36,208
x essentially.

151
00:15:36,208 --> 00:15:44,239
So, which means of course, I will have to
match this man x with mortal x with man

152
00:15:44,240 --> 00:15:49,240
sonatas which is work the unification algorithm
will allow it do it will tell me what

153
00:15:49,240 --> 00:15:57,409
values for x will make this true expressions.
The same in one case we have just called it

154
00:15:57,409 --> 00:16:03,980
as list here essentially. So, to match this
with this of course, the predicate name must

155
00:16:03,980 --> 00:16:05,940
be
the same. So, we are just treating it as a

156
00:16:05,940 --> 00:16:11,010
atom here which means it can only match a
another atom which is same a man not can only

157
00:16:11,009 --> 00:16:16,379
match not or can only match or it is only
the variables which can match something else.

158
00:16:16,379 --> 00:16:22,050
So, let us assume that we have an
arbitrary nested pattern which is express

159
00:16:22,049 --> 00:16:25,919
as a list of this kind. And we want to write
a

160
00:16:25,919 --> 00:16:35,209
general algorithm which will find a unifier
for any 2 patterns or a substitution was those

161
00:16:35,210 --> 00:16:40,860
2 patterns which should make it a same this
substitution is called a unifier. And that

162
00:16:40,860 --> 00:16:42,570
is
algorithm that we are looking for unification

163
00:16:42,570 --> 00:16:47,269
algorithm. So, the algorithm is called let
us

164
00:16:47,269 --> 00:16:53,698
say it is called unify I will just sketch
it here and you get fill in the details.

165
00:16:53,698 --> 00:17:11,970
So, let us say x y and what is does is it.
So, will write in a prolog like fusion this

166
00:17:11,970 --> 00:17:26,130
part that
is sub unify x y. So, like we do in very very

167
00:17:26,130 --> 00:17:30,710
often we write a program; we add a third
parameter to make like simpler for us we added

168
00:17:30,710 --> 00:17:37,769
an empty list and call it sub unify sub
unify what this is going to be is the substitution.

169
00:17:37,769 --> 00:17:46,259
So, obviously when we call it when we
call we so x y are any search list arbitrary

170
00:17:46,259 --> 00:18:05,500
list we start of by supplying an empty
substitution. And now we, so x y theta where

171
00:18:05,500 --> 00:18:09,308
theta is the substitution we are trying to
build what is a substitution? Substitution

172
00:18:09,308 --> 00:18:12,920
is a collection variable value essentially
it says

173
00:18:12,920 --> 00:18:17,440
.x equal to x should be substituted by this
y should be substituted by this and so on.

174
00:18:17,440 --> 00:18:24,220
We
should make the 2 patterns same essentially

175
00:18:24,220 --> 00:18:27,180
and this algorithm goes to a series of cases.
I

176
00:18:27,180 --> 00:18:33,808
will just list out the salient once here;
obviously x and y are the same whether they

177
00:18:33,808 --> 00:18:37,589
have
atom or whether they have a list then you

178
00:18:37,589 --> 00:18:47,500
do not need to do anything they already unified
essentially. So, some of main cases are follows.

179
00:18:47,500 --> 00:18:58,630
So, these are cases so I just write it as
f So, let us understand this to mean that

180
00:18:58,630 --> 00:19:07,980
x is a
variable then call another function called

181
00:19:07,980 --> 00:19:24,240
unify x y theta. So, if one of them is a variable
then it is a candidate for being substituted

182
00:19:24,240 --> 00:19:31,230
by something else and that this function unify
will do likewise if y is a variable you can

183
00:19:31,230 --> 00:19:42,680
also call var unify with y x theta somewhere.
So, this order will not be the perfect order

184
00:19:42,680 --> 00:19:59,509
I am writing here if atom x then 
if x equal to

185
00:19:59,509 --> 00:20:17,269
why return theta else. So, if x is an atom
if the argument that we are trying to unify.

186
00:20:17,269 --> 00:20:20,769
So,
this going to be a program, so this x and

187
00:20:20,769 --> 00:20:27,200
y initially will be such bigger patterns but
eventually when we build on into list at some

188
00:20:27,200 --> 00:20:31,670
point they will either a variable or an atom.
So, if it is a variable then we just I call

189
00:20:31,670 --> 00:20:35,120
it call var unify with others argument if
it is an

190
00:20:35,119 --> 00:20:42,149
atom we check whether it is matching or not
essentially. So, if it is not a variable then

191
00:20:42,150 --> 00:20:49,440
if
it is not an atom it must be a list then we

192
00:20:49,440 --> 00:21:00,080
say if length x not equal to length it is
a list.

193
00:21:00,079 --> 00:21:09,109
So, we can compute it is length return fail
if the 2 list are of unequal length then you

194
00:21:09,109 --> 00:21:16,639
can
never make them match else make recursive

195
00:21:16,640 --> 00:21:32,360
cause. So, make I just write it like this
appropriate recursive calls what does it mean

196
00:21:32,359 --> 00:21:40,408
that? For example, if this is one of my
argument this is x and this x has a list of

197
00:21:40,409 --> 00:21:43,289
3 elements the first element is constant.
Or the

198
00:21:43,288 --> 00:21:47,089
second element is this list which is this
whole thing and the third element is this

199
00:21:47,089 --> 00:21:50,369
other
list. So, if I have another list of 3 elements

200
00:21:50,369 --> 00:21:55,918
I can try to match that and then I will make
recursive calls once this with this then another

201
00:21:55,919 --> 00:22:09,370
with this and another with this. So, I
implemental build a substitution that leads

202
00:22:09,369 --> 00:22:12,369
with ask with the task of writing the var
unify

203
00:22:12,369 --> 00:22:21,269
which is really building the substitution
I might have skipped one of the small details

204
00:22:21,269 --> 00:22:33,308
does not matter x. So, when we make a call
to var unify we know that x is a variable.

205
00:22:33,308 --> 00:22:36,918
The
other thing would be a list could be a something

206
00:22:36,919 --> 00:22:46,009
else. So, let us say this is a variable and
y and theta we know that the first thing is

207
00:22:46,009 --> 00:22:53,009
a variable essentially we have to do a few
checks. So, essentially what we really want

208
00:22:53,009 --> 00:23:00,519
do is to say add var egual to y to my theta.

209
00:23:00,519 --> 00:23:06,139
Add one more substitution, but before doing
that I want to do. So, what I what I want

210
00:23:06,140 --> 00:23:07,460
do?

211
00:23:07,460 --> 00:23:22,829
.I want say return bete union var equal to
y. I want to basically add one more substitution

212
00:23:22,829 --> 00:23:27,720
which is the call I am making, but is I may
allowed to do that I have do a couple of

213
00:23:27,720 --> 00:23:41,610
checks first first is if var is already equal
to y. Then you can just return theta you do

214
00:23:41,609 --> 00:23:45,089
not
have to do anything else it could be the case.

215
00:23:45,089 --> 00:23:51,058
For example, I am comparing well these are
not variables does not matter it could that

216
00:23:51,058 --> 00:24:04,799
they are same variables then you just return
theta then if variable occurs return fail.

217
00:24:04,799 --> 00:24:16,259
So, if the variable happens to occur in y
then you

218
00:24:16,259 --> 00:24:21,359
return fail. So, let me use an example to
illustrate by this is needed and this example

219
00:24:21,359 --> 00:24:26,099
is
from book by I can make them what which disturbs

220
00:24:26,099 --> 00:24:29,079
it in this notation.

221
00:24:29,079 --> 00:24:30,079
.

222
00:24:30,079 --> 00:24:46,449
So, the example is as follows naught c’s
x. So, let us say c is stands for the predicate

223
00:24:46,450 --> 00:24:49,400
and
the meaning of sees is that the first argument

224
00:24:49,400 --> 00:24:57,040
can see the second argument. So, for
example, I see you or things like that, and

225
00:24:57,039 --> 00:25:00,099
this is a universally quantified statement.
It is

226
00:25:00,099 --> 00:25:07,859
saying there for all x let us assume that
x is people x cannot see x which means one

227
00:25:07,859 --> 00:25:15,339
cannot see oneself essentially. So, let us
assume that that is a true statement and I

228
00:25:15,339 --> 00:25:17,449
have a
rule which I am let us say I am doing forward

229
00:25:17,450 --> 00:25:21,730
chaining. And the rule is as follows again
I

230
00:25:21,730 --> 00:25:26,480
am writing it in this new notation where instead
of writing the implication sign I will

231
00:25:26,480 --> 00:25:36,390
write an if here then the antecedent and then
the consequent. So, instead of saying this

232
00:25:36,390 --> 00:25:41,440
implies the consequent I am writing it in
this list like notation which may them what

233
00:25:41,440 --> 00:25:45,750
the
use which is quite nice notation to use easy

234
00:25:45,750 --> 00:26:01,410
to process so this rule says.

235
00:26:01,410 --> 00:26:23,019
.So, it always worry about the number of brackets
in this set of thing. So, what does this

236
00:26:23,019 --> 00:26:34,629
tool say? It is a universally quantified statement
how would read it in English. So, feet is

237
00:26:34,630 --> 00:26:39,700
a function remember that in first of the logic
the argument to predicate can only be terms.

238
00:26:39,700 --> 00:26:45,450
And terms are either variables or art or constant
or functions feet of z is function. So, let

239
00:26:45,450 --> 00:26:53,480
us say feet was stands for z's feet. So, this
is saying that is anyone cannot see their

240
00:26:53,480 --> 00:26:56,730
feet
they should diet essentially this may be a

241
00:26:56,730 --> 00:27:01,480
true statement. Of course, know the question
is

242
00:27:01,480 --> 00:27:09,519
shall should this rule and this these 2 rules
can we apply forward chaining here to that

243
00:27:09,519 --> 00:27:21,869
everyone should diet 
not given these facts right. So, let us say

244
00:27:21,869 --> 00:27:26,669
how that particular
statement that we are talking about if variable

245
00:27:26,670 --> 00:27:34,090
occurs y then return failure comes to our.
So, we are trying to unify this with this

246
00:27:34,089 --> 00:27:41,859
remember the antecedent should match.

247
00:27:41,859 --> 00:27:49,099
Now, we will make recursive cause first you
see that this is a list of 2 arguments then

248
00:27:49,099 --> 00:27:51,719
we
will make 2 recursive cause one with the first

249
00:27:51,720 --> 00:27:58,990
argument. Then one with the second
argument then the first call this is an atom

250
00:27:58,990 --> 00:28:02,490
and this matches this. So, that is fine so
the

251
00:28:02,490 --> 00:28:07,490
first recursive call will work and it will
not change theta at all the second recursive

252
00:28:07,490 --> 00:28:11,319
call
has list of 3 elements and this also as a

253
00:28:11,319 --> 00:28:14,740
list of 3 elements. So, that is fine first
we will

254
00:28:14,740 --> 00:28:24,599
make a call with sees and sees here in the
first call this case will come if if this

255
00:28:24,599 --> 00:28:28,819
is an atom
this is same atom then do nothing in the second

256
00:28:28,819 --> 00:28:38,720
call we will do this. So, our algorithm
will say x is a variable. So, I will call

257
00:28:38,720 --> 00:28:43,839
var unify with x and x and z and then in the
last

258
00:28:43,839 --> 00:28:49,558
statement which I will reached there I will
say add x is equal to z I am not writing the

259
00:28:49,558 --> 00:29:00,038
question mark here to theta. So, this will
go into theta so this is if you want to may

260
00:29:00,038 --> 00:29:03,289
these
2 patterns same substitute for x the value

261
00:29:03,289 --> 00:29:08,109
z. And you will have theta now you have x
is

262
00:29:08,109 --> 00:29:18,028
already been put as z here. So, let so whether
you do this here or whether you do this

263
00:29:18,028 --> 00:29:29,970
theta both ways it works in fact the others
other situation is if var as the value in

264
00:29:29,970 --> 00:29:37,899
theta
while you let us call it z in theta.

265
00:29:37,898 --> 00:29:54,699
Then 

266
00:29:54,700 --> 00:30:00,610
if variable already has the value in theta
then call sub unify with that value

267
00:30:00,609 --> 00:30:06,788
essentially.So, in this example we already
have a value z in theta x equal to z. So,

268
00:30:06,788 --> 00:30:11,070
if we
are not change this x that clause will and

269
00:30:11,070 --> 00:30:21,668
we will call with x n. So, we so that recursive
call that sub unify call in this line here

270
00:30:21,669 --> 00:30:26,669
would be with the value of z with z and feet
of z

271
00:30:26,669 --> 00:30:33,259
essentially. So, let us assume that we have
already made this z which is this case where

272
00:30:33,259 --> 00:30:43,798
this is happening now you are trying to unify
this x which is a variable with feet of. So,

273
00:30:43,798 --> 00:30:52,139
this is become z now, so let me put an arrow
here and show that this is become z.

274
00:30:52,140 --> 00:30:59,788
.Because we have substituted x with z now,
we have making a call of a variable z with

275
00:30:59,788 --> 00:31:04,730
a
list which is feet of z which is the y.

276
00:31:04,730 --> 00:31:12,048
So, this x in this statement here sorry this
is well in this statement and this is y and

277
00:31:12,048 --> 00:31:14,918
this
statement says that if var occurs in y then

278
00:31:14,919 --> 00:31:17,399
return fail essentially. So, in this example
z

279
00:31:17,398 --> 00:31:24,678
occurs in this pattern or list. So, the algorithm
should return failure in that we cannot

280
00:31:24,679 --> 00:31:30,380
unify this essentially which is good for us
because otherwise all of us would have have

281
00:31:30,380 --> 00:31:34,010
to
diet. So, this does not apply and this particular

282
00:31:34,009 --> 00:31:40,359
clause here is meant to catch exactly these
kind of a things essentially. So, you can

283
00:31:40,359 --> 00:31:46,678
never unify z with feet of z you know if you
substitute feet of z for z then you will have

284
00:31:46,679 --> 00:31:48,409
to substitute feet of z for this z also then
the z

285
00:31:48,409 --> 00:32:07,130
inside then the z inside then the z inside.
So, it know does not make sense. So, this

286
00:32:07,130 --> 00:32:10,690
unification algorithm.

287
00:32:10,690 --> 00:32:11,690
.

288
00:32:11,690 --> 00:32:30,788
And what it returns is the theta which is
the most general unifier which can may the

289
00:32:30,788 --> 00:32:37,500
2
patterns same. So, for example, if I have

290
00:32:37,500 --> 00:32:58,089
a statement p x z and another statement p
x let

291
00:32:58,089 --> 00:33:08,788
us say constant a. Then you can see that I
can have one unifier which is x is equal to

292
00:33:08,788 --> 00:33:13,700
b
and z equal to a that is a unifier I am not

293
00:33:13,700 --> 00:33:15,789
saying that this algorithm will find this
that a

294
00:33:15,789 --> 00:33:23,230
unifier. So, that is one unifier and there
is another unifier which is simply z equal

295
00:33:23,230 --> 00:33:33,610
to a
this unifier more general then this unifier,

296
00:33:33,609 --> 00:33:35,889
Because it does less amount of substitution
I

297
00:33:35,890 --> 00:33:41,788
.mean anything that this does this also does,
but there is something which this does which

298
00:33:41,788 --> 00:33:47,048
this does not do. So, this is called more
general then this go in to details we will

299
00:33:47,048 --> 00:33:50,668
accept
that there is a partial order of unifiers.

300
00:33:50,669 --> 00:33:58,639
And there is something called the most general
unifier which is called m g u and this algorithm

301
00:33:58,638 --> 00:34:05,689
essentially returns the most general
unifier. So, again without going into details

302
00:34:05,690 --> 00:34:07,710
we just accept the fact that it is desirable
to

303
00:34:07,710 --> 00:34:13,449
find the most general unifier. And the reason
for that is that you can make the most

304
00:34:13,449 --> 00:34:18,449
general inferences from which you can always
derive most specific inferences using the

305
00:34:18,449 --> 00:34:35,349
universal rule essentially. So, I am we do
not have to go in to details over that, but

306
00:34:35,349 --> 00:34:38,099
it
basically the it is son ate algorithm which

307
00:34:38,099 --> 00:34:41,869
is really popular and theorem proving and
we

308
00:34:41,869 --> 00:34:52,789
use it all the time. So, let us address this
problem let us see an how the resolution method

309
00:34:52,789 --> 00:34:53,789
solve this problem.

310
00:34:53,789 --> 00:34:54,789
.

311
00:34:54,789 --> 00:34:58,460
So, to convert to solve a problem with resolution
method you have to convert it in to

312
00:34:58,460 --> 00:35:14,220
clause form. And a clause form is a form which
looks like follow as follows at there is

313
00:35:14,219 --> 00:35:24,909
some number of universal quantifiers x 1 all
x 2 all x n. Then there is a set of clauses

314
00:35:24,909 --> 00:35:33,759
c
one and c 2 and c k such a form such a form

315
00:35:33,760 --> 00:35:40,410
of a formula is clause form when each c I
is

316
00:35:40,409 --> 00:36:00,440
d one or d 2 or d r and each d I is equal
to l I or negation of l I. So, of course,

317
00:36:00,440 --> 00:36:05,650
they inside
part you will recognize as a conjunctive normal

318
00:36:05,650 --> 00:36:14,550
form a set of clauses which are joined by
an and each clause is basically some something.

319
00:36:14,550 --> 00:36:16,269
And each of those things is either a

320
00:36:16,269 --> 00:36:20,610
.literal which means an atomic statement or
the negation of an atomic statement. So, you

321
00:36:20,610 --> 00:36:29,180
have push the negation side all the way inside
and you have removed or thrown way

322
00:36:29,179 --> 00:36:34,409
existential quantifiers likely in our example
we do not really have existential quantifiers.

323
00:36:34,409 --> 00:36:40,339
Or at least we will see in a moment that we
do not have, but we discussed earlier how

324
00:36:40,340 --> 00:36:43,240
to
handle existential quantifiers by using the

325
00:36:43,239 --> 00:36:48,489
solemn functions. And the solemn constants
that can be done and then re arranging any

326
00:36:48,489 --> 00:36:51,179
formula into c n f is something that I am
sure

327
00:36:51,179 --> 00:36:53,899
you have studied how to do that.

328
00:36:53,900 --> 00:36:57,880
And then you move the universal quantifiers
outside one they are together outside you

329
00:36:57,880 --> 00:37:05,400
can just threw it away use quantifier form
which is what we had doing here essentially.

330
00:37:05,400 --> 00:37:13,440
So, what is it, so if you recall the deduction
theorem that we had talked about earlier it

331
00:37:13,440 --> 00:37:19,019
said that to show this follows on this you
are equivalently showing that this and this

332
00:37:19,019 --> 00:37:27,369
entails this. And if you want use the resolution
method you will recall that to use the

333
00:37:27,369 --> 00:37:34,239
resolution method you must take the conclusion
and take it is negation and add it as a

334
00:37:34,239 --> 00:37:40,069
clause to your system essentially. So, this
is already in clause form all we need do is

335
00:37:40,070 --> 00:37:43,539
to
convert this into take it is negation. So,

336
00:37:43,539 --> 00:37:46,659
what it is negation of that? The negation
of that

337
00:37:46,659 --> 00:37:55,389
put on negation sign outside here I will have
to push the negation sign inside, because

338
00:37:55,389 --> 00:37:57,480
I
have to convert it into this clause form.

339
00:37:57,480 --> 00:38:09,400
So, this will become for all x for all y not
one x y

340
00:38:09,400 --> 00:38:27,329
or not green x or green y. So, once this negation
go inside then it go inside the and sign

341
00:38:27,329 --> 00:38:33,409
convert it to an or remember that we have
to push to the inner most place. So, this

342
00:38:33,409 --> 00:38:37,250
will
become not on this will become not green this

343
00:38:37,250 --> 00:38:40,500
negation negation cancel then this will
become green y.

344
00:38:40,500 --> 00:39:11,789
So, let me write this here on x y or green
x or not green y. So, this is one clause express

345
00:39:11,789 --> 00:39:13,860
it
in the implicit quantifier from and those

346
00:39:13,860 --> 00:39:24,559
are other things given to us which is on a
b and

347
00:39:24,559 --> 00:39:34,340
on b c. So, let us forget on table c that
is not useful for us I mean we can write it,

348
00:39:34,340 --> 00:39:43,590
but it
does not help us green a and that is say it

349
00:39:43,590 --> 00:39:51,680
is on table c there any way we do not really
need that. So, we has this clauses and we

350
00:39:51,679 --> 00:39:53,629
want to what is it we want to show that can
we

351
00:39:53,630 --> 00:39:58,460
derive the null clause from this. And we are
going to use the unification algorithm along

352
00:39:58,460 --> 00:40:02,925
the way our example is so simple. That we
do not have to really use a very complicated,

353
00:40:02,925 --> 00:40:10,830
because it is very simple you can match it.
So, let us just try this form this and this

354
00:40:10,829 --> 00:40:14,960
I
substitute x equal to a and y is equal to

355
00:40:14,960 --> 00:40:33,190
b I get green a or not green b. So, I am not
stated

356
00:40:33,190 --> 00:40:38,590
the resolution step or the rule for first
of the logic, but you can see that it is very

357
00:40:38,590 --> 00:40:39,590
similar

358
00:40:39,590 --> 00:40:44,960
.to modified you do you apply the substitution
and in the resolving you have substitution

359
00:40:44,960 --> 00:40:46,550
already applied essentially.

360
00:40:46,550 --> 00:40:51,630
So, because I am saying x equal to a and y
is equal to b then this becomes a this becomes

361
00:40:51,630 --> 00:41:09,019
b and I get this essentially then from this.
And this I can get similarly green b or not

362
00:41:09,019 --> 00:41:37,969
green c is that correct this should be negation
here right and these should not be negation

363
00:41:37,969 --> 00:41:47,779
and this should be negation y. So, all 3 are
long way so negation on x y negation green

364
00:41:47,780 --> 00:41:53,040
x
yes seen that thing there and green y essentially

365
00:41:53,039 --> 00:42:11,349
what we get here is not green a and
green b and not green b or green c. So, is

366
00:42:11,349 --> 00:42:20,420
that correct know and then from this and this
I

367
00:42:20,420 --> 00:42:38,450
can get not green b and from this one and
this one if you can keep track of arrows I

368
00:42:38,449 --> 00:42:49,859
can
get green b and from this and this. So, just

369
00:42:49,860 --> 00:43:01,170
I repeat from on a b and that negated goals.
So, remember this is a negated goal that we

370
00:43:01,170 --> 00:43:07,710
have added we get not green a or green b
then from on b c and the negated goal we get

371
00:43:07,710 --> 00:43:11,260
not green b or green c, but here we have
side not green c.

372
00:43:11,260 --> 00:43:16,450
So, when we resolve this with this we get
not green b only this remains when we resolve

373
00:43:16,449 --> 00:43:22,739
this with this this is green a and this not
green a. So, you get green b and then we not

374
00:43:22,739 --> 00:43:27,819
green b or green b and from that we get the
null clause essentially. So, you can see that

375
00:43:27,820 --> 00:43:32,960
there is simple proof using the resolution
method and if look at a proof carefully you

376
00:43:32,960 --> 00:43:38,280
can
see that it is trying to in some sense say

377
00:43:38,280 --> 00:43:41,700
at the same time that if this formula is to
be

378
00:43:41,699 --> 00:43:46,429
unsatisfiable. If this whole set of formulas
which means only this formula, because this

379
00:43:46,429 --> 00:43:48,769
is
accepted to be true; this is the premises

380
00:43:48,769 --> 00:43:54,590
given to us. If this is to be false then it
entails

381
00:43:54,590 --> 00:44:02,019
same time b must green and b must not be green
and of course, is a contradiction. So, as

382
00:44:02,019 --> 00:44:09,599
we discussed earlier the resolution method
is like a proof for contradiction. So, if

383
00:44:09,599 --> 00:44:12,529
you
remember when we talked about forward chaining

384
00:44:12,530 --> 00:44:19,040
or backward chaining. There is no
way you can move from this set of data to

385
00:44:19,039 --> 00:44:25,059
this conclusion essentially the conclusion
holds that one the exists a block on another

386
00:44:25,059 --> 00:44:26,059
block.

387
00:44:26,059 --> 00:44:32,529
So, that the block top is green that the block
below is not green it is it is not even initially

388
00:44:32,530 --> 00:44:37,560
clear, but it is true. But we cannot derive
it using first forward chaining or back ward

389
00:44:37,559 --> 00:44:43,940
chaining, but in resolution method there is
a very simple small proof for doing that.

390
00:44:43,940 --> 00:44:52,030
So,
in fact, this procedure by Alan Robinson was

391
00:44:52,030 --> 00:45:01,200
a big in logical reasoning automatic
theorem proving. And nowadays, automatic theorem

392
00:45:01,199 --> 00:45:03,710
proving is an, in many different

393
00:45:03,710 --> 00:45:08,409
.place for many different applications essentially.
And the heart of this is resolution

394
00:45:08,409 --> 00:45:18,639
method essentially which is a sound and complete
method for first of the logic

395
00:45:18,639 --> 00:45:31,069
essentially. So, I think we should stop here
with this we will end this course I must say

396
00:45:31,070 --> 00:45:34,880
I
enjoyed teaching the class. And I hope some

397
00:45:34,880 --> 00:45:39,309
of you at least enjoyed the course I think
so.

398
00:45:39,309 --> 00:45:49,309
.

