
1
00:00:00.430 --> 00:00:04.690
Hello everyone and welcome to a series of
lessons on graph analytics with Neo4j.

2
00:00:05.730 --> 00:00:10.520
In this first tutorial we are going to go
briefly through the process of downloading

3
00:00:10.520 --> 00:00:15.420
and installing Neo4j, and
then we'll go ahead and run Neo4j and

4
00:00:16.560 --> 00:00:20.670
provide a brief review of
the Neo4j graphical interface.

5
00:00:20.670 --> 00:00:21.713
So, let's get started.

6
00:00:25.417 --> 00:00:30.480
To download Neo4j,
you'll want to browse to neo4j.com, and

7
00:00:30.480 --> 00:00:36.660
once you're at that URL,
you should see a webpage similar to this.

8
00:00:36.660 --> 00:00:40.030
Neo4j typically will detect which
operating system you're running, but

9
00:00:40.030 --> 00:00:43.340
if you want to download
other versions of Neo4j,

10
00:00:43.340 --> 00:00:46.990
click this link in the upper
right-hand corner to download Neo4j.

11
00:00:46.990 --> 00:00:51.030
We're going to use the community edition,
so we'll click this link right here.

12
00:00:51.030 --> 00:00:52.950
But if you'd like to
explore other releases,

13
00:00:52.950 --> 00:00:54.360
you can click the link down here.

14
00:00:55.550 --> 00:00:58.760
When we click
the Download Community Edition link,

15
00:00:58.760 --> 00:01:02.260
Neo4j should automatically
begin the download.

16
00:01:02.260 --> 00:01:07.220
There are versions of Neo4j for
Windows, Mac, and Linux.

17
00:01:07.220 --> 00:01:10.300
Neo4j is developed with the Java
programming language, so

18
00:01:10.300 --> 00:01:15.240
you'll want to be sure you have the
minimum system requirements to run Neo4j.

19
00:01:15.240 --> 00:01:18.220
We'll provide a link to those system
requirements in the resources of

20
00:01:18.220 --> 00:01:18.750
this video.

21
00:01:19.820 --> 00:01:24.000
This example is with
the Mac OS X operating system.

22
00:01:24.000 --> 00:01:27.829
And we've downloaded the .dmg file and
we can click to open that.

23
00:01:31.126 --> 00:01:35.037
And as is the case with the Mac
applications to install is very

24
00:01:35.037 --> 00:01:36.890
straightforward.

25
00:01:36.890 --> 00:01:40.590
We'll just click and drag this icon
into the Applications folder and

26
00:01:40.590 --> 00:01:43.210
that should automatically install.

27
00:01:43.210 --> 00:01:44.820
Once the application is installed,

28
00:01:44.820 --> 00:01:48.260
we should see it listed in
the Applications folder.

29
00:01:48.260 --> 00:01:50.149
So let's go ahead and run Neo4j.

30
00:01:54.491 --> 00:01:58.078
To run Neo4j, you'll just double-click
on the application's icon.

31
00:01:58.078 --> 00:02:02.770
Neo4j is browser-based, so
it launches a web server, and

32
00:02:02.770 --> 00:02:07.050
it launches a URL specific to Neo4j.

33
00:02:07.050 --> 00:02:10.520
So to activate that server
we'll click the Start button.

34
00:02:10.520 --> 00:02:14.940
If it's your first time using Neo4j
then you probably won't have any graph

35
00:02:14.940 --> 00:02:19.890
databases available to open,
so Neo4j makes it easy for

36
00:02:19.890 --> 00:02:23.650
you by providing a default
graph database of movie data.

37
00:02:24.660 --> 00:02:29.534
To run Neo4j, you click this link and
that should launch your default browser.

38
00:02:33.598 --> 00:02:37.510
Installation on Windows should be
just as straightforward as OS X.

39
00:02:37.510 --> 00:02:41.380
You'll click the same
Download Neo4j button and

40
00:02:41.380 --> 00:02:45.900
when the download page opens,
you'll click Download Community Edition.

41
00:02:45.900 --> 00:02:51.390
Neo4j should recognize you're running
Windows and should download an executable.

42
00:02:51.390 --> 00:02:56.340
Once that downloads we can run it and
we'll step through the same steps

43
00:02:56.340 --> 00:02:59.150
which are typical for
a Windows operating system.

44
00:02:59.150 --> 00:03:02.491
Now I already have Neo4j
installed in my Windows system so

45
00:03:02.491 --> 00:03:05.161
I will be updating my
existing installation.

46
00:03:09.538 --> 00:03:12.210
And Neo4j downloads a Java jar file.

47
00:03:13.340 --> 00:03:17.600
Once the application's installed
it will open the dialog box and

48
00:03:17.600 --> 00:03:19.730
we can start up our web server.

49
00:03:19.730 --> 00:03:23.200
And the same URL is available and
when we click that, our default

50
00:03:23.200 --> 00:03:27.427
browser should be launched and we should
see the same interface we see In OS X.

51
00:03:28.665 --> 00:03:32.810
You should be able to subsequently
run neo4j by accessing the executable

52
00:03:32.810 --> 00:03:34.890
in the Windows Start menu.

53
00:03:34.890 --> 00:03:37.279
So let's take a look at
the neo4j interface.

54
00:03:40.797 --> 00:03:45.150
As I mentioned previously,
neo4j is a browser-based application.

55
00:03:45.150 --> 00:03:49.135
So once the application launches it
should open your default browser and

56
00:03:49.135 --> 00:03:52.110
in my case, I'm using the Chrome browser.

57
00:03:52.110 --> 00:03:56.250
And you should see a URL like
this in the address bar.

58
00:03:56.250 --> 00:04:00.740
Most browsers provide a full-screen
viewing mode, so I'm going to go ahead and

59
00:04:00.740 --> 00:04:04.560
activate that, in this case,
what Chrome calls presentation mode.

60
00:04:04.560 --> 00:04:08.020
The interface for
neo4j consists of three main areas.

61
00:04:08.020 --> 00:04:12.600
There's the command line along the top
where you can issue commands and you can

62
00:04:12.600 --> 00:04:17.030
paste content into the command line and
execute multiple lines at one time.

63
00:04:18.760 --> 00:04:23.330
You can specify these commands
to be one of your favorites.

64
00:04:23.330 --> 00:04:25.600
You can clear the command box.

65
00:04:25.600 --> 00:04:28.738
And you can run, or execute,
the commands with the Play button.

66
00:04:28.738 --> 00:04:33.640
On the left-hand side is an expandable and
collapsible panel that provides

67
00:04:33.640 --> 00:04:36.830
supplementary information about the
database you're currently working with.

68
00:04:37.900 --> 00:04:40.550
There's an option to list your favorites,
and

69
00:04:40.550 --> 00:04:45.020
Neo4j provides an initial
default listing of favorites.

70
00:04:45.020 --> 00:04:47.890
And there's supplementary information and
links to references and

71
00:04:47.890 --> 00:04:50.920
examples and tutorials and so on.

72
00:04:50.920 --> 00:04:55.990
You can also modify the configuration
of your Neo4j installation for

73
00:04:55.990 --> 00:04:57.570
your particular user.

74
00:04:57.570 --> 00:05:00.383
And there's additional information
about the application.

75
00:05:00.383 --> 00:05:04.631
The third area is the main panel in
the middle where the results of all of

76
00:05:04.631 --> 00:05:07.760
the commands that you
execute are displayed.

77
00:05:07.760 --> 00:05:11.220
In fact, this panel itself has been
generated by issuing a command,

78
00:05:11.220 --> 00:05:14.770
which is displayed in
the very top of the panel.

79
00:05:14.770 --> 00:05:18.180
The command is ;play start.

80
00:05:18.180 --> 00:05:23.160
In fact, if I type that command into my
command line I should be able to generate

81
00:05:23.160 --> 00:05:26.088
a duplicate of that panel,
and sure enough, there it is.

82
00:05:26.088 --> 00:05:32.310
The upper right-hand corner of these
panels I can pin the panel to my webpage,

83
00:05:32.310 --> 00:05:34.590
and I can do this with as
many panels as I want and

84
00:05:34.590 --> 00:05:37.820
the window will simply allow
me to scroll up and down.

85
00:05:37.820 --> 00:05:40.520
I can view this particular
panel full screen.

86
00:05:40.520 --> 00:05:43.430
Or it can cancel or close it,
which is what I'm going to do.

87
00:05:43.430 --> 00:05:49.530
Now you can see neo4j makes it very
easy to learn all about graph analytics.

88
00:05:49.530 --> 00:05:53.460
So let's go ahead and get started
with learning how to create and

89
00:05:53.460 --> 00:05:55.220
modify our first graph network.

1
00:00:02.654 --> 00:00:07.877
Next we're going to get started with Neo4j
by creating our first graph network.

2
00:00:08.960 --> 00:00:11.940
To do this,
first we will review a graphical or

3
00:00:11.940 --> 00:00:15.010
a diagrammatic representation
of a graph network.

4
00:00:15.010 --> 00:00:19.350
Then, we'll introduce you to an equivalent
text representation of that network.

5
00:00:19.350 --> 00:00:24.060
Then, we will build on those text
representations in the form of pseudocode,

6
00:00:24.060 --> 00:00:28.240
with the ultimate goal being
to develop an actual script

7
00:00:28.240 --> 00:00:30.010
to create our network in Neo4j.

8
00:00:31.160 --> 00:00:35.423
Then, we'll go ahead and run the script to
create the network, and we'll explore it,

9
00:00:35.423 --> 00:00:37.333
and confirm it structure and content.

10
00:00:41.776 --> 00:00:47.800
You're looking at a simple graph network,
consisting of five nodes and five edges.

11
00:00:47.800 --> 00:00:51.050
Each node represents a person,
an individual.

12
00:00:51.050 --> 00:00:54.450
And, the edges represent
relationships between those people.

13
00:00:54.450 --> 00:00:58.840
Each node has a number associate with it,
N1 through N5.

14
00:00:58.840 --> 00:01:04.732
And, each edge has a corresponding number
associated with it, E1 through E5.

15
00:01:04.732 --> 00:01:09.286
Edges are relationships such
as Harry is known by Tom,

16
00:01:09.286 --> 00:01:11.964
or Julian is coworker of Harry.

17
00:01:11.964 --> 00:01:16.460
We could have more or less edges, but we
wanted to keep things relatively simple,

18
00:01:16.460 --> 00:01:20.050
while still maintaining
a reasonable degree of complexity.

19
00:01:20.050 --> 00:01:23.000
What we want is a script that we can

20
00:01:23.000 --> 00:01:28.270
process with Neo4j in order to
create an actual graph network.

21
00:01:28.270 --> 00:01:31.273
So, let's look at a text
representation of this network.

22
00:01:35.494 --> 00:01:40.879
So, here we list our five nodes and
five edges, and we're going to begin

23
00:01:40.879 --> 00:01:46.940
the process of extending the text
descriptions of our graph network.

24
00:01:46.940 --> 00:01:50.210
I'm going to scroll down briefly,
and just show you the end result, so

25
00:01:50.210 --> 00:01:54.070
you have a better idea of what
the final goal is going to be.

26
00:01:54.070 --> 00:01:58.854
This is the actual code that we're going
to submit to Neo4j in order to create

27
00:01:58.854 --> 00:01:59.745
our network.

28
00:01:59.745 --> 00:02:02.425
But, we're going to back
up a little bit and

29
00:02:02.425 --> 00:02:05.615
look at some simplified
versions of this syntax, so

30
00:02:05.615 --> 00:02:10.627
we can better understand how simple the
graph network relationships really are.

31
00:02:13.374 --> 00:02:18.930
Here, we list the five nodes and
five edges, as you saw just a moment ago.

32
00:02:18.930 --> 00:02:23.340
And down below,
we have a simple notation structure,

33
00:02:23.340 --> 00:02:26.490
which attempts to describe
the five edge relationships.

34
00:02:26.490 --> 00:02:30.600
The first line represents the edge E1.

35
00:02:30.600 --> 00:02:34.820
We can see that the nodes N1 and
N2 are included,

36
00:02:34.820 --> 00:02:40.410
because Harry is known by Tom, and
Tom is node N1 and Harry is node N2.

37
00:02:40.410 --> 00:02:44.950
The same goes for the second line,
the relationship between Julian and Harry.

38
00:02:44.950 --> 00:02:47.770
Julian is co-worker of Harry, and so on.

39
00:02:48.890 --> 00:02:53.830
So, let's take this a step further
by defining our graph network,

40
00:02:53.830 --> 00:02:57.300
so that each node is
a particular type of node.

41
00:02:57.300 --> 00:03:03.410
In this case, we're going to define a node
type as what we're calling a ToyNode.

42
00:03:03.410 --> 00:03:08.040
As we introduce each node and
its relationship with other nodes,

43
00:03:08.040 --> 00:03:11.248
we'll define the node
to be of type ToyNode.

44
00:03:11.248 --> 00:03:16.181
So, on this first line,
N1 goes through e1 to N2.

45
00:03:16.181 --> 00:03:18.822
And, both of those are introduced for
the first time, so

46
00:03:18.822 --> 00:03:21.370
we'll define them as type ToyNode.

47
00:03:21.370 --> 00:03:25.380
But, on the next line, since we
already introduced N2 as type ToyNode,

48
00:03:25.380 --> 00:03:26.970
we don't need to repeat that statement.

49
00:03:28.000 --> 00:03:33.200
And, so we continue in the same manner
with the remaining edge relationships.

50
00:03:33.200 --> 00:03:38.860
Taking this even further, we'll apply
a similar kind of constraint to our edges.

51
00:03:38.860 --> 00:03:44.880
In this case, we'll define our network
such that each edge is a particular type,

52
00:03:44.880 --> 00:03:47.120
which we're calling ToyRelation.

53
00:03:47.120 --> 00:03:50.510
Next, we're going to add
properties to our nodes and edges.

54
00:03:50.510 --> 00:03:54.070
Our nodes can have properties
such as name or job,

55
00:03:54.070 --> 00:03:59.850
so in this case, our first node,
N1, will have the name Tom.

56
00:03:59.850 --> 00:04:04.700
And, the appropriate syntax for this
includes curly braces surrounding the key

57
00:04:04.700 --> 00:04:09.570
value pairs, a colon separating
the key value pairs, and

58
00:04:09.570 --> 00:04:13.500
the values defined within single quotes.

59
00:04:13.500 --> 00:04:17.738
Likewise, each edge may have
a specific type of relationship,

60
00:04:17.738 --> 00:04:20.722
including co-worker, wife, and friend.

61
00:04:22.534 --> 00:04:26.499
So, finally this brings us to the actual
code we're going to use to create our

62
00:04:26.499 --> 00:04:28.130
graph network.

63
00:04:28.130 --> 00:04:31.057
So, let's go ahead and copy this,
and paste it into Neo4j, so

64
00:04:31.057 --> 00:04:32.587
we can take a look at our network.

65
00:04:35.295 --> 00:04:38.410
Here we are, running Neo4j in our browser.

66
00:04:38.410 --> 00:04:43.830
So, I'm going to paste the code that
I just copied from my text file

67
00:04:43.830 --> 00:04:46.360
into the command line
in the Neo4j interface.

68
00:04:47.450 --> 00:04:50.970
And, I'll click the Play button
to execute those commands, and

69
00:04:50.970 --> 00:04:55.250
we'll see the results returned
in this newly displayed panel.

70
00:04:55.250 --> 00:05:00.320
We can see that we have 5 labels added,
5 nodes were created, 13 properties were

71
00:05:00.320 --> 00:05:06.680
set, 5 relationships were created, and the
entire process required 31 milliseconds.

72
00:05:09.000 --> 00:05:14.550
However, we still can't actually view our
graph unless we issue yet another command.

73
00:05:14.550 --> 00:05:19.640
So, let's shuffle to our text file,
and take a look at that command.

74
00:05:19.640 --> 00:05:23.910
What this command does,
is it tries to identify a match

75
00:05:23.910 --> 00:05:29.600
in which a particular node has
a relationship with any other node.

76
00:05:29.600 --> 00:05:33.180
And, then we'll return those nodes and
relationships.

77
00:05:33.180 --> 00:05:36.020
So, we'll go ahead and copy this, and

78
00:05:36.020 --> 00:05:40.280
we'll paste it in to our command line,
and we'll execute.

79
00:05:40.280 --> 00:05:41.970
And, there's our graph.

80
00:05:41.970 --> 00:05:47.360
When we mouse over the nodes, we can see
information displayed on the bottom.

81
00:05:47.360 --> 00:05:51.770
And, when we select those nodes, that
information is displayed permanently along

82
00:05:51.770 --> 00:05:55.810
the bottom,
likewise with edge relationships.

83
00:05:55.810 --> 00:06:01.536
So, we would expect to see things such
as Michelle is the wife of Harry,

84
00:06:01.536 --> 00:06:06.110
Julian is a co-worker of Harry, and so on.

85
00:06:06.110 --> 00:06:09.310
So, it looks like our network
has been created successfully.

86
00:06:09.310 --> 00:06:12.980
We can also display
information in a tabular format

87
00:06:12.980 --> 00:06:15.190
by clicking the Rows icon on the left.

88
00:06:15.190 --> 00:06:19.030
And, we'll see that this information
is not constrained by the directed

89
00:06:19.030 --> 00:06:20.320
nature of our graph.

90
00:06:20.320 --> 00:06:23.585
For example, we see that Harry
has a relationship with Tom,

91
00:06:23.585 --> 00:06:25.910
in which Harry knows Tom.

92
00:06:25.910 --> 00:06:29.386
But likewise, down here,
Tom has a relationship with Harry,

93
00:06:29.386 --> 00:06:30.840
in which Tom knows Harry.

94
00:06:32.400 --> 00:06:35.620
Next, we're going to learn
how to add to this graph and

95
00:06:35.620 --> 00:06:38.777
modify some of the properties
of the nodes and edges.

1
00:00:01.100 --> 00:00:05.230
In this segment, we're going to
learn how to import data into Neo4j.

2
00:00:06.780 --> 00:00:11.440
We will begin by using a fairly simple
spreadsheet consisting of only a few

3
00:00:11.440 --> 00:00:15.550
rows and three columns in a format
that's fairly typical for

4
00:00:15.550 --> 00:00:17.630
importing into a graph database.

5
00:00:17.630 --> 00:00:23.180
We will review the Neo4j CYPHER
script used to perform this import.

6
00:00:23.180 --> 00:00:26.340
And then we'll run the script and
validate the resulting graph.

7
00:00:26.340 --> 00:00:28.790
Then we'll demonstrate
a similar process but

8
00:00:28.790 --> 00:00:32.060
with a more challenging dataset,
consisting of terrorist network data.

9
00:00:33.210 --> 00:00:35.060
We will review this dataset and

10
00:00:35.060 --> 00:00:38.900
the script commands necessary for
performing the import.

11
00:00:38.900 --> 00:00:41.100
And we'll run the script and
explore the resulting graph.

12
00:00:42.180 --> 00:00:46.953
And finally, we will review a third
dataset that you will use yourself to

13
00:00:46.953 --> 00:00:49.780
perform similar data inport operations.

14
00:00:54.323 --> 00:00:57.440
First, let's take a look
at our sample dataset.

15
00:00:57.440 --> 00:01:01.890
This spreadsheet consists of just
a few rows and three columns.

16
00:01:01.890 --> 00:01:03.480
Each column has a heading.

17
00:01:03.480 --> 00:01:08.034
The first column heading is Source,
the second column heading is Target, and

18
00:01:08.034 --> 00:01:10.324
the third column heading is distance.

19
00:01:10.324 --> 00:01:14.762
You can imagine that this might represent
data from a simple road network in which

20
00:01:14.762 --> 00:01:17.570
the Source and
Target values represent towns, and

21
00:01:17.570 --> 00:01:21.963
the distance values represent the actual
distance in miles between the towns.

22
00:01:25.333 --> 00:01:28.492
So let's take a look at
the Neo4j CYPHER script and

23
00:01:28.492 --> 00:01:32.110
see what we will need to do to
import our spreadsheet data.

24
00:01:32.110 --> 00:01:36.010
The first line of code
performs the actual import.

25
00:01:36.010 --> 00:01:40.340
The other three lines of code provide
constraints to the formatting

26
00:01:40.340 --> 00:01:41.670
of that data.

27
00:01:41.670 --> 00:01:45.350
Since our data file is
a comma separated values or

28
00:01:45.350 --> 00:01:49.170
CSV file,
we will need to specify that in our code.

29
00:01:49.170 --> 00:01:51.530
Our file also contains headers.

30
00:01:51.530 --> 00:01:53.718
And if you're using
a Windows operating system,

31
00:01:53.718 --> 00:01:55.758
your file path will look
something like this.

32
00:01:55.758 --> 00:02:00.609
Since we're running Neo4j in a browser,
the file path needs

33
00:02:00.609 --> 00:02:05.365
to conform to the HTTP address
conventions of the word file,

34
00:02:05.365 --> 00:02:10.030
followed by a colon,
followed by three forward slashes and

35
00:02:10.030 --> 00:02:16.307
then the hard disk letter where the file
is located, plus the path to that file.

36
00:02:16.307 --> 00:02:20.046
If you're using Mac OSX,
your command will be similar, but

37
00:02:20.046 --> 00:02:24.490
the file path will probably
look something more like this.

38
00:02:24.490 --> 00:02:28.280
The next three lines specify which
nodes will be the source nodes and

39
00:02:28.280 --> 00:02:30.810
which nodes will be the target nodes.

40
00:02:30.810 --> 00:02:36.020
And the properties will attach to them as
well as defining the relationships and

41
00:02:36.020 --> 00:02:38.860
the properties we will
attach to the relationships.

42
00:02:38.860 --> 00:02:43.800
As we read each line of data n,
we're going to use keyword line,

43
00:02:43.800 --> 00:02:47.330
to specify the individual line
we're currently working on.

44
00:02:47.330 --> 00:02:51.120
We use that here at the end
of our load command and so

45
00:02:51.120 --> 00:02:54.800
we'll have to continue to use it
in the subsequent merge commands.

46
00:02:56.000 --> 00:02:58.990
Our source node variable
is going to be n and

47
00:02:58.990 --> 00:03:03.010
we'll use the MyNode type,
which we've made up ourselves.

48
00:03:03.010 --> 00:03:07.150
We're going to add a Name property
to each of our source nodes.

49
00:03:07.150 --> 00:03:12.880
And we're going to attach the value in
the Source column to that particular node.

50
00:03:12.880 --> 00:03:17.350
Likewise for our target nodes,
we'll use a variable m.

51
00:03:17.350 --> 00:03:19.930
We'll define them as the same type,
MyNode.

52
00:03:21.330 --> 00:03:25.820
We will give them a Name and we will
extract that name from the Target column

53
00:03:25.820 --> 00:03:28.300
on the particular line we're working with.

54
00:03:28.300 --> 00:03:31.590
Finally, we need to define
our edge relationships.

55
00:03:31.590 --> 00:03:34.870
We're going to give each
edge a label of the word TO,

56
00:03:34.870 --> 00:03:40.360
and we're going to add a property called
dist, which represents the distance.

57
00:03:40.360 --> 00:03:43.150
And we'll attach the values
in the distance column

58
00:03:43.150 --> 00:03:45.950
from the particular line
we're currently working on.

59
00:03:45.950 --> 00:03:52.050
So let's go ahead and copy this code and
paste it into Neo4j, and see what happens.

60
00:03:52.050 --> 00:03:54.868
Now, I'm working on a Mac OSX machine, so

61
00:03:54.868 --> 00:03:59.663
I'm going to copy this code down here and
perform the import operation.

62
00:04:02.380 --> 00:04:07.986
So I've pasted the line
of code into Neo4j and

63
00:04:07.986 --> 00:04:10.740
I'll click Execute.

64
00:04:10.740 --> 00:04:12.190
And it takes a few moments to run.

65
00:04:12.190 --> 00:04:16.410
There's not too much data so it shouldn't
take more than just a few seconds.

66
00:04:16.410 --> 00:04:20.794
And now we get the results in which
11 labels, 11 nodes have been added,

67
00:04:20.794 --> 00:04:25.057
25 properties have been set and
14 relationships have been created.

68
00:04:25.057 --> 00:04:27.320
So let's take a look
at this graph network.

69
00:04:27.320 --> 00:04:31.540
We can see that the nodes are listed
all as MyNode and there's our graph.

70
00:04:32.590 --> 00:04:36.345
The edge relationships should all
have different distance values and

71
00:04:36.345 --> 00:04:38.833
each node should be named
a different letter.

72
00:04:38.833 --> 00:04:41.887
Okay, so
let's try a more difficult dataset.

73
00:04:44.849 --> 00:04:48.135
Here is the spreadsheet
containing terrorist data.

74
00:04:48.135 --> 00:04:53.175
The spreadsheet consists of seven
columns with headings such as Country,

75
00:04:53.175 --> 00:04:57.897
ActorName, ActorType, AffiliationTo,
AffiliationStartDate,

76
00:04:57.897 --> 00:05:04.300
AffiliationEndDate, and any aliases
associated with that particular terrorist.

77
00:05:04.300 --> 00:05:09.880
This dataset consists of
over 100,000 rows of data.

78
00:05:09.880 --> 00:05:14.350
Since that could take a very long
time to load into Neo4j, we will be

79
00:05:14.350 --> 00:05:19.980
working with a subset of this dataset
consisting of the first 1,000 rows.

80
00:05:19.980 --> 00:05:23.246
That much data will still
include three countries,

81
00:05:23.246 --> 00:05:26.296
which should be plenty of data for
our purposes.

82
00:05:29.953 --> 00:05:34.911
So here is the script we're going to use
to import the subset of terrorist data,

83
00:05:34.911 --> 00:05:39.420
which shares similarities with
the script we used previously.

84
00:05:39.420 --> 00:05:42.030
But since there are more
columns in our dataset,

85
00:05:42.030 --> 00:05:46.810
we're going to include some additional
properties into our graph network.

86
00:05:46.810 --> 00:05:50.160
The first line of code is very similar

87
00:05:50.160 --> 00:05:53.610
to the load command we've
used in previous datasets.

88
00:05:53.610 --> 00:06:00.720
The second line of code will use
a variable c and a label Country for

89
00:06:00.720 --> 00:06:04.155
the particular nodes representing
the individual countries in the dataset.

90
00:06:05.300 --> 00:06:09.280
In this particular case, we're going to
use the keyword row instead of line to

91
00:06:09.280 --> 00:06:11.990
read our data n, but
it really doesn't matter.

92
00:06:11.990 --> 00:06:16.397
We could use either word as long we
are consistent from command to command.

93
00:06:16.397 --> 00:06:21.136
So we're using the term row and
associating the value in the Country

94
00:06:21.136 --> 00:06:25.891
column with the node that we're
working on in that particular row.

95
00:06:25.891 --> 00:06:30.375
We will do something similar with
nodes that are intended to represent

96
00:06:30.375 --> 00:06:33.570
the actors or
the actual individual terrorists.

97
00:06:33.570 --> 00:06:39.670
We're going to use a variable a and
we will associate a property

98
00:06:39.670 --> 00:06:45.140
called Name, and associate
the ActorName with that property.

99
00:06:45.140 --> 00:06:49.410
We'll also associate
a property named Aliases, and

100
00:06:49.410 --> 00:06:53.250
associate the value in the Aliases
column with that property.

101
00:06:54.590 --> 00:06:59.580
And finally,
we will define a property called Type and

102
00:06:59.580 --> 00:07:03.580
associate the values in the ActorType
column with that property.

103
00:07:04.650 --> 00:07:08.110
We're going to create nodes
representing organizations as well and

104
00:07:08.110 --> 00:07:13.700
we will use the variable o, and
the label Organization for those nodes.

105
00:07:13.700 --> 00:07:18.800
We will attach a single property
to these nodes called Name and

106
00:07:18.800 --> 00:07:23.968
we'll assign the values in
the AffiliationTo column to that property.

107
00:07:23.968 --> 00:07:27.862
Then we're going to define
relationships between the Actors and

108
00:07:27.862 --> 00:07:30.700
the Organizations they're affiliated with.

109
00:07:32.030 --> 00:07:35.835
The relationship label is
going to be AFFILIATED_TO and

110
00:07:35.835 --> 00:07:39.350
we'll define a property called Start.

111
00:07:39.350 --> 00:07:43.525
And we'll assign the values in the
AffiliationStartDate with that property.

112
00:07:43.525 --> 00:07:48.210
Likewise, we will define
a property called End and

113
00:07:48.210 --> 00:07:52.800
assign the values in
the AffiliationEndDate with that property.

114
00:07:52.800 --> 00:07:57.500
And finally, we're going to create
relationships between the countries and

115
00:07:57.500 --> 00:07:59.160
the actors.

116
00:07:59.160 --> 00:08:04.160
In this case, we will define relationships
with the label IS_FROM that will

117
00:08:04.160 --> 00:08:09.890
describe the fact that a particular
actor is from a particular country.

118
00:08:09.890 --> 00:08:13.711
So if all this makes sense,
let's go ahead and copy this script and

119
00:08:13.711 --> 00:08:16.250
paste it into Neo4j, and see the results.

120
00:08:19.270 --> 00:08:22.926
So here we are in Neo4j, and
I'm going to go ahead and

121
00:08:22.926 --> 00:08:27.619
paste that script into the command line,
and we will execute it.

122
00:08:29.951 --> 00:08:37.021
We loaded 1,000 rows of data, which
consists of 658 labels and 658 nodes.

123
00:08:37.021 --> 00:08:42.401
3,464 properties and
1,403 relationships and

124
00:08:42.401 --> 00:08:45.809
it took about two and a half seconds.

125
00:08:45.809 --> 00:08:50.376
So let's look at a small
subset of this network.

126
00:08:55.795 --> 00:09:01.090
Here, we see the equivalent of
the first 25 rows of the dataset.

127
00:09:01.090 --> 00:09:05.120
There's only enough data
such that 1 Country,

128
00:09:05.120 --> 00:09:09.067
8 Actors and 15 Organizations are visible.

129
00:09:09.067 --> 00:09:12.874
Let's go ahead and
change this command to 250.

130
00:09:12.874 --> 00:09:16.550
By clicking on the line of
code in the top of our panel,

131
00:09:16.550 --> 00:09:20.653
it automatically gets pasted
into the command line above.

132
00:09:20.653 --> 00:09:26.085
So all we need to do is add a zero on the
end of our command and execute that again.

133
00:09:26.085 --> 00:09:30.752
Now we have a much larger,
more complex graph,

134
00:09:30.752 --> 00:09:34.262
but we still only have one country.

135
00:09:34.262 --> 00:09:36.918
In order to see more than one country,

136
00:09:36.918 --> 00:09:43.010
we'll need to render the entire 1,000
rows of our terrorist data subset.

137
00:09:43.010 --> 00:09:46.710
But in so doing, we will have a difficult
time viewing the entire graph.

138
00:09:47.720 --> 00:09:51.950
The community edition of Neo4j
is limited in its ability to

139
00:09:51.950 --> 00:09:53.810
navigate a graph network.

140
00:09:53.810 --> 00:09:56.440
But I'm going to show you
a little trick by editing

141
00:09:56.440 --> 00:10:00.290
the HTML behind the scenes to
scale the view of our graph.

142
00:10:01.770 --> 00:10:04.862
So let's go ahead and
render all 1,000 rows.

143
00:10:10.923 --> 00:10:15.473
So most recent versions of the major
browsers provide the ability to go behind

144
00:10:15.473 --> 00:10:18.080
the scenes and edit the HTML.

145
00:10:18.080 --> 00:10:23.024
So the trick is to find a place on
the viewing panel that does not have

146
00:10:23.024 --> 00:10:24.096
any objects.

147
00:10:24.096 --> 00:10:27.971
So that when you right-click and
inspect the element,

148
00:10:27.971 --> 00:10:30.864
you'll be inspecting the viewing area.

149
00:10:30.864 --> 00:10:33.257
Neo4j uses SVG graphics, or

150
00:10:33.257 --> 00:10:38.360
Scalable Vector Graphics to
render its graph networks.

151
00:10:38.360 --> 00:10:42.373
And SVG uses a g element,
which can be seen here on the right.

152
00:10:42.373 --> 00:10:48.452
So in order to change the scale of our
view, we simply need to double-click and

153
00:10:48.452 --> 00:10:53.903
add scale, open parentheses, and
the scale factor that we'd like.

154
00:10:53.903 --> 00:11:00.938
We hit Return and
the graph network now is zoomed out.

155
00:11:00.938 --> 00:11:06.823
I'm going to try to position it so
we can see at least two countries,

156
00:11:06.823 --> 00:11:09.610
and I'll close my HTML panel.

157
00:11:10.920 --> 00:11:12.371
And so now we can view two countries.

158
00:11:12.371 --> 00:11:18.456
We can see Albania in the upper region,
and Afghanistan in the lower right.

159
00:11:18.456 --> 00:11:21.388
And we can see that there are actors and

160
00:11:21.388 --> 00:11:26.970
organizations that have
relationships with both countries.

161
00:11:26.970 --> 00:11:31.384
Now there are add ons to Neo4j that
make navigating a graph network a little

162
00:11:31.384 --> 00:11:32.155
easier, but

163
00:11:32.155 --> 00:11:37.074
this trick is convenient for those of you
who have not added any Neo4j extensions.

164
00:11:40.998 --> 00:11:45.355
The last thing that we're going to do
is take a look at the sample dataset of

165
00:11:45.355 --> 00:11:50.208
gene-disease associations, and give you
an idea what's going to be expected of

166
00:11:50.208 --> 00:11:53.930
you in the accompanying assignment for
this module.

167
00:11:53.930 --> 00:11:58.060
This data consists of
information associating

168
00:11:58.060 --> 00:12:01.200
different genes with different diseases.

169
00:12:01.200 --> 00:12:05.638
The spreadsheet consists of
columns with headings for geneId,

170
00:12:05.638 --> 00:12:10.610
geneSymbol, geneName, diseaseId,

171
00:12:10.610 --> 00:12:15.870
the diseaseName, the score that
represents the extent to which that gene

172
00:12:15.870 --> 00:12:19.302
is associated with that
particular disease.

173
00:12:19.302 --> 00:12:25.554
The NumberofPubmed articles
containing that information.

174
00:12:25.554 --> 00:12:26.944
The associationTypes,

175
00:12:26.944 --> 00:12:31.584
there are up to three different types of
associations between a gene and a disease.

176
00:12:31.584 --> 00:12:34.113
And then the sources of data and

177
00:12:34.113 --> 00:12:39.084
information that confirm this
gene disease relationship.

178
00:12:39.084 --> 00:12:44.830
Now this dataset contains
over 400,000 rows of data.

179
00:12:44.830 --> 00:12:48.322
So if you have difficulty
importing this entire dataset,

180
00:12:48.322 --> 00:12:53.810
then you'll be better off extracting
the first few thousand rows.

181
00:12:53.810 --> 00:12:57.507
So you're goal will be to
define the load statement,

182
00:12:57.507 --> 00:13:02.437
which includes a CSV with headers,
that will allow you to import enough

183
00:13:02.437 --> 00:13:07.384
data into Neo4j to give you an idea
that you've done it successfully.

1
00:00:01.730 --> 00:00:05.250
We've already learned a little
about the Neo4j interface.

2
00:00:05.250 --> 00:00:08.200
And we've learned how to create
a relatively simple graph with it.

3
00:00:09.390 --> 00:00:10.240
In this lecture,

4
00:00:10.240 --> 00:00:14.660
we're going to learn how to add
another node and an edge to the graph.

5
00:00:16.210 --> 00:00:19.880
We'll also go through
the process of adding a node and

6
00:00:19.880 --> 00:00:21.230
edge incorrectly to the graph.

7
00:00:22.360 --> 00:00:24.710
And we'll learn how to
correct that mistake.

8
00:00:24.710 --> 00:00:28.874
And finally we'll learn how to modify
an existing node's information.

9
00:00:34.748 --> 00:00:39.275
Okay, so here's our network that we
created in the previous lecture.

10
00:00:39.275 --> 00:00:41.790
The first modification
that we want to make,

11
00:00:41.790 --> 00:00:43.980
is adding a single node to the network.

12
00:00:45.080 --> 00:00:49.440
So let's say that Julian has a fiance and

13
00:00:49.440 --> 00:00:53.380
her name is Joyce and
she works as a store clerk.

14
00:00:53.380 --> 00:00:57.090
So let's look at the code that we're
going to use to make that modification.

15
00:00:58.340 --> 00:01:01.940
So this process involves two steps or
two separate commands.

16
00:01:01.940 --> 00:01:06.780
First command requires you to find the
node that you want to add the new node to.

17
00:01:06.780 --> 00:01:12.689
So we use the match command and
we specify the ToyNode named Julian.

18
00:01:12.689 --> 00:01:17.716
Once that command is issued then
we'll use the merge command and

19
00:01:17.716 --> 00:01:22.370
define the relation between Julian and
the new node.

20
00:01:22.370 --> 00:01:25.385
And it's going to be fiancee.

21
00:01:25.385 --> 00:01:28.920
And then the new node
will also be a ToyNode.

22
00:01:28.920 --> 00:01:32.680
And the name is Joyce, and
her job is store clerk.

23
00:01:32.680 --> 00:01:36.537
So let's go ahead and
copy both these lines of code.

24
00:01:36.537 --> 00:01:41.430
And we'll paste them into our command
line, and we'll run these commands.

25
00:01:41.430 --> 00:01:44.112
And the results that
are returned look good.

26
00:01:44.112 --> 00:01:50.057
Neo4j says that it has added 1 label,
created 1 node, set 3 properties,

27
00:01:50.057 --> 00:01:56.102
created 1 relationship, and
it's required 55 milliseconds to execute.

28
00:01:56.102 --> 00:01:58.240
So let's look at that network.

29
00:01:58.240 --> 00:02:00.110
Maybe the easiest way to
view an existing network,

30
00:02:00.110 --> 00:02:04.900
if it's the only one you're working on and
you know the constraints involved,

31
00:02:04.900 --> 00:02:10.290
just ToyNodes, is to expand the panel on
the left and just click the ToyNode node.

32
00:02:10.290 --> 00:02:13.550
And you'll easily see the new network.

33
00:02:13.550 --> 00:02:16.600
And we can confirm that Joyce
has been successfully added, and

34
00:02:16.600 --> 00:02:21.220
when we select that,
we can see that her job is store clerk.

35
00:02:21.220 --> 00:02:26.090
The command that was issued automatically
by clicking the ToyNode button in

36
00:02:26.090 --> 00:02:31.270
the panel Is a little different than what
we've been using to view our networks.

37
00:02:31.270 --> 00:02:34.310
But they both work essentially
the same with this particular network.

38
00:02:35.340 --> 00:02:38.888
So next let's see what happens if
we do something incorrectly, and

39
00:02:38.888 --> 00:02:40.389
how to correct the mistake.

40
00:02:45.521 --> 00:02:46.313
So to do this,

41
00:02:46.313 --> 00:02:50.282
we'll need to get back to our original
network without the added node.

42
00:02:50.282 --> 00:02:54.198
And maybe the easiest way to do
this is to delete everything and

43
00:02:54.198 --> 00:02:56.320
recreate our original network.

44
00:02:57.370 --> 00:02:59.470
So first I'm going to copy and

45
00:02:59.470 --> 00:03:03.060
paste command to delete all
of the nodes and edges.

46
00:03:03.060 --> 00:03:08.440
You'll find this command in the getting
started video supplementary resources.

47
00:03:09.600 --> 00:03:13.260
It involves the match command and
I'm matching all nodes and

48
00:03:13.260 --> 00:03:17.620
all relationships and I'm deleting
those nodes and relationships.

49
00:03:17.620 --> 00:03:22.173
So let's issue that command,
which should say it's deleted 6 nodes and

50
00:03:22.173 --> 00:03:24.532
6 relationships, and sure enough.

51
00:03:24.532 --> 00:03:30.109
Neo4J's command line has a nice feature of
maintaining a history of the commands and

52
00:03:30.109 --> 00:03:34.910
so in OSX we can use the command+up
arrow to cycle through the commands and

53
00:03:34.910 --> 00:03:39.160
find the original create command
that created our network.

54
00:03:39.160 --> 00:03:41.950
On Windows, it's a CTRL+up arrow command.

55
00:03:41.950 --> 00:03:46.320
So here I've found that command and
I'm going to re-execute it.

56
00:03:46.320 --> 00:03:49.100
And we have our original
network back again.

57
00:03:49.100 --> 00:03:50.390
Let's view that network.

58
00:03:52.931 --> 00:03:53.810
And there it is.

59
00:03:55.220 --> 00:04:00.480
So let's say for whatever reason I am
not quite fully understanding how to add

60
00:04:00.480 --> 00:04:05.380
an additional node to an existing network,
and I want to use the create command.

61
00:04:07.190 --> 00:04:09.870
For example, I might be thinking that

62
00:04:09.870 --> 00:04:13.370
this statement right here will
accomplish the same kind of thing.

63
00:04:13.370 --> 00:04:18.930
By using the create command and
by specifying a ToyNode named Julian.

64
00:04:20.070 --> 00:04:23.370
Well, if we go ahead and
give that a try let's see what happens.

65
00:04:23.370 --> 00:04:29.700
So I'll copy this command and I will paste
it into my command line and execute it.

66
00:04:31.500 --> 00:04:36.530
And it says it's added 2 labels and
created 2 nodes and set 4 properties.

67
00:04:37.680 --> 00:04:42.806
And if we look at this, We

68
00:04:42.806 --> 00:04:49.240
see we've actually got another node named
Julian who has a relationship with Joyce.

69
00:04:49.240 --> 00:04:54.970
So that much is correct, but it's not
the same Julian from the original network.

70
00:04:54.970 --> 00:04:56.110
So how do we undo this?

71
00:04:57.200 --> 00:05:03.200
Well, we'll need to specify the Julian
that has a relationship with Joyce and

72
00:05:03.200 --> 00:05:05.760
delete both the Julian and
the Joyce notes.

73
00:05:08.750 --> 00:05:12.160
So here we'll use the match
command once again.

74
00:05:12.160 --> 00:05:18.400
And we'll identify the node, the ToyNode,
with the name Joyce and any relationship

75
00:05:18.400 --> 00:05:24.540
she has with any other node should be
deleted in addition to that other node.

76
00:05:24.540 --> 00:05:26.665
Let's go ahead and copy this.

77
00:05:26.665 --> 00:05:32.000
And we'll paste it into our
command line and execute.

78
00:05:32.000 --> 00:05:34.840
And it says it deleted 2 nodes and
deleted 1 relationship.

79
00:05:35.920 --> 00:05:37.740
Let's view our network again.

80
00:05:39.850 --> 00:05:41.660
And it's back to normal.

81
00:05:41.660 --> 00:05:46.416
So that's one example of how you can
intuitively figure out how to correct

82
00:05:46.416 --> 00:05:47.731
certain mistakes.

83
00:05:53.826 --> 00:05:58.400
Next we're going to modify
information of an existing node.

84
00:05:58.400 --> 00:06:04.790
So if you remember when we first created
our network, Harry didn't have a job.

85
00:06:04.790 --> 00:06:08.370
So let's go ahead and add a job to Harry.

86
00:06:08.370 --> 00:06:08.910
First of all,

87
00:06:08.910 --> 00:06:13.700
we'll need to actually select
the node by using the match command.

88
00:06:14.810 --> 00:06:16.520
So we'll issue that here and

89
00:06:16.520 --> 00:06:20.760
we'll specify that that node
name must be equal to Harry.

90
00:06:22.070 --> 00:06:25.540
And then we're going to
use the set command and

91
00:06:25.540 --> 00:06:30.210
specify that job will be equal to drummer.

92
00:06:30.210 --> 00:06:31.430
So let's go ahead and copy that.

93
00:06:33.450 --> 00:06:35.958
And we'll paste it and execute it.

94
00:06:37.954 --> 00:06:42.410
And the results that are returned
says that one property has been set.

95
00:06:42.410 --> 00:06:45.400
But let's say that Harry does
more than just play drums.

96
00:06:45.400 --> 00:06:48.740
Let's say that he can
also play lead guitar.

97
00:06:48.740 --> 00:06:52.810
So in this case we will be
adding an additional property

98
00:06:52.810 --> 00:06:57.050
to a property that already exists and
we'll see how Neo4J handles that.

99
00:06:57.050 --> 00:07:02.150
It's a relatively simple modification
we make, in which we're setting

100
00:07:02.150 --> 00:07:06.535
the job key equal to the existing job key

101
00:07:06.535 --> 00:07:12.620
+ an additional value to that key,
in this case, lead guitarist.

102
00:07:12.620 --> 00:07:14.303
So let's copy that statement.

103
00:07:16.729 --> 00:07:19.730
And we'll paste it and execute it.

104
00:07:19.730 --> 00:07:24.229
And we get a similar result returned and
then let's look at our network.

105
00:07:27.771 --> 00:07:33.480
And when we select Harry, sure enough
now we see that he has two jobs.

106
00:07:33.480 --> 00:07:34.890
They're separated by a comma.

107
00:07:34.890 --> 00:07:37.660
One is drummer and one is lead guitarist.

108
00:07:37.660 --> 00:07:40.474
There's much more you can do with Neo4j,
but

109
00:07:40.474 --> 00:07:44.373
we'll want to move on and
learn some more advanced capabilities

110
00:07:44.373 --> 00:07:48.212
that work us closer towards
managing our big data challenges.

1
00:00:02.250 --> 00:00:06.207
Next, we will talk about
Path Analytics using Cypher,

2
00:00:06.207 --> 00:00:09.100
the query language for Neo4j.

3
00:00:09.100 --> 00:00:13.450
Here's the listing of the various
queries we will be demonstrating.

4
00:00:26.288 --> 00:00:30.040
There are some things that Cypher
is capable of doing very well.

5
00:00:30.040 --> 00:00:33.350
And there are other things that
require a little bit of creativity

6
00:00:33.350 --> 00:00:36.230
in order to get the results
that you're looking for.

7
00:00:36.230 --> 00:00:38.450
And we'll show you some examples of that.

8
00:00:38.450 --> 00:00:43.718
It's also important to keep in mind
that because we're working with paths,

9
00:00:43.718 --> 00:00:47.285
which are an official
structure in graph networks,

10
00:00:47.285 --> 00:00:50.867
each one of these examples
includes a new variable.

11
00:00:50.867 --> 00:00:54.221
Which in this case,
we're using the letter p to represent for

12
00:00:54.221 --> 00:00:58.410
the actual path objects that
we're going to be returning.

13
00:00:58.410 --> 00:01:03.030
You may also see the complete word
path instead of just the single letter

14
00:01:03.030 --> 00:01:05.580
p to represent these objects.

15
00:01:05.580 --> 00:01:09.950
We're going to continue to use the data
set of a simple road network that we've

16
00:01:09.950 --> 00:01:14.970
already been using in previous
demonstrations that contains 11 nodes and

17
00:01:14.970 --> 00:01:16.000
14 edges.

18
00:01:18.610 --> 00:01:21.180
So the first query we're
going to demonstrate

19
00:01:21.180 --> 00:01:24.040
is finding a path between specific nodes.

20
00:01:24.040 --> 00:01:28.739
So this would be very much like trying
to find a root between two different

21
00:01:28.739 --> 00:01:30.829
locations in our road network.

22
00:01:30.829 --> 00:01:35.079
In this case, we're going to find
a path between the node named H and

23
00:01:35.079 --> 00:01:36.210
the node named P.

24
00:01:37.980 --> 00:01:41.411
To do this,
we'll use the match command and

25
00:01:41.411 --> 00:01:47.162
we'll say match p which is a variable
we're using to represent our path,

26
00:01:47.162 --> 00:01:50.524
= node a, going through an edge to node c.

27
00:01:50.524 --> 00:01:55.766
There's something slightly different about
this edge, and that is that we're using

28
00:01:55.766 --> 00:02:00.573
a star to represent an arbitrary number
of edges in sequence between a and c, and

29
00:02:00.573 --> 00:02:05.980
we'll be returning all of those edges
that are necessary to complete the path.

30
00:02:05.980 --> 00:02:09.530
And in this case we only want
to return a single path.

31
00:02:09.530 --> 00:02:13.440
So when we submit this query,
we see this path.

32
00:02:13.440 --> 00:02:17.240
It consists of eight nodes and
seven edges.

33
00:02:17.240 --> 00:02:19.490
And it begins with H and ends with P.

34
00:02:21.600 --> 00:02:25.980
Now, another common function we
will use frequently with paths

35
00:02:25.980 --> 00:02:28.650
is finding the length
between two specific nodes.

36
00:02:29.800 --> 00:02:35.010
So we'll issue the same two lines of code
and then we'll use this new command,

37
00:02:35.010 --> 00:02:37.950
length, to return an actual value.

38
00:02:37.950 --> 00:02:41.070
We want to be returning an actual path.

39
00:02:41.070 --> 00:02:42.780
And we just want a single value.

40
00:02:42.780 --> 00:02:45.820
And when we submit this query,
we get the result seven.

41
00:02:45.820 --> 00:02:49.800
And we can see that by visually
inspecting the graph or our seven edges.

42
00:02:49.800 --> 00:02:52.310
But because most networks
are much more complex than this,

43
00:02:52.310 --> 00:02:56.130
we would need to understand the necessary
query to return the length.

44
00:02:58.005 --> 00:03:00.160
And ideally,
in the case of our road network,

45
00:03:00.160 --> 00:03:04.710
we would want to find the shortest
path between those two nodes.

46
00:03:04.710 --> 00:03:06.220
So in this case we're introducing yet

47
00:03:06.220 --> 00:03:10.150
another new command specific
to paths called shortestPath.

48
00:03:10.150 --> 00:03:13.149
We will use the same variable key, and

49
00:03:13.149 --> 00:03:18.794
the same descriptions in our syntax,
in connecting node a with node c.

50
00:03:18.794 --> 00:03:23.815
And in this case, were going to look for
the shortest path between node a and

51
00:03:23.815 --> 00:03:29.090
node p, and we're going to return that
path as well as the length of that path.

52
00:03:29.090 --> 00:03:30.680
And we're just going to
return a single path.

53
00:03:31.760 --> 00:03:36.870
And when we submit this query,
we get a path that's five nodes and

54
00:03:36.870 --> 00:03:41.990
four edges long and if we look at
the text results that are returned,

55
00:03:41.990 --> 00:03:46.020
we'll see a length displayed
in the length column.

56
00:03:46.020 --> 00:03:49.980
And that value is 4, and we can see
that by visually inspecting our graph.

57
00:03:52.430 --> 00:03:57.236
The next query we are going to demonstrate
is intended to illustrate that

58
00:03:57.236 --> 00:04:00.010
there may be more than one shortest path.

59
00:04:00.010 --> 00:04:04.967
And so, we may want to know all of the
possible shortest paths in order to make

60
00:04:04.967 --> 00:04:08.300
a choice between which one we prefer.

61
00:04:08.300 --> 00:04:14.290
So we'll be using a command that is built
into Neo4j called, allShortestPaths.

62
00:04:14.290 --> 00:04:18.580
We'll be issuing a similar query
to what we issued previously,

63
00:04:18.580 --> 00:04:24.610
we're going to try to find all of the
shortest paths between node a and node p.

64
00:04:24.610 --> 00:04:30.160
And instead of the letters a and c, we're
using the terms source and destination.

65
00:04:30.160 --> 00:04:34.640
But the results that we're going to return
will actually be in the form of an array.

66
00:04:34.640 --> 00:04:39.640
We're using a new term, extract,
which is based on the following.

67
00:04:39.640 --> 00:04:44.370
Assuming we have matched our path p,
we want to identify

68
00:04:44.370 --> 00:04:48.670
all of the nodes in p and
extract their names.

69
00:04:48.670 --> 00:04:53.790
And we'll return these names as a listing,
which we'll call the variable paths.

70
00:04:53.790 --> 00:04:59.700
If there's more than one shortest path,
we'll get multiple listings of node names.

71
00:04:59.700 --> 00:05:04.120
So when we submit this query, the results
are listed in the rows display and

72
00:05:04.120 --> 00:05:08.130
we see there are actually
two shortest paths.

73
00:05:08.130 --> 00:05:11.643
They each have five nodes and four edges.

74
00:05:13.987 --> 00:05:18.060
Now, we may want to issue a query
that finds the shortest path but

75
00:05:18.060 --> 00:05:22.300
with particular constraints or
conditions that we place on them.

76
00:05:23.640 --> 00:05:28.160
So in this case we still want
to find the shortest path, but

77
00:05:28.160 --> 00:05:33.010
in this case we may want to constrain
the path length to be greater

78
00:05:33.010 --> 00:05:35.530
than a particular value, in this case 5.

79
00:05:35.530 --> 00:05:39.050
And then, we want to return essentially
the same results that we returned in

80
00:05:39.050 --> 00:05:40.480
the previous query.

81
00:05:40.480 --> 00:05:45.180
But we'll also want to return the length
of the resulting path just so

82
00:05:45.180 --> 00:05:47.610
we have that information conveniently.

83
00:05:47.610 --> 00:05:49.310
So when we issue this command

84
00:05:50.360 --> 00:05:55.230
we get a path with length six
between node A and node P.

85
00:05:55.230 --> 00:05:59.870
So it's clearly longer than the shortest
path that we had found earlier.

86
00:06:02.710 --> 00:06:06.940
Now that we are somewhat familiar
with the two shortest path commands,

87
00:06:06.940 --> 00:06:09.750
the shortest path, or a single path and

88
00:06:09.750 --> 00:06:14.730
the all shortest paths command or multiple
shortest paths, we're going to use

89
00:06:14.730 --> 00:06:20.530
that in a little bit of a creative way
to return the diameter of the graph.

90
00:06:20.530 --> 00:06:22.750
And if you remember from
a previous lecture,

91
00:06:22.750 --> 00:06:25.500
the definition of
the diameter of the graph

92
00:06:25.500 --> 00:06:31.170
is actually the longest continuous
path between two nodes in the graph.

93
00:06:31.170 --> 00:06:37.440
So by using the shortest path command, but
returning all possible shortest paths,

94
00:06:37.440 --> 00:06:42.725
we're actually going to get the longest
path included in those results returned.

95
00:06:42.725 --> 00:06:44.400
Now, if we look carefully at this script,

96
00:06:44.400 --> 00:06:47.590
it is a little different
than our previous scripts.

97
00:06:47.590 --> 00:06:52.570
In this case our match command is
matching all nodes of type MyNode.

98
00:06:52.570 --> 00:06:55.272
We'll assign those to the variable end.

99
00:06:55.272 --> 00:07:01.001
We're also matching the all nodes of type
MyNode and assigning that to variable m.

100
00:07:01.001 --> 00:07:02.570
So these matches are the same.

101
00:07:02.570 --> 00:07:07.543
But we want to place a constraint
such that the nodes in n are not

102
00:07:07.543 --> 00:07:09.933
the same as the nodes in m, and

103
00:07:09.933 --> 00:07:15.981
then we want to find all of the shortest
paths between unique nodes in n and m.

104
00:07:15.981 --> 00:07:21.410
And return the names of those nodes as
well as the length of that resulting path.

105
00:07:21.410 --> 00:07:24.470
And the trick is to use
the command order by.

106
00:07:24.470 --> 00:07:29.360
And so for those of you who are familiar
already with SQL query language,

107
00:07:29.360 --> 00:07:31.030
you'll recognize order by.

108
00:07:31.030 --> 00:07:34.610
You'll also recognize the descend command.

109
00:07:34.610 --> 00:07:40.310
So if we order the resulting paths
by their length in descending order,

110
00:07:40.310 --> 00:07:45.470
and only return 1, that path should
actually be the longest path.

111
00:07:45.470 --> 00:07:47.420
And that's equal to
the diameter of the graph.

112
00:07:48.500 --> 00:07:52.440
So when we submit this query,
here's the results that we get.

113
00:07:52.440 --> 00:07:57.349
We get a path between node e and
node l with length severn.

114
00:07:57.349 --> 00:08:02.809
Or maybe it occurs to you that maybe this
is not the only diameter of the graph,

115
00:08:02.809 --> 00:08:05.340
the only path with length of seven.

116
00:08:06.580 --> 00:08:13.488
So we can modify our query just a little
bit and change the limit from one to five.

117
00:08:13.488 --> 00:08:16.029
And we'll see the results.

118
00:08:16.029 --> 00:08:18.240
And sure enough,
we actually get five paths.

119
00:08:19.730 --> 00:08:22.650
And 3 of those have length 7.

120
00:08:22.650 --> 00:08:26.757
So there are actually three
distinct paths which qualify as

121
00:08:26.757 --> 00:08:29.391
a diameter of this particular graph.
